!function(t,e,r){var n,i=function(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,n.get?n:{enumerable:!0,get:function(){return t[r]}})}})),e.default=t,Object.freeze(e)}(r),s=(n={})&&"object"==typeof n&&"default"in n?n:{default:n};let o={};"undefined"!=typeof self&&(o=self),t.nativeCrypto=o.msCrypto||o.crypto||{},t.nativeSubtle=null;try{t.nativeSubtle=(null==t.nativeCrypto?void 0:t.nativeCrypto.subtle)||(null==t.nativeCrypto?void 0:t.nativeCrypto.webkitSubtle)||null}catch(Mr){console.warn("Cannot get subtle from crypto",Mr)}class c{static isArrayBuffer(t){return"[object ArrayBuffer]"===Object.prototype.toString.call(t)}static toArrayBuffer(t){const e=this.toUint8Array(t);return e.byteOffset||e.length?e.buffer.slice(e.byteOffset,e.byteOffset+e.length):e.buffer}static toUint8Array(t){if("undefined"!=typeof Buffer&&Buffer.isBuffer(t))return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);if(this.isArrayBuffer(t))return new Uint8Array(t);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}}function a(t){return"undefined"!=typeof Buffer&&Buffer.isBuffer(t)?new Uint8Array(t):c.isArrayBufferView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t)}class h{static isHex(t){return"string"==typeof t&&/^[a-z0-9]+$/i.test(t)}static isBase64(t){return"string"==typeof t&&/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}static isBase64Url(t){return"string"==typeof t&&/^[a-zA-Z0-9-_]+$/i.test(t)}static ToString(t,e="utf8"){const r=a(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){const e=a(t);if("undefined"!=typeof btoa){const t=this.ToString(e,"binary");return btoa(t)}return Buffer.from(e).toString("base64")}static FromBase64(t){const e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!h.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){const e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!h.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t){const e=unescape(encodeURIComponent(t)),r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r.buffer}static ToUtf8String(t){const e=a(t),r=String.fromCharCode.apply(null,e);return decodeURIComponent(escape(r))}static FromBinary(t){const e=t.length,r=new Uint8Array(e);for(let n=0;n<e;n++)r[n]=t.charCodeAt(n);return r.buffer}static ToBinary(t){const e=a(t);let r="";const n=e.length;for(let i=0;i<n;i++)r+=String.fromCharCode(e[i]);return r}static ToHex(t){const e=a(t),r=[],n=e.length;for(let i=0;i<n;i++){const t=e[i].toString(16);r.push(1===t.length?"0"+t:t)}return r.join("")}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!h.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e="0"+e);const r=new Uint8Array(e.length/2);for(let n=0;n<e.length;n+=2){const t=e.slice(n,n+2);r[n/2]=parseInt(t,16)}return r.buffer}static Base64Padding(t){const e=4-t.length%4;if(e<4)for(let r=0;r<e;r++)t+="=";return t}static formatString(t){return(null==t?void 0:t.replace(/[\n\r\t ]/g,""))||""}}function u(t,e,r,n){var i,s=arguments.length,o=s<3?e:null===n?n=Object.getOwnPropertyDescriptor(e,r):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,r,n);else for(var c=t.length-1;c>=0;c--)(i=t[c])&&(o=(s<3?i(o):s>3?i(e,r,o):i(e,r))||o);return s>3&&o&&Object.defineProperty(e,r,o),o}function f(t,e,r,i){return new(r||(r=Promise))((function(s,o){function c(t){try{h(i.next(t))}catch(n){o(n)}}function a(t){try{h(i.throw(t))}catch(n){o(n)}}function h(t){var e;t.done?s(t.value):(e=t.value,e instanceof r?e:new r((function(t){t(e)}))).then(c,a)}h((i=i.apply(t,e||[])).next())}))}function l(t){var e={exports:{}};return t(e,e.exports),e.exports}function y(t,e){let r=0;if(1===t.length)return t[0];for(let n=t.length-1;n>=0;n--)r+=t[t.length-1-n]*Math.pow(2,e*n);return r}function d(t,e,r=-1){const n=r;let i=t,s=0,o=Math.pow(2,e);for(let c=1;c<8;c++){if(t<o){let t;if(n<0)t=new ArrayBuffer(c),s=c;else{if(n<c)return new ArrayBuffer(0);t=new ArrayBuffer(n),s=n}const r=new Uint8Array(t);for(let n=c-1;n>=0;n--){const t=Math.pow(2,n*e);r[s-n-1]=Math.floor(i/t),i-=r[s-n-1]*t}return t}o*=Math.pow(2,e)}return new ArrayBuffer(0)}const w="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",v=Math.log(2);var m,A,g,b=function(t){if(t.__esModule)return t;var e=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(t).forEach((function(r){var n=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(e,r,n.get?n:{enumerable:!0,get:function(){return t[r]}})})),e}(Object.freeze({__proto__:null,getUTCDate:function(t){return new Date(t.getTime()+6e4*t.getTimezoneOffset())},getParametersValue:function(t,e,r){return t instanceof Object==0?r:e in t?t[e]:r},bufferToHexCodes:function(t,e=0,r=t.byteLength-e,n=!1){let i="";for(const s of new Uint8Array(t,e,r)){const t=s.toString(16).toUpperCase();1===t.length&&(i+="0"),i+=t,n&&(i+=" ")}return i.trim()},checkBufferParams:function(t,e,r,n){return e instanceof ArrayBuffer==0?(t.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===e.byteLength?(t.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(t.error="Wrong parameter: inputOffset less than zero",!1):n<0?(t.error="Wrong parameter: inputLength less than zero",!1):!(e.byteLength-r-n<0&&(t.error="End of input reached before message was fully decoded (inconsistent offset and length values)",1))},utilFromBase:y,utilToBase:d,utilConcatBuf:function(...t){let e=0,r=0;for(const s of t)e+=s.byteLength;const n=new ArrayBuffer(e),i=new Uint8Array(n);for(const s of t)i.set(new Uint8Array(s),r),r+=s.byteLength;return n},utilConcatView:function(...t){let e=0,r=0;for(const s of t)e+=s.length;const n=new ArrayBuffer(e),i=new Uint8Array(n);for(const s of t)i.set(s,r),r+=s.length;return i},utilDecodeTC:function(){const t=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const e=0===t[0]&&0==(128&t[1]);(255===t[0]&&128&t[1]||e)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(e);for(let o=0;o<this.valueHex.byteLength;o++)r[o]=0;r[0]=128&t[0];const n=y(r,8),i=new ArrayBuffer(this.valueHex.byteLength),s=new Uint8Array(i);for(let o=0;o<this.valueHex.byteLength;o++)s[o]=t[o];return s[0]&=127,y(s,8)-n},utilEncodeTC:function(t){const e=t<0?-1*t:t;let r=128;for(let n=1;n<8;n++){if(e<=r){if(t<0){const t=d(r-e,8,n);return new Uint8Array(t)[0]|=128,t}let i=d(e,8,n),s=new Uint8Array(i);if(128&s[0]){const t=i.slice(0),e=new Uint8Array(t);i=new ArrayBuffer(i.byteLength+1),s=new Uint8Array(i);for(let r=0;r<t.byteLength;r++)s[r+1]=e[r];s[0]=0}return i}r*=Math.pow(2,8)}return new ArrayBuffer(0)},isEqualBuffer:function(t,e){if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),n=new Uint8Array(e);for(let i=0;i<r.length;i++)if(r[i]!==n[i])return!1;return!0},padNumber:function(t,e){const r=t.toString(10);if(e<r.length)return"";const n=e-r.length,i=new Array(n);for(let s=0;s<n;s++)i[s]="0";return i.join("").concat(r)},toBase64:function(t,e=!1,r=!1,n=!1){let i=0,s=0,o=0,c="";const a=e?p:w;if(n){let e=0;for(let r=0;r<t.length;r++)if(0!==t.charCodeAt(r)){e=r;break}t=t.slice(e)}for(;i<t.length;){const e=t.charCodeAt(i++);i>=t.length&&(s=1);const n=t.charCodeAt(i++);i>=t.length&&(o=1);const h=t.charCodeAt(i++),u=e>>2,f=(3&e)<<4|n>>4;let l=(15&n)<<2|h>>6,y=63&h;1===s?l=y=64:1===o&&(y=64),c+=r?64===l?`${a.charAt(u)}${a.charAt(f)}`:64===y?`${a.charAt(u)}${a.charAt(f)}${a.charAt(l)}`:`${a.charAt(u)}${a.charAt(f)}${a.charAt(l)}${a.charAt(y)}`:`${a.charAt(u)}${a.charAt(f)}${a.charAt(l)}${a.charAt(y)}`}return c},fromBase64:function(t,e=!1,r=!1){const n=e?p:w;function i(t){for(let e=0;e<64;e++)if(n.charAt(e)===t)return e;return 64}function s(t){return 64===t?0:t}let o=0,c="";for(;o<t.length;){const e=i(t.charAt(o++)),r=o>=t.length?0:i(t.charAt(o++)),n=o>=t.length?0:i(t.charAt(o++)),a=o>=t.length?0:i(t.charAt(o++)),h=s(e)<<2|s(r)>>4,u=(15&s(r))<<4|s(n)>>2,f=(3&s(n))<<6|s(a);c+=String.fromCharCode(h),64!==n&&(c+=String.fromCharCode(u)),64!==a&&(c+=String.fromCharCode(f))}if(r){let t=-1;for(let e=c.length-1;e>=0;e--)if(0!==c.charCodeAt(e)){t=e;break}c=-1!==t?c.slice(0,t+1):""}return c},arrayBufferToString:function(t){let e="";const r=new Uint8Array(t);for(const n of r)e+=String.fromCharCode(n);return e},stringToArrayBuffer:function(t){const e=t.length,r=new ArrayBuffer(e),n=new Uint8Array(r);for(let i=0;i<e;i++)n[i]=t.charCodeAt(i);return r},nearestPowerOf2:function(t){const e=Math.log(t)/v,r=Math.floor(e),n=Math.round(e);return r===n?r:n},clearProps:function(t,e){for(const r of e)delete t[r]}})),k=l((function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.fromBER=at,e.compareSchema=ht,e.verifySchema=function(t,e){if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const r=at(t);return-1===r.offset?{verified:!1,result:r.result}:ht(r.result,r.result,e)},e.fromJSON=function(){},e.RawData=e.Repeated=e.Any=e.Choice=e.TIME=e.Duration=e.DateTime=e.TimeOfDay=e.DATE=e.GeneralizedTime=e.UTCTime=e.CharacterString=e.GeneralString=e.VisibleString=e.GraphicString=e.IA5String=e.VideotexString=e.TeletexString=e.PrintableString=e.NumericString=e.UniversalString=e.BmpString=e.RelativeObjectIdentifier=e.Utf8String=e.ObjectIdentifier=e.Enumerated=e.Integer=e.BitString=e.OctetString=e.Null=e.Set=e.Sequence=e.Boolean=e.EndOfContent=e.Constructed=e.Primitive=e.BaseBlock=e.ValueBlock=e.HexBlock=void 0;const r=[new Uint8Array([1])];class n{constructor(t={}){this.blockLength=(0,b.getParametersValue)(t,"blockLength",0),this.error=(0,b.getParametersValue)(t,"error",""),this.warnings=(0,b.getParametersValue)(t,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in t?t.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:(0,b.bufferToHexCodes)(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const i=t=>class extends t{constructor(t={}){super(t),this.isHexOnly=(0,b.getParametersValue)(t,"isHexOnly",!1),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(t,e,r){return!1===(0,b.checkBufferParams)(this,t,e,r)?-1:0===new Uint8Array(t,e,r).length?(this.warnings.push("Zero buffer length"),e):(this.valueHex=t.slice(e,e+r),this.blockLength=r,e+r)}toBER(t=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===t?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isHexOnly=this.isHexOnly,t.valueHex=(0,b.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}};e.HexBlock=i;class s extends(i(n)){constructor(t={}){super(),"idBlock"in t?(this.isHexOnly=(0,b.getParametersValue)(t.idBlock,"isHexOnly",!1),this.valueHex=(0,b.getParametersValue)(t.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=(0,b.getParametersValue)(t.idBlock,"tagClass",-1),this.tagNumber=(0,b.getParametersValue)(t.idBlock,"tagNumber",-1),this.isConstructed=(0,b.getParametersValue)(t.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(t=!1){let e,r,n=0;switch(this.tagClass){case 1:n|=0;break;case 2:n|=64;break;case 3:n|=128;break;case 4:n|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(n|=32),this.tagNumber<31&&!this.isHexOnly){if(e=new ArrayBuffer(1),r=new Uint8Array(e),!t){let t=this.tagNumber;t&=31,n|=t,r[0]=n}return e}if(!1===this.isHexOnly){const i=(0,b.utilToBase)(this.tagNumber,7),s=new Uint8Array(i),o=i.byteLength;if(e=new ArrayBuffer(o+1),r=new Uint8Array(e),r[0]=31|n,!t){for(let t=0;t<o-1;t++)r[t+1]=128|s[t];r[o]=s[o-1]}return e}if(e=new ArrayBuffer(this.valueHex.byteLength+1),r=new Uint8Array(e),r[0]=31|n,!1===t){const t=new Uint8Array(this.valueHex);for(let e=0;e<t.length-1;e++)r[e+1]=128|t[e];r[this.valueHex.byteLength]=t[t.length-1]}return e}fromBER(t,e,r){if(!1===(0,b.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);if(0===n.length)return this.error="Zero buffer length",-1;switch(192&n[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&n[0]),this.isHexOnly=!1;const i=31&n[0];if(31!==i)this.tagNumber=i,this.blockLength=1;else{let t=1;this.valueHex=new ArrayBuffer(255);let e=255,r=new Uint8Array(this.valueHex);for(;128&n[t];){if(r[t-1]=127&n[t],t++,t>=n.length)return this.error="End of input reached before message was fully decoded",-1;if(t===e){e+=255;const t=new ArrayBuffer(e),n=new Uint8Array(t);for(let e=0;e<r.length;e++)n[e]=r[e];this.valueHex=new ArrayBuffer(e),r=new Uint8Array(this.valueHex)}}this.blockLength=t+1,r[t-1]=127&n[t];const i=new ArrayBuffer(t),s=new Uint8Array(i);for(let n=0;n<t;n++)s[n]=r[n];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex),r.set(s),this.blockLength<=9?this.tagNumber=(0,b.utilFromBase)(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.tagClass=this.tagClass,t.tagNumber=this.tagNumber,t.isConstructed=this.isConstructed,t}}class o extends n{constructor(t={}){super(),"lenBlock"in t?(this.isIndefiniteForm=(0,b.getParametersValue)(t.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=(0,b.getParametersValue)(t.lenBlock,"longFormUsed",!1),this.length=(0,b.getParametersValue)(t.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(t,e,r){if(!1===(0,b.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);if(0===n.length)return this.error="Zero buffer length",-1;if(255===n[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===n[0],!0===this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(128&n[0]),!1===this.longFormUsed)return this.length=n[0],this.blockLength=1,e+this.blockLength;const i=127&n[0];if(i>8)return this.error="Too big integer",-1;if(i+1>n.length)return this.error="End of input reached before message was fully decoded",-1;const s=new Uint8Array(i);for(let o=0;o<i;o++)s[o]=n[o+1];return 0===s[i-1]&&this.warnings.push("Needlessly long encoded length"),this.length=(0,b.utilFromBase)(s,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=i+1,e+this.blockLength}toBER(t=!1){let e,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=128),e;if(!0===this.longFormUsed){const n=(0,b.utilToBase)(this.length,8);if(n.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(e=new ArrayBuffer(n.byteLength+1),!0===t)return e;const i=new Uint8Array(n);r=new Uint8Array(e),r[0]=128|n.byteLength;for(let t=0;t<n.byteLength;t++)r[t+1]=i[t];return e}return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=this.length),e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isIndefiniteForm=this.isIndefiniteForm,t.longFormUsed=this.longFormUsed,t.length=this.length,t}}class c extends n{constructor(t={}){super(t)}static blockName(){return"valueBlock"}fromBER(t,e,r){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}toBER(t=!1){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}}e.ValueBlock=c;class a extends n{constructor(t={},e=c){super(t),"name"in t&&(this.name=t.name),"optional"in t&&(this.optional=t.optional),"primitiveSchema"in t&&(this.primitiveSchema=t.primitiveSchema),this.idBlock=new s(t),this.lenBlock=new o(t),this.valueBlock=new e(t)}static blockName(){return"BaseBlock"}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}toBER(t=!1){let e;const r=this.idBlock.toBER(t),n=this.valueBlock.toBER(!0);this.lenBlock.length=n.byteLength;const i=this.lenBlock.toBER(t);let s;if(e=(0,b.utilConcatBuf)(r,i),s=!1===t?this.valueBlock.toBER(t):new ArrayBuffer(this.lenBlock.length),e=(0,b.utilConcatBuf)(e,s),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===t){const t=new Uint8Array(r);t[0]=0,t[1]=0}e=(0,b.utilConcatBuf)(e,r)}return e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.idBlock=this.idBlock.toJSON(),t.lenBlock=this.lenBlock.toJSON(),t.valueBlock=this.valueBlock.toJSON(),"name"in this&&(t.name=this.name),"optional"in this&&(t.optional=this.optional),"primitiveSchema"in this&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}}e.BaseBlock=a;class h extends c{constructor(t={}){super(t),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=(0,b.getParametersValue)(t,"isHexOnly",!0)}fromBER(t,e,r){if(!1===(0,b.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);if(0===n.length)return this.warnings.push("Zero buffer length"),e;this.valueHex=new ArrayBuffer(n.length);const i=new Uint8Array(this.valueHex);for(let s=0;s<n.length;s++)i[s]=n[s];return this.blockLength=r,e+r}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueHex=(0,b.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t.isHexOnly=this.isHexOnly,t}}class u extends a{constructor(t={}){super(t,h),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}e.Primitive=u;class f extends c{constructor(t={}){super(t),this.value=(0,b.getParametersValue)(t,"value",[]),this.isIndefiniteForm=(0,b.getParametersValue)(t,"isIndefiniteForm",!1)}fromBER(t,e,r){const n=e,i=r;if(!1===(0,b.checkBufferParams)(this,t,e,r))return-1;if(0===new Uint8Array(t,e,r).length)return this.warnings.push("Zero buffer length"),e;let s=e;for(;(!0===this.isIndefiniteForm?1:r)>0;){const e=ct(t,s,r);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(s=e.offset,this.blockLength+=e.result.blockLength,r-=e.result.blockLength,this.value.push(e.result),!0===this.isIndefiniteForm&&e.result.constructor.blockName()===d.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===d.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=t.slice(n,n+i),s}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(t);e=(0,b.utilConcatBuf)(e,n)}return e}static blockName(){return"ConstructedValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.isIndefiniteForm=this.isIndefiniteForm,t.value=[];for(let r=0;r<this.value.length;r++)t.value.push(this.value[r].toJSON());return t}}class l extends a{constructor(t={}){super(t,f),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(t,e,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}}e.Constructed=l;class y extends c{constructor(t={}){super(t)}fromBER(t,e,r){return e}toBER(t=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class d extends a{constructor(t={}){super(t,y),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}e.EndOfContent=d;class w extends c{constructor(t={}){super(t),this.value=(0,b.getParametersValue)(t,"value",!1),this.isHexOnly=(0,b.getParametersValue)(t,"isHexOnly",!1),"valueHex"in t?this.valueHex=t.valueHex.slice(0):(this.valueHex=new ArrayBuffer(1),!0===this.value&&(new Uint8Array(this.valueHex)[0]=255))}fromBER(t,e,r){if(!1===(0,b.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(n.length);const i=new Uint8Array(this.valueHex);for(let s=0;s<n.length;s++)i[s]=n[s];return this.value=0!==b.utilDecodeTC.call(this),this.blockLength=r,e+r}toBER(t=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t.isHexOnly=this.isHexOnly,t.valueHex=(0,b.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class p extends a{constructor(t={}){super(t,w),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}e.Boolean=p;class v extends l{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}e.Sequence=v;class m extends l{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}e.Set=m;class A extends a{constructor(t={}){super(t,n),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(t,e,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,e+r>t.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):e+r}toBER(t=!1){const e=new ArrayBuffer(2);if(!0===t)return e;const r=new Uint8Array(e);return r[0]=5,r[1]=0,e}}e.Null=A;class g extends(i(f)){constructor(t={}){super(t),this.isConstructed=(0,b.getParametersValue)(t,"isConstructed",!1)}fromBER(t,e,r){let n=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,n=f.prototype.fromBER.call(this,t,e,r),-1===n)return n;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===d.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(e!==k.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,n=super.fromBER(t,e,r),this.blockLength=r;return n}toBER(t=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,t);let e=new ArrayBuffer(this.valueHex.byteLength);return!0===t||0===this.valueHex.byteLength||(e=this.valueHex.slice(0)),e}static blockName(){return"OctetStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=(0,b.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class k extends a{constructor(t={}){super(t,g),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(t,e,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),e):super.fromBER(t,e,r)}static blockName(){return"OctetString"}isEqual(t){return t instanceof k!=0&&JSON.stringify(this)===JSON.stringify(t)}}e.OctetString=k;class S extends(i(f)){constructor(t={}){super(t),this.unusedBits=(0,b.getParametersValue)(t,"unusedBits",0),this.isConstructed=(0,b.getParametersValue)(t,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(t,e,r){if(0===r)return e;let n=-1;if(!0===this.isConstructed){if(n=f.prototype.fromBER.call(this,t,e,r),-1===n)return n;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===d.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(e!==B.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[t].valueBlock.unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[t].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return n}if(!1===(0,b.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);if(this.unusedBits=i[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(i.length-1);const s=new Uint8Array(this.valueHex);for(let o=0;o<r-1;o++)s[o]=i[o+1];return this.blockLength=i.length,e+r}toBER(t=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,t);if(!0===t)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const e=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),n=new Uint8Array(r);n[0]=this.unusedBits;for(let i=0;i<this.valueHex.byteLength;i++)n[i+1]=e[i];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.unusedBits=this.unusedBits,t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=(0,b.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class B extends a{constructor(t={}){super(t,S),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(t,e,r){return 0===r?e:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(t,e,r))}isEqual(t){return t instanceof B!=0&&JSON.stringify(this)===JSON.stringify(t)}}e.BitString=B;class E extends(i(c)){constructor(t={}){super(t),"value"in t&&(this.valueDec=t.value)}set valueHex(t){this._valueHex=t.slice(0),t.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,t.byteLength>0&&(this._valueDec=b.utilDecodeTC.call(this)))}get valueHex(){return this._valueHex}set valueDec(t){this._valueDec=t,this.isHexOnly=!1,this._valueHex=(0,b.utilEncodeTC)(t)}get valueDec(){return this._valueDec}fromDER(t,e,r,n=0){const i=this.fromBER(t,e,r);if(-1===i)return i;const s=new Uint8Array(this._valueHex);if(0===s[0]&&0!=(128&s[1])){const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}else if(0!==n&&this._valueHex.byteLength<n){n-this._valueHex.byteLength>1&&(n=this._valueHex.byteLength+1);const t=new ArrayBuffer(n);new Uint8Array(t).set(s,n-this._valueHex.byteLength),this._valueHex=t.slice(0)}return i}toDER(t=!1){const e=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&e[0]):{const t=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(t);r[0]=0,r.set(e,1),this._valueHex=t.slice(0)}break;case 0===e[0]&&0==(128&e[1]):{const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}}return this.toBER(t)}fromBER(t,e,r){const n=super.fromBER(t,e,r);return-1===n?n:(this.blockLength=r,e+r)}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}toString(){function t(t,e){const r=new Uint8Array([0]);let n=new Uint8Array(t),i=new Uint8Array(e),s=n.slice(0);const o=s.length-1;let c=i.slice(0);const a=c.length-1;let h=0,u=0;for(let f=a<o?o:a;f>=0;f--,u++){switch(!0){case u<c.length:h=s[o-u]+c[a-u]+r[0];break;default:h=s[o-u]+r[0]}switch(r[0]=h/10,!0){case u>=s.length:s=(0,b.utilConcatView)(new Uint8Array([h%10]),s);break;default:s[o-u]=h%10}}return r[0]>0&&(s=(0,b.utilConcatView)(r,s)),s.slice(0)}function e(t){if(t>=r.length)for(let e=r.length;e<=t;e++){const t=new Uint8Array([0]);let n=r[e-1].slice(0);for(let e=n.length-1;e>=0;e--){const r=new Uint8Array([(n[e]<<1)+t[0]]);t[0]=r[0]/10,n[e]=r[0]%10}t[0]>0&&(n=(0,b.utilConcatView)(t,n)),r.push(n)}return r[t]}function n(t,e){let r=0,n=new Uint8Array(t),i=new Uint8Array(e),s=n.slice(0);const o=s.length-1;let c=i.slice(0);const a=c.length-1;let h,u=0;for(let f=a;f>=0;f--,u++)switch(h=s[o-u]-c[a-u]-r,!0){case h<0:r=1,s[o-u]=h+10;break;default:r=0,s[o-u]=h}if(r>0)for(let f=o-a+1;f>=0;f--,u++){if(h=s[o-u]-r,!(h<0)){r=0,s[o-u]=h;break}r=1,s[o-u]=h+10}return s.slice()}const i=8*this._valueHex.byteLength-1;let s,o=new Uint8Array(8*this._valueHex.byteLength/3),c=0;const a=new Uint8Array(this._valueHex);let h="",u=!1;for(let r=this._valueHex.byteLength-1;r>=0;r--){s=a[r];for(let r=0;r<8;r++){if(1==(1&s))switch(c){case i:o=n(e(c),o),h="-";break;default:o=t(o,e(c))}c++,s>>=1}}for(let r=0;r<o.length;r++)o[r]&&(u=!0),u&&(h+="0123456789".charAt(o[r]));return!1===u&&(h+="0123456789".charAt(0)),h}}class K extends a{constructor(t={}){super(t,E),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(t){return t instanceof K?this.valueBlock.isHexOnly&&t.valueBlock.isHexOnly?(0,b.isEqualBuffer)(this.valueBlock.valueHex,t.valueBlock.valueHex):this.valueBlock.isHexOnly===t.valueBlock.isHexOnly&&this.valueBlock.valueDec===t.valueBlock.valueDec:t instanceof ArrayBuffer&&(0,b.isEqualBuffer)(this.valueBlock.valueHex,t)}convertToDER(){const t=new K({valueHex:this.valueBlock.valueHex});return t.valueBlock.toDER(),t}convertFromDER(){const t=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,e=new K({valueHex:this.valueBlock.valueHex});return e.valueBlock.fromDER(e.valueBlock.valueHex,0,e.valueBlock.valueHex.byteLength,t),e}}e.Integer=K;class x extends K{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}e.Enumerated=x;class N extends(i(n)){constructor(t={}){super(t),this.valueDec=(0,b.getParametersValue)(t,"valueDec",-1),this.isFirstSid=(0,b.getParametersValue)(t,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===(0,b.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let i=new Uint8Array(this.valueHex);for(let c=0;c<r&&(i[c]=127&n[c],this.blockLength++,0!=(128&n[c]));c++);const s=new ArrayBuffer(this.blockLength),o=new Uint8Array(s);for(let c=0;c<this.blockLength;c++)o[c]=i[c];return this.valueHex=s.slice(0),i=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===i[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,b.utilFromBase)(i,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const n=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|n[t];return r[this.blockLength-1]=n[this.blockLength-1],e}const n=(0,b.utilToBase)(this.valueDec,7);if(0===n.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(n.byteLength),!1===t){const t=new Uint8Array(n);r=new Uint8Array(e);for(let e=0;e<n.byteLength-1;e++)r[e]=128|t[e];r[n.byteLength-1]=t[n.byteLength-1]}return e}toString(){let t="";if(!0===this.isHexOnly)t=(0,b.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let e=this.valueDec;this.valueDec<=39?t="0.":this.valueDec<=79?(t="1.",e-=40):(t="2.",e-=80),t+=e.toString()}else t=this.valueDec.toString();return t}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t.isFirstSid=this.isFirstSid,t}}class U extends c{constructor(t={}){super(t),this.fromString((0,b.getParametersValue)(t,"value",""))}fromBER(t,e,r){let n=e;for(;r>0;){const e=new N;if(n=e.fromBER(t,n,r),-1===n)return this.blockLength=0,this.error=e.error,n;0===this.value.length&&(e.isFirstSid=!0),this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return n}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(t);if(0===n.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=(0,b.utilConcatBuf)(e,n)}return e}fromString(t){this.value=[];let e=0,r=0,n="",i=!1;do{if(r=t.indexOf(".",e),n=-1===r?t.substr(e):t.substr(e,r-e),e=r+1,i){const t=this.value[0];let e=0;switch(t.valueDec){case 0:break;case 1:e=40;break;case 2:e=80;break;default:return this.value=[],!1}const r=parseInt(n,10);if(isNaN(r))return!0;t.valueDec=r+e,i=!1}else{const t=new N;if(t.valueDec=parseInt(n,10),isNaN(t.valueDec))return!0;0===this.value.length&&(t.isFirstSid=!0,i=!0),this.value.push(t)}}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(t+="."),e?(n=`{${n}}`,this.value[r].isFirstSid?t=`2.{${n} - 80}`:t+=n):t+=n}return t}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class C extends a{constructor(t={}){super(t,U),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}e.ObjectIdentifier=C;class O extends(i(n)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class I extends a{constructor(t={}){super(t,O),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(t){const e=unescape(encodeURIComponent(t)),r=e.length;this.valueBlock.valueHex=new ArrayBuffer(r);const n=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<r;i++)n[i]=e.charCodeAt(i);this.valueBlock.value=t}}e.Utf8String=I;class T extends(i(n)){constructor(t={}){super(t),this.valueDec=(0,b.getParametersValue)(t,"valueDec",-1)}static blockName(){return"relativeSidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===(0,b.checkBufferParams)(this,t,e,r))return-1;const n=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let i=new Uint8Array(this.valueHex);for(let c=0;c<r&&(i[c]=127&n[c],this.blockLength++,0!=(128&n[c]));c++);const s=new ArrayBuffer(this.blockLength),o=new Uint8Array(s);for(let c=0;c<this.blockLength;c++)o[c]=i[c];return this.valueHex=s.slice(0),i=new Uint8Array(this.valueHex),0!=(128&n[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===i[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,b.utilFromBase)(i,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const n=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|n[t];return r[this.blockLength-1]=n[this.blockLength-1],e}const n=(0,b.utilToBase)(this.valueDec,7);if(0===n.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(n.byteLength),!1===t){const t=new Uint8Array(n);r=new Uint8Array(e);for(let e=0;e<n.byteLength-1;e++)r[e]=128|t[e];r[n.byteLength-1]=t[n.byteLength-1]}return e}toString(){let t="";return t=!0===this.isHexOnly?(0,b.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength):this.valueDec.toString(),t}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}}class j extends c{constructor(t={}){super(t),this.fromString((0,b.getParametersValue)(t,"value",""))}fromBER(t,e,r){let n=e;for(;r>0;){const e=new T;if(n=e.fromBER(t,n,r),-1===n)return this.blockLength=0,this.error=e.error,n;this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return n}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const n=this.value[r].toBER(t);if(0===n.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=(0,b.utilConcatBuf)(e,n)}return e}fromString(t){this.value=[];let e=0,r=0,n="";do{r=t.indexOf(".",e),n=-1===r?t.substr(e):t.substr(e,r-e),e=r+1;const i=new T;if(i.valueDec=parseInt(n,10),isNaN(i.valueDec))return!0;this.value.push(i)}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let n=this.value[r].toString();0!==r&&(t+="."),e?(n=`{${n}}`,t+=n):t+=n}return t}static blockName(){return"RelativeObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class P extends a{constructor(t={}){super(t,j),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}static blockName(){return"RelativeObjectIdentifier"}}e.RelativeObjectIdentifier=P;class D extends(i(n)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class R extends a{constructor(t={}){super(t,D),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let n=0;n<r.length;n+=2){const t=r[n];r[n]=r[n+1],r[n+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(2*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<e;n++){const e=(0,b.utilToBase)(t.charCodeAt(n),8),i=new Uint8Array(e);if(i.length>2)continue;const s=2-i.length;for(let t=i.length-1;t>=0;t--)r[2*n+t+s]=i[t]}this.valueBlock.value=t}}e.BmpString=R;class M extends(i(n)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class $ extends a{constructor(t={}){super(t,M),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let n=0;n<r.length;n+=4)r[n]=r[n+3],r[n+1]=r[n+2],r[n+2]=0,r[n+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(4*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<e;n++){const e=(0,b.utilToBase)(t.charCodeAt(n),8),i=new Uint8Array(e);if(i.length>4)continue;const s=4-i.length;for(let t=i.length-1;t>=0;t--)r[4*n+t+s]=i[t]}this.valueBlock.value=t}}e.UniversalString=$;class H extends(i(n)){constructor(t={}){super(t),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class J extends a{constructor(t={}){super(t,H),"value"in t&&this.fromString(t.value)}static blockName(){return"SIMPLESTRING"}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(e);const r=new Uint8Array(this.valueBlock.valueHex);for(let n=0;n<e;n++)r[n]=t.charCodeAt(n);this.valueBlock.value=t}}class V extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}e.NumericString=V;class W extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}e.PrintableString=W;class G extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}e.TeletexString=G;class _ extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}e.VideotexString=_;class z extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}e.IA5String=z;class q extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}e.GraphicString=q;class L extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}e.VisibleString=L;class F extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}e.GeneralString=F;class Z extends J{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}e.CharacterString=Z;class X extends L{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(t){const e=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(t);if(null===e)return void(this.error="Wrong input string for convertion");const r=parseInt(e[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(e[2],10),this.day=parseInt(e[3],10),this.hour=parseInt(e[4],10),this.minute=parseInt(e[5],10),this.second=parseInt(e[6],10)}toString(){const t=new Array(7);return t[0]=(0,b.padNumber)(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=(0,b.padNumber)(this.month,2),t[2]=(0,b.padNumber)(this.day,2),t[3]=(0,b.padNumber)(this.hour,2),t[4]=(0,b.padNumber)(this.minute,2),t[5]=(0,b.padNumber)(this.second,2),t[6]="Z",t.join("")}static blockName(){return"UTCTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t}}e.UTCTime=X;class Q extends L{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(t,e,r){const n=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===n?(this.error=this.valueBlock.error,n):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),n)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(t){let e,r=!1,n="",i="",s=0,o=0,c=0;if("Z"===t[t.length-1])n=t.substr(0,t.length-1),r=!0;else{const e=new Number(t[t.length-1]);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");n=t}if(r){if(-1!==n.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==n.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let t=1,e=n.indexOf("+"),r="";if(-1===e&&(e=n.indexOf("-"),t=-1),-1!==e){if(r=n.substr(e+1),n=n.substr(0,e),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let i=new Number(r.substr(0,2));if(isNaN(i.valueOf()))throw new Error("Wrong input string for convertion");if(o=t*i,4===r.length){if(i=new Number(r.substr(2,2)),isNaN(i.valueOf()))throw new Error("Wrong input string for convertion");c=t*i}}}let a=n.indexOf(".");if(-1===a&&(a=n.indexOf(",")),-1!==a){const t=new Number("0"+n.substr(a));if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");s=t.valueOf(),i=n.substr(0,a)}else i=n;switch(!0){case 8===i.length:if(e=/(\d{4})(\d{2})(\d{2})/gi,-1!==a)throw new Error("Wrong input string for convertion");break;case 10===i.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==a){let t=60*s;this.minute=Math.floor(t),t=60*(t-this.minute),this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 12===i.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==a){let t=60*s;this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 14===i.length:e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==a&&(this.millisecond=Math.floor(1e3*s));break;default:throw new Error("Wrong input string for convertion")}const h=e.exec(i);if(null===h)throw new Error("Wrong input string for convertion");for(let u=1;u<h.length;u++)switch(u){case 1:this.year=parseInt(h[u],10);break;case 2:this.month=parseInt(h[u],10);break;case 3:this.day=parseInt(h[u],10);break;case 4:this.hour=parseInt(h[u],10)+o;break;case 5:this.minute=parseInt(h[u],10)+c;break;case 6:this.second=parseInt(h[u],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const t=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=t.getUTCFullYear(),this.month=t.getUTCMonth(),this.day=t.getUTCDay(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}}toString(){const t=[];return t.push((0,b.padNumber)(this.year,4)),t.push((0,b.padNumber)(this.month,2)),t.push((0,b.padNumber)(this.day,2)),t.push((0,b.padNumber)(this.hour,2)),t.push((0,b.padNumber)(this.minute,2)),t.push((0,b.padNumber)(this.second,2)),0!==this.millisecond&&(t.push("."),t.push((0,b.padNumber)(this.millisecond,3))),t.push("Z"),t.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t.millisecond=this.millisecond,t}}e.GeneralizedTime=Q;class Y extends I{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}e.DATE=Y;class tt extends I{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}e.TimeOfDay=tt;class et extends I{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}e.DateTime=et;class rt extends I{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}e.Duration=rt;class nt extends I{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}e.TIME=nt;class it{constructor(t={}){this.value=(0,b.getParametersValue)(t,"value",[]),this.optional=(0,b.getParametersValue)(t,"optional",!1)}}e.Choice=it;class st{constructor(t={}){this.name=(0,b.getParametersValue)(t,"name",""),this.optional=(0,b.getParametersValue)(t,"optional",!1)}}e.Any=st;class ot{constructor(t={}){this.name=(0,b.getParametersValue)(t,"name",""),this.optional=(0,b.getParametersValue)(t,"optional",!1),this.value=(0,b.getParametersValue)(t,"value",new st),this.local=(0,b.getParametersValue)(t,"local",!1)}}function ct(t,e,r){const i=e;let s=new a({},Object);const o=new n;if(!1===(0,b.checkBufferParams)(o,t,e,r))return s.error=o.error,{offset:-1,result:s};if(0===new Uint8Array(t,e,r).length)return this.error="Zero buffer length",{offset:-1,result:s};let c=s.idBlock.fromBER(t,e,r);if(s.warnings.concat(s.idBlock.warnings),-1===c)return s.error=s.idBlock.error,{offset:-1,result:s};if(c=s.lenBlock.fromBER(t,e=c,r-=s.idBlock.blockLength),s.warnings.concat(s.lenBlock.warnings),-1===c)return s.error=s.lenBlock.error,{offset:-1,result:s};if(e=c,r-=s.lenBlock.blockLength,!1===s.idBlock.isConstructed&&!0===s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let h=a;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&!1===s.idBlock.isHexOnly)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(!0===s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};h=d;break;case 1:h=p;break;case 2:h=K;break;case 3:h=B;break;case 4:h=k;break;case 5:h=A;break;case 6:h=C;break;case 10:h=x;break;case 12:h=I;break;case 13:h=P;break;case 14:h=nt;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:h=v;break;case 17:h=m;break;case 18:h=V;break;case 19:h=W;break;case 20:h=G;break;case 21:h=_;break;case 22:h=z;break;case 23:h=X;break;case 24:h=Q;break;case 25:h=q;break;case 26:h=L;break;case 27:h=F;break;case 28:h=$;break;case 29:h=Z;break;case 30:h=R;break;case 31:h=Y;break;case 32:h=tt;break;case 33:h=et;break;case 34:h=rt;break;default:{let n;n=!0===s.idBlock.isConstructed?new l:new u,n.idBlock=s.idBlock,n.lenBlock=s.lenBlock,n.warnings=s.warnings,s=n,c=s.fromBER(t,e,r)}}break;case 2:case 3:case 4:default:h=!0===s.idBlock.isConstructed?l:u}return s=function(t,e){if(t instanceof e)return t;const r=new e;return r.idBlock=t.idBlock,r.lenBlock=t.lenBlock,r.warnings=t.warnings,r.valueBeforeDecode=t.valueBeforeDecode.slice(0),r}(s,h),c=s.fromBER(t,e,!0===s.lenBlock.isIndefiniteForm?r:s.lenBlock.length),s.valueBeforeDecode=t.slice(i,i+s.blockLength),{offset:c,result:s}}function at(t){if(0===t.byteLength){const t=new a({},Object);return t.error="Input buffer has zero length",{offset:-1,result:t}}return ct(t,0,t.byteLength)}function ht(t,e,r){if(r instanceof it){for(let n=0;n<r.value.length;n++)if(!0===ht(t,e,r.value[n]).verified)return{verified:!0,result:t};{const t={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(t.name=r.name),t}}if(r instanceof st)return r.hasOwnProperty("name")&&(t[r.name]=e),{verified:!0,result:t};if(t instanceof Object==0)return{verified:!1,result:{error:"Wrong root object"}};if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=r.idBlock.toBER(!1);if(0===n.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(n,0,n.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:t};if("isHexOnly"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:t};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const n=new Uint8Array(r.idBlock.valueHex),i=new Uint8Array(e.idBlock.valueHex);if(n.length!==i.length)return{verified:!1,result:t};for(let e=0;e<n.length;e++)if(n[e]!==i[1])return{verified:!1,result:t}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(t[r.name]=e)),!0===r.idBlock.isConstructed){let n=0,i={verified:!1},s=r.valueBlock.value.length;if(s>0&&r.valueBlock.value[0]instanceof ot&&(s=e.valueBlock.value.length),0===s)return{verified:!0,result:t};if(0===e.valueBlock.value.length&&0!==r.valueBlock.value.length){let e=!0;for(let t=0;t<r.valueBlock.value.length;t++)e=e&&(r.valueBlock.value[t].optional||!1);return!0===e?{verified:!0,result:t}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),t.error="Inconsistent object length",{verified:!1,result:t})}for(let o=0;o<s;o++)if(o-n>=e.valueBlock.value.length){if(!1===r.valueBlock.value[o].optional){const e={verified:!1,result:t};return t.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}}else if(r.valueBlock.value[0]instanceof ot){if(i=ht(t,e.valueBlock.value[o],r.valueBlock.value[0].value),!1===i.verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),i;n++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let n={};n="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?e:t,void 0===n[r.valueBlock.value[0].name]&&(n[r.valueBlock.value[0].name]=[]),n[r.valueBlock.value[0].name].push(e.valueBlock.value[o])}}else if(i=ht(t,e.valueBlock.value[o-n],r.valueBlock.value[o]),!1===i.verified){if(!0!==r.valueBlock.value[o].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),i;n++}if(!1===i.verified){const e={verified:!1,result:t};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return{verified:!0,result:t}}if("primitiveSchema"in r&&"valueHex"in e.valueBlock){const n=at(e.valueBlock.valueHex);if(-1===n.offset){const e={verified:!1,result:n.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return ht(t,n.result,r.primitiveSchema)}return{verified:!0,result:t}}e.Repeated=ot,e.RawData=class{constructor(t={}){this.data=(0,b.getParametersValue)(t,"data",new ArrayBuffer(0))}fromBER(t,e,r){return this.data=t.slice(e,r),e+r}toBER(t=!1){return this.data}}})),S=(m=k)&&m.__esModule&&Object.prototype.hasOwnProperty.call(m,"default")?m.default:m,B=Object.freeze(Object.assign(Object.create(null),k,{default:S}));!function(t){t[t.Sequence=0]="Sequence",t[t.Set=1]="Set",t[t.Choice=2]="Choice"}(A||(A={})),function(t){t[t.Any=1]="Any",t[t.Boolean=2]="Boolean",t[t.OctetString=3]="OctetString",t[t.BitString=4]="BitString",t[t.Integer=5]="Integer",t[t.Enumerated=6]="Enumerated",t[t.ObjectIdentifier=7]="ObjectIdentifier",t[t.Utf8String=8]="Utf8String",t[t.BmpString=9]="BmpString",t[t.UniversalString=10]="UniversalString",t[t.NumericString=11]="NumericString",t[t.PrintableString=12]="PrintableString",t[t.TeletexString=13]="TeletexString",t[t.VideotexString=14]="VideotexString",t[t.IA5String=15]="IA5String",t[t.GraphicString=16]="GraphicString",t[t.VisibleString=17]="VisibleString",t[t.GeneralString=18]="GeneralString",t[t.CharacterString=19]="CharacterString",t[t.UTCTime=20]="UTCTime",t[t.GeneralizedTime=21]="GeneralizedTime",t[t.DATE=22]="DATE",t[t.TimeOfDay=23]="TimeOfDay",t[t.DateTime=24]="DateTime",t[t.Duration=25]="Duration",t[t.TIME=26]="TIME",t[t.Null=27]="Null"}(g||(g={}));const E={fromASN:t=>t instanceof k.Null?null:t.valueBeforeDecode,toASN:t=>{if(null===t)return new k.Null;const e=k.fromBER(t);if(e.result.error)throw new Error(e.result.error);return e.result}},K={fromASN:t=>t.valueBlock.valueHex.byteLength>4?t.valueBlock.toString():t.valueBlock.valueDec,toASN:t=>new k.Integer({value:t})},x={fromASN:t=>t.valueBlock.valueDec,toASN:t=>new k.Enumerated({value:t})},N={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new k.BitString({valueHex:t})},U={fromASN:t=>t.valueBlock.toString(),toASN:t=>new k.ObjectIdentifier({value:t})},C={fromASN:t=>t.valueBlock.value,toASN:t=>new k.Boolean({value:t})},O={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new k.OctetString({valueHex:t})};function I(t){return{fromASN:t=>t.valueBlock.value,toASN:e=>new t({value:e})}}const T=I(k.Utf8String),j=I(k.BmpString),P=I(k.UniversalString),D=I(k.NumericString),R=I(k.PrintableString),M=I(k.TeletexString),$=I(k.VideotexString),H=I(k.IA5String),J=I(k.GraphicString),V=I(k.VisibleString),W=I(k.GeneralString),G=I(k.CharacterString),_={fromASN:t=>t.toDate(),toASN:t=>new k.UTCTime({valueDate:t})},z={fromASN:t=>t.toDate(),toASN:t=>new k.GeneralizedTime({valueDate:t})},q={fromASN:()=>null,toASN:()=>new k.Null};function L(t){switch(t){case g.Any:return E;case g.BitString:return N;case g.BmpString:return j;case g.Boolean:return C;case g.CharacterString:return G;case g.Enumerated:return x;case g.GeneralString:return W;case g.GeneralizedTime:return z;case g.GraphicString:return J;case g.IA5String:return H;case g.Integer:return K;case g.Null:return q;case g.NumericString:return D;case g.ObjectIdentifier:return U;case g.OctetString:return O;case g.PrintableString:return R;case g.TeletexString:return M;case g.UTCTime:return _;case g.UniversalString:return P;case g.Utf8String:return T;case g.VideotexString:return $;case g.VisibleString:return V;default:return null}}class F{constructor(t){this.buffer="number"==typeof t?new ArrayBuffer(t):c.isBufferSource(t)?c.toArrayBuffer(t):Array.isArray(t)?new Uint8Array(t):new ArrayBuffer(0)}get byteLength(){return this.buffer.byteLength}get byteOffset(){return 0}fromASN(t){if(!(t instanceof k.OctetString))throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString");return this.buffer=t.valueBlock.valueHex,this}toASN(){return new k.OctetString({valueHex:this.buffer})}toSchema(t){return new k.OctetString({name:t})}}function Z(t){return t&&t.prototype?!(!t.prototype.toASN||!t.prototype.fromASN)||Z(t.prototype):!!(t&&t.toASN&&t.fromASN)}function X(t,e){if(!t||!e)return!1;if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),n=new Uint8Array(e);for(let i=0;i<t.byteLength;i++)if(r[i]!==n[i])return!1;return!0}const Q=new class{constructor(){this.items=new WeakMap}has(t){return this.items.has(t)}get(t){var e,r,n,i;const s=this.items.get(t);if(!s)throw new Error(`Cannot get schema for '${null!==(i=null===(n=null===(r=null===(e=t)||void 0===e?void 0:e.prototype)||void 0===r?void 0:r.constructor)||void 0===n?void 0:n.name)&&void 0!==i?i:t}' target`);return s}cache(t){const e=this.get(t);e.schema||(e.schema=this.create(t,!0))}createDefault(t){const e={type:A.Sequence,items:{}},r=this.findParentSchema(t);return r&&(Object.assign(e,r),e.items=Object.assign({},e.items,r.items)),e}create(t,e){const r=this.items.get(t)||this.createDefault(t),n=[];for(const i in r.items){const t=r.items[i],s=e?i:"";let o;if("number"==typeof t.type){const e=g[t.type],r=B[e];if(!r)throw new Error(`Cannot get ASN1 class by name '${e}'`);o=new r({name:s})}else Z(t.type)?o=(new t.type).toSchema(s):t.optional?this.get(t.type).type===A.Choice?o=new k.Any({name:s}):(o=this.create(t.type,!1),o.name=s):o=new k.Any({name:s});const c=!!t.optional||void 0!==t.defaultValue;if(t.repeated&&(o.name="",o=new("set"===t.repeated?k.Set:k.Sequence)({name:"",value:[new k.Repeated({name:s,value:o})]})),null!=t.context)if(t.implicit)if("number"==typeof t.type||Z(t.type))n.push(new(t.repeated?k.Constructed:k.Primitive)({name:s,optional:c,idBlock:{tagClass:3,tagNumber:t.context}}));else{this.cache(t.type);const e=!!t.repeated;let r=e?o:this.get(t.type).schema;r=r.valueBlock?r.valueBlock.value:r.value,n.push(new k.Constructed({name:e?"":s,optional:c,idBlock:{tagClass:3,tagNumber:t.context},value:r}))}else n.push(new k.Constructed({optional:c,idBlock:{tagClass:3,tagNumber:t.context},value:[o]}));else o.optional=c,n.push(o)}switch(r.type){case A.Sequence:return new k.Sequence({value:n,name:""});case A.Set:return new k.Set({value:n,name:""});case A.Choice:return new k.Choice({value:n,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(t,e){return this.items.set(t,e),this}findParentSchema(t){const e=t.__proto__;return e?this.items.get(e)||this.findParentSchema(e):null}},Y=t=>e=>{let r;Q.has(e)?r=Q.get(e):(r=Q.createDefault(e),Q.set(e,r)),Object.assign(r,t)},tt=t=>(e,r)=>{let n;Q.has(e.constructor)?n=Q.get(e.constructor):(n=Q.createDefault(e.constructor),Q.set(e.constructor,n));const i=Object.assign({},t);if("number"==typeof i.type&&!i.converter){const n=L(t.type);if(!n)throw new Error(`Cannot get default converter for property '${r}' of ${e.constructor.name}`);i.converter=n}n.items[r]=i};class et extends Error{constructor(){super(...arguments),this.schemas=[]}}class rt{static serialize(t){return t instanceof k.BaseBlock?t.toBER(!1):this.toASN(t).toBER(!1)}static toASN(t){if(t&&Z(t.constructor))return t.toASN();const e=t.constructor,r=Q.get(e);Q.cache(e);let n,i=[];if(r.itemType)if("number"==typeof r.itemType){const n=L(r.itemType);if(!n)throw new Error(`Cannot get default converter for array item of ${e.name} ASN1 schema`);i=t.map(t=>n.toASN(t))}else i=t.map(t=>this.toAsnItem({type:r.itemType},"[]",e,t));else for(const s in r.items){const n=r.items[s],o=t[s];if(void 0===o||n.defaultValue===o||"object"==typeof n.defaultValue&&"object"==typeof o&&X(this.serialize(n.defaultValue),this.serialize(o)))continue;let c=rt.toAsnItem(n,s,e,o);if("number"==typeof n.context)if(n.implicit)if(n.repeated||"number"!=typeof n.type&&!Z(n.type))i.push(new k.Constructed({optional:n.optional,idBlock:{tagClass:3,tagNumber:n.context},value:c.valueBlock.value}));else{const t={};t.valueHex=c.valueBlock.toBER(),i.push(new k.Primitive(Object.assign({optional:n.optional,idBlock:{tagClass:3,tagNumber:n.context}},t)))}else i.push(new k.Constructed({optional:n.optional,idBlock:{tagClass:3,tagNumber:n.context},value:[c]}));else n.repeated?i=i.concat(c):i.push(c)}switch(r.type){case A.Sequence:n=new k.Sequence({value:i});break;case A.Set:n=new k.Set({value:i});break;case A.Choice:if(!i[0])throw new Error(`Schema '${e.name}' has wrong data. Choice cannot be empty.`);n=i[0]}return n}static toAsnItem(t,e,r,n){let i;if("number"==typeof t.type){const s=t.converter;if(!s)throw new Error(`Property '${e}' doesn't have converter for type ${g[t.type]} in schema '${r.name}'`);if(t.repeated){const e=Array.from(n,t=>s.toASN(t));i=new("sequence"===t.repeated?k.Sequence:k.Set)({value:e})}else i=s.toASN(n)}else if(t.repeated){const e=Array.from(n,t=>this.toASN(t));i=new("sequence"===t.repeated?k.Sequence:k.Set)({value:e})}else i=this.toASN(n);return i}}class nt{static serialize(t){return rt.serialize(t)}static parse(t,e){return class{static parse(t,e){let r;if(t instanceof ArrayBuffer)r=t;else if("undefined"!=typeof Buffer&&Buffer.isBuffer(t))r=new Uint8Array(t).buffer;else{if(!(ArrayBuffer.isView(t)||t.buffer instanceof ArrayBuffer))throw new TypeError("Wrong type of 'data' argument");r=t.buffer}const n=k.fromBER(r);if(n.result.error)throw new Error(n.result.error);return this.fromASN(n.result,e)}static fromASN(t,e){var r;try{if(Z(e))return(new e).fromASN(t);const n=Q.get(e);Q.cache(e);let i=n.schema;if(t.constructor===k.Constructed&&n.type!==A.Choice){i=new k.Constructed({idBlock:{tagClass:3,tagNumber:t.idBlock.tagNumber},value:n.schema.valueBlock.value});for(const e in n.items)delete t[e]}const s=k.compareSchema(t,t,i);if(!s.verified)throw new et(`Data does not match to ${e.name} ASN1 schema. ${s.result.error}`);const o=new e;if(function t(e){var r;if(e){const n=Object.getPrototypeOf(e);return(null===(r=null==n?void 0:n.prototype)||void 0===r?void 0:r.constructor)===Array||t(n)}return!1}(e)){if("number"==typeof n.itemType){const r=L(n.itemType);if(!r)throw new Error(`Cannot get default converter for array item of ${e.name} ASN1 schema`);return e.from(t.valueBlock.value,t=>r.fromASN(t))}return e.from(t.valueBlock.value,t=>this.fromASN(t,n.itemType))}for(const e in n.items){if(!t[e])continue;const i=n.items[e];if("number"==typeof i.type||Z(i.type)){const n=null!==(r=i.converter)&&void 0!==r?r:Z(i.type)?new i.type:null;if(!n)throw new Error("Converter is empty");if(i.repeated)if(i.implicit){const r=new("sequence"===i.repeated?k.Sequence:k.Set);r.valueBlock=t[e].valueBlock;const s=k.fromBER(r.toBER(!1)).result.valueBlock.value;o[e]=Array.from(s,t=>n.fromASN(t))}else o[e]=Array.from(t[e],t=>n.fromASN(t));else{let r=t[e];if(i.implicit){let t;if(Z(i.type))t=(new i.type).toSchema("");else{const e=g[i.type],r=B[e];if(!r)throw new Error(`Cannot get '${e}' class from asn1js module`);t=new r}t.valueBlock=r.valueBlock,r=k.fromBER(t.toBER(!1)).result}o[e]=n.fromASN(r)}}else o[e]=i.repeated?Array.from(t[e],t=>this.fromASN(t,i.type)):this.fromASN(t[e],i.type)}return o}catch(n){throw n instanceof et&&n.schemas.push(e.name),n}}}.parse(t,e)}}class it extends Error{constructor(t,e){super(e?t+". See the inner exception for more details.":t),this.message=t,this.innerError=e}}class st extends it{constructor(t,e,r){super(e,r),this.schema=t}}class ot extends st{constructor(t,e,r){super(t,`JSON doesn't match to '${t.target.name}' schema. ${e}`,r)}}class ct extends it{}class at extends it{constructor(t,e,r){super(`Cannot serialize by '${t}' schema. ${e}`,r),this.schemaName=t}}class ht extends ot{constructor(t,e,r={}){super(t,"Some keys doesn't match to schema"),this.keys=e,this.errors=r}}var ut;function ft(t,e){if(!function(t,e){switch(e){case ut.Boolean:return"boolean"==typeof t;case ut.Number:return"number"==typeof t;case ut.String:return"string"==typeof t}return!0}(t,e))throw new TypeError("Value must be "+ut[e])}function lt(t){return t&&t.prototype?!(!t.prototype.toJSON||!t.prototype.fromJSON)||lt(t.prototype):!!(t&&t.toJSON&&t.fromJSON)}!function(t){t[t.Any=0]="Any",t[t.Boolean=1]="Boolean",t[t.Number=2]="Number",t[t.String=3]="String"}(ut||(ut={}));const yt=new class{constructor(){this.items=new Map}has(t){return this.items.has(t)||!!this.findParentSchema(t)}get(t){const e=this.items.get(t)||this.findParentSchema(t);if(!e)throw new Error("Cannot get schema for current target");return e}create(t){const e={names:{}},r=this.findParentSchema(t);if(r){Object.assign(e,r),e.names={};for(const t in r.names)e.names[t]=Object.assign({},r.names[t])}return e.target=t,e}set(t,e){return this.items.set(t,e),this}findParentSchema(t){const e=t.__proto__;return e?this.items.get(e)||this.findParentSchema(e):null}};class dt{constructor(t){this.pattern=new RegExp(t)}validate(t){const e=new RegExp(this.pattern.source,this.pattern.flags);if("string"!=typeof t)throw new ct("Incoming value must be string");if(!e.exec(t))throw new ct(`Value doesn't match to pattern '${e.toString()}'`)}}class wt{constructor(t=Number.MIN_VALUE,e=Number.MAX_VALUE){this.min=t,this.max=e}validate(t){if(ft(t,ut.Number),!(this.min<=t&&t<=this.max))throw new ct(`Value doesn't match to diapason [${this.min===Number.MIN_VALUE?"MIN":this.min},${this.max===Number.MAX_VALUE?"MAX":this.max}]`)}}class pt{constructor(t=Number.MIN_VALUE,e=Number.MAX_VALUE){this.min=t,this.max=e}validate(t){if(ft(t,ut.Number),!(this.min<t&&t<this.max))throw new ct(`Value doesn't match to diapason (${this.min===Number.MIN_VALUE?"MIN":this.min},${this.max===Number.MAX_VALUE?"MAX":this.max})`)}}class vt{constructor(t,e,r){this.length=t,this.minLength=e,this.maxLength=r}validate(t){if(void 0===this.length){if(void 0!==this.minLength&&t.length<this.minLength)throw new ct(`Value length must be more than ${this.minLength}.`);if(void 0!==this.maxLength&&t.length>this.maxLength)throw new ct(`Value length must be less than ${this.maxLength}.`)}else if(t.length!==this.length)throw new ct(`Value length must be exactly ${this.length}.`)}}class mt{constructor(t){this.enumeration=t}validate(t){if(ft(t,ut.String),!this.enumeration.includes(t))throw new ct("Value must be one of "+this.enumeration.map(t=>`'${t}'`).join(", "))}}class At{static checkValues(t,e){const r=Array.isArray(t)?t:[t];for(const n of r)for(const r of e.validations)r.validate(r instanceof vt&&e.repeated?t:n)}static checkTypes(t,e){if(e.repeated&&!Array.isArray(t))throw new TypeError("Value must be Array");if("number"==typeof e.type){const r=Array.isArray(t)?t:[t];for(const t of r)ft(t,e.type)}}static getSchemaByName(t,e="default"){return{...t.names.default,...t.names[e]}}}class gt extends At{static serialize(t,e,r,n){const i=this.toJSON(t,e);return JSON.stringify(i,r,n)}static toJSON(t,e={}){let r,i=e.targetSchema;const s=e.schemaName||"default";if(lt(t))return t.toJSON();if(Array.isArray(t)){r=[];for(const n of t)r.push(this.toJSON(n,e))}else if("object"==typeof t){if(i&&!yt.has(i))throw new it("Cannot get schema for `targetSchema` param");if(i=i||t.constructor,yt.has(i)){const e=yt.get(i);r={};const o=this.getSchemaByName(e,s);for(const c in o)try{const e=o[c],n=t[c];let a;if(e.optional&&void 0===n||void 0!==e.defaultValue&&n===e.defaultValue)continue;if(!e.optional&&void 0===n)throw new at(i.name,`Property '${c}' is required.`);a="number"==typeof e.type?e.converter?e.repeated?n.map(r=>e.converter.toJSON(r,t)):e.converter.toJSON(n,t):n:e.repeated?n.map(t=>this.toJSON(t,{schemaName:s})):this.toJSON(n,{schemaName:s}),this.checkTypes(a,e),this.checkValues(a,e),r[e.name||c]=a}catch(n){throw n instanceof at?n:new at(e.target.name,`Property '${c}' is wrong. ${n.message}`,n)}}else{r={};for(const e in t)r[e]=this.toJSON(t[e],{schemaName:s})}}else r=t;return r}}class bt extends At{static parse(t,e){const r=JSON.parse(t);return this.fromJSON(r,e)}static fromJSON(t,e){const r=e.targetSchema,i=e.schemaName||"default",s=new r;if(lt(s))return s.fromJSON(t);const o=yt.get(r),c=this.getSchemaByName(o,i),a={};e.strictProperty&&!Array.isArray(t)&&bt.checkStrictProperty(t,c,o);for(const u in c)try{const r=c[u],n=r.name||u,a=t[n];if(void 0===a&&(r.optional||void 0!==r.defaultValue))continue;if(!r.optional&&void 0===a)throw new ot(o,`Property '${n}' is required.`);if(this.checkTypes(a,r),this.checkValues(a,r),"number"==typeof r.type)s[u]=r.converter?r.repeated?a.map(t=>r.converter.fromJSON(t,s)):r.converter.fromJSON(a,s):a;else{const t={...e,targetSchema:r.type,schemaName:i};s[u]=r.repeated?a.map(e=>this.fromJSON(e,t)):this.fromJSON(a,t)}}catch(n){if(n instanceof ot||(n=new ot(o,`Property '${u}' is wrong. ${n.message}`,n)),!e.strictAllKeys)throw n;a[u]=n}const h=Object.keys(a);if(h.length)throw new ht(o,h,a);return s}static checkStrictProperty(t,e,r){const n=Object.keys(t),i=Object.keys(e),s=[];for(const o of n)-1===i.indexOf(o)&&s.push(o);if(s.length)throw new ht(r,s)}}const kt=(t={})=>(e,r)=>{const n=`Cannot set type for ${r} property of ${e.constructor.name} schema`;let i;yt.has(e.constructor)?(i=yt.get(e.constructor),i.target!==e.constructor&&(i=yt.create(e.constructor),yt.set(e.constructor,i))):(i=yt.create(e.constructor),yt.set(e.constructor,i));const s=Object.assign({type:ut.Any,validations:[]},t);if(s.validations=function(t){const e=[];return t.pattern&&e.push(new dt(t.pattern)),t.type!==ut.Number&&t.type!==ut.Any||(void 0===t.minInclusive&&void 0===t.maxInclusive||e.push(new wt(t.minInclusive,t.maxInclusive)),void 0===t.minExclusive&&void 0===t.maxExclusive||e.push(new pt(t.minExclusive,t.maxExclusive)),void 0!==t.enumeration&&e.push(new mt(t.enumeration))),(t.type===ut.String||t.repeated||t.type===ut.Any)&&(void 0===t.length&&void 0===t.minLength&&void 0===t.maxLength||e.push(new vt(t.length,t.minLength,t.maxLength))),e}(s),"number"!=typeof s.type&&!yt.has(s.type)&&!lt(s.type))throw new Error(n+". Assigning type doesn't have schema.");let o;o=Array.isArray(t.schema)?t.schema:[t.schema||"default"];for(const t of o)i.names[t]||(i.names[t]={}),i.names[t][r]=s};class St extends Error{}class Bt extends St{}class Et extends St{constructor(t){super("Unsupported operation: "+(t?""+t:""))}}class Kt extends St{}class xt extends St{constructor(t){super(t+": Missing required property")}}function Nt(t){return"object"==typeof t&&"kty"in t}class Ut{async digest(...t){return this.checkDigest.apply(this,t),this.onDigest.apply(this,t)}checkDigest(t,e){this.checkAlgorithmName(t)}async onDigest(t,e){throw new Et("digest")}async generateKey(...t){return this.checkGenerateKey.apply(this,t),this.onGenerateKey.apply(this,t)}checkGenerateKey(t,e,r,...n){if(this.checkAlgorithmName(t),this.checkGenerateKeyParams(t),!r||!r.length)throw new TypeError("Usages cannot be empty when creating a key.");let i;i=Array.isArray(this.usages)?this.usages:this.usages.privateKey.concat(this.usages.publicKey),this.checkKeyUsages(r,i)}checkGenerateKeyParams(t){}async onGenerateKey(t,e,r,...n){throw new Et("generateKey")}async sign(...t){return this.checkSign.apply(this,t),this.onSign.apply(this,t)}checkSign(t,e,r,...n){this.checkAlgorithmName(t),this.checkAlgorithmParams(t),this.checkCryptoKey(e,"sign")}async onSign(t,e,r,...n){throw new Et("sign")}async verify(...t){return this.checkVerify.apply(this,t),this.onVerify.apply(this,t)}checkVerify(t,e,r,n,...i){this.checkAlgorithmName(t),this.checkAlgorithmParams(t),this.checkCryptoKey(e,"verify")}async onVerify(t,e,r,n,...i){throw new Et("verify")}async encrypt(...t){return this.checkEncrypt.apply(this,t),this.onEncrypt.apply(this,t)}checkEncrypt(t,e,r,n={},...i){this.checkAlgorithmName(t),this.checkAlgorithmParams(t),this.checkCryptoKey(e,n.keyUsage?"encrypt":void 0)}async onEncrypt(t,e,r,...n){throw new Et("encrypt")}async decrypt(...t){return this.checkDecrypt.apply(this,t),this.onDecrypt.apply(this,t)}checkDecrypt(t,e,r,n={},...i){this.checkAlgorithmName(t),this.checkAlgorithmParams(t),this.checkCryptoKey(e,n.keyUsage?"decrypt":void 0)}async onDecrypt(t,e,r,...n){throw new Et("decrypt")}async deriveBits(...t){return this.checkDeriveBits.apply(this,t),this.onDeriveBits.apply(this,t)}checkDeriveBits(t,e,r,n={},...i){if(this.checkAlgorithmName(t),this.checkAlgorithmParams(t),this.checkCryptoKey(e,n.keyUsage?"deriveBits":void 0),r%8!=0)throw new Kt("length: Is not multiple of 8")}async onDeriveBits(t,e,r,...n){throw new Et("deriveBits")}async exportKey(...t){return this.checkExportKey.apply(this,t),this.onExportKey.apply(this,t)}checkExportKey(t,e,...r){if(this.checkKeyFormat(t),this.checkCryptoKey(e),!e.extractable)throw new St("key: Is not extractable")}async onExportKey(t,e,...r){throw new Et("exportKey")}async importKey(...t){return this.checkImportKey.apply(this,t),this.onImportKey.apply(this,t)}checkImportKey(t,e,r,n,i,...s){this.checkKeyFormat(t),this.checkKeyData(t,e),this.checkAlgorithmName(r),this.checkImportParams(r),Array.isArray(this.usages)&&this.checkKeyUsages(i,this.usages)}async onImportKey(t,e,r,n,i,...s){throw new Et("importKey")}checkAlgorithmName(t){if(t.name.toLowerCase()!==this.name.toLowerCase())throw new Bt("Unrecognized name")}checkAlgorithmParams(t){}checkDerivedKeyParams(t){}checkKeyUsages(t,e){for(const r of t)if(-1===e.indexOf(r))throw new TypeError("Cannot create a key using the specified key usages")}checkCryptoKey(t,e){if(this.checkAlgorithmName(t.algorithm),e&&-1===t.usages.indexOf(e))throw new St("key does not match that of operation")}checkRequiredProperty(t,e){if(!(e in t))throw new xt(e)}checkHashAlgorithm(t,e){for(const r of e)if(r.toLowerCase()===t.name.toLowerCase())return;throw new Kt("hash: Must be one of "+e.join(", "))}checkImportParams(t){}checkKeyFormat(t){switch(t){case"raw":case"pkcs8":case"spki":case"jwk":break;default:throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'")}}checkKeyData(t,e){if(!e)throw new TypeError("keyData: Cannot be empty on empty on key importing");if("jwk"===t){if(!Nt(e))throw new TypeError("keyData: Is not JsonWebToken")}else if(!c.isBufferSource(e))throw new TypeError("keyData: Is not ArrayBufferView or ArrayBuffer")}prepareData(t){return c.toArrayBuffer(t)}}class Ct extends Ut{checkGenerateKeyParams(t){if(this.checkRequiredProperty(t,"length"),"number"!=typeof t.length)throw new TypeError("length: Is not of type Number");switch(t.length){case 128:case 192:case 256:break;default:throw new TypeError("length: Must be 128, 192, or 256")}}checkDerivedKeyParams(t){this.checkGenerateKeyParams(t)}}class Ot extends Ct{constructor(){super(...arguments),this.name="AES-CBC",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"iv"),!(t.iv instanceof ArrayBuffer||ArrayBuffer.isView(t.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==t.iv.byteLength)throw new TypeError("iv: Must have length 16 bytes")}}class It extends Ct{constructor(){super(...arguments),this.name="AES-CTR",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"counter"),!(t.counter instanceof ArrayBuffer||ArrayBuffer.isView(t.counter)))throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(16!==t.counter.byteLength)throw new TypeError("iv: Must have length 16 bytes");if(this.checkRequiredProperty(t,"length"),"number"!=typeof t.length)throw new TypeError("length: Is not a Number");if(t.length<1)throw new Kt("length: Must be more than 0")}}class Tt extends Ct{constructor(){super(...arguments),this.name="AES-ECB",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}}class jt extends Ct{constructor(){super(...arguments),this.name="AES-GCM",this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"iv"),!(t.iv instanceof ArrayBuffer||ArrayBuffer.isView(t.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(t.iv.byteLength<1)throw new Kt("iv: Must have length more than 0 and less than 2^64 - 1");switch("tagLength"in t||(t.tagLength=128),t.tagLength){case 32:case 64:case 96:case 104:case 112:case 120:case 128:break;default:throw new Kt("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128")}}}class Pt extends Ct{constructor(){super(...arguments),this.name="AES-KW",this.usages=["wrapKey","unwrapKey"]}}class Dt extends Ut{constructor(){super(...arguments),this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){if(this.ivSize){if(this.checkRequiredProperty(t,"iv"),!(t.iv instanceof ArrayBuffer||ArrayBuffer.isView(t.iv)))throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(t.iv.byteLength!==this.ivSize)throw new TypeError(`iv: Must have length ${this.ivSize} bytes`)}}checkGenerateKeyParams(t){if(this.checkRequiredProperty(t,"length"),"number"!=typeof t.length)throw new TypeError("length: Is not of type Number");if(t.length!==this.keySizeBits)throw new Kt("algorith.length: Must be "+this.keySizeBits)}checkDerivedKeyParams(t){this.checkGenerateKeyParams(t)}}class Rt extends Ut{constructor(){super(...arguments),this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"]}checkGenerateKeyParams(t){if(this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms),this.checkRequiredProperty(t,"publicExponent"),!(t.publicExponent&&t.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const e=h.ToBase64(t.publicExponent);if("Aw=="!==e&&"AQAB"!==e)throw new TypeError("publicExponent: Must be [3] or [1,0,1]");switch(this.checkRequiredProperty(t,"modulusLength"),t.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}checkImportParams(t){this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms)}}class Mt extends Rt{constructor(){super(...arguments),this.name="RSASSA-PKCS1-v1_5",this.usages={privateKey:["sign"],publicKey:["verify"]}}}class $t extends Rt{constructor(){super(...arguments),this.name="RSA-PSS",this.usages={privateKey:["sign"],publicKey:["verify"]}}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"saltLength"),"number"!=typeof t.saltLength)throw new TypeError("saltLength: Is not a Number");if(t.saltLength<0)throw new RangeError("saltLength: Must be positive number")}}class Ht extends Rt{constructor(){super(...arguments),this.name="RSA-OAEP",this.usages={privateKey:["decrypt","unwrapKey"],publicKey:["encrypt","wrapKey"]}}checkAlgorithmParams(t){if(t.label&&!(t.label instanceof ArrayBuffer||ArrayBuffer.isView(t.label)))throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'")}}class Jt extends Ut{checkGenerateKeyParams(t){this.checkRequiredProperty(t,"namedCurve"),this.checkNamedCurve(t.namedCurve)}checkNamedCurve(t){for(const e of this.namedCurves)if(e.toLowerCase()===t.toLowerCase())return;throw new Kt("namedCurve: Must be one of "+this.namedCurves.join(", "))}}class Vt extends Jt{constructor(){super(...arguments),this.name="ECDSA",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(t){this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms)}}const Wt=["secret","private","public"];class Gt{static create(t,e,r,n){const i=new this;return i.algorithm=t,i.type=e,i.extractable=r,i.usages=n,i}static isKeyType(t){return-1!==Wt.indexOf(t)}get[Symbol.toStringTag](){return"CryptoKey"}}class _t extends Jt{constructor(){super(...arguments),this.name="ECDH",this.usages={privateKey:["deriveBits","deriveKey"],publicKey:[]},this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"public"),!(t.public instanceof Gt))throw new TypeError("public: Is not a CryptoKey");if("public"!==t.public.type)throw new Kt("public: Is not a public key");if(t.public.algorithm.name!==this.name)throw new Kt(`public: Is not ${this.name} key`)}}class zt extends Jt{constructor(){super(...arguments),this.name="EdDSA",this.usages={privateKey:["sign"],publicKey:["verify"]},this.namedCurves=["Ed25519","Ed448"]}}class qt extends Ut{constructor(){super(...arguments),this.name="HMAC",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["sign","verify"]}getDefaultLength(t){switch(t.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":return 512;default:throw new Error(`Unknown algorithm name '${t}'`)}}checkGenerateKeyParams(t){if(this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms),"length"in t){if("number"!=typeof t.length)throw new TypeError("length: Is not a Number");if(t.length<1)throw new RangeError("length: Number is out of range")}}checkImportParams(t){this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms)}}class Lt extends Ut{constructor(){super(...arguments),this.name="PBKDF2",this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"],this.usages=["deriveBits","deriveKey"]}checkAlgorithmParams(t){if(this.checkRequiredProperty(t,"hash"),this.checkHashAlgorithm(t.hash,this.hashAlgorithms),this.checkRequiredProperty(t,"salt"),!(t.salt instanceof ArrayBuffer||ArrayBuffer.isView(t.salt)))throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'");if(this.checkRequiredProperty(t,"iterations"),"number"!=typeof t.iterations)throw new TypeError("iterations: Is not a Number");if(t.iterations<1)throw new TypeError("iterations: Is less than 1")}checkImportKey(t,e,r,n,i,...s){if(super.checkImportKey(t,e,r,n,i),n)throw new SyntaxError("extractable: Must be 'false'")}}class Ft{get[Symbol.toStringTag](){return"Crypto"}}class Zt{constructor(){this.items={}}get(t){return this.items[t.toLowerCase()]||null}set(t){this.items[t.name.toLowerCase()]=t}removeAt(t){const e=this.get(t.toLowerCase());return e&&delete this.items[t],e}has(t){return!!this.get(t)}get length(){return Object.keys(this.items).length}get algorithms(){const t=[];for(const e in this.items)t.push(this.items[e].name);return t.sort()}}class Xt{constructor(){this.providers=new Zt}static isHashedAlgorithm(t){return!!(t&&"object"==typeof t&&"name"in t&&"hash"in t)}get[Symbol.toStringTag](){return"SubtleCrypto"}async digest(...t){this.checkRequiredArguments(t,2,"digest");const[e,r,...n]=t,i=this.prepareAlgorithm(e),s=c.toArrayBuffer(r),o=this.getProvider(i.name);return await o.digest(i,s,...n)}async generateKey(...t){this.checkRequiredArguments(t,3,"generateKey");const[e,r,n,...i]=t,s=this.prepareAlgorithm(e),o=this.getProvider(s.name);return await o.generateKey({...s,name:o.name},r,n,...i)}async sign(...t){this.checkRequiredArguments(t,3,"sign");const[e,r,n,...i]=t;this.checkCryptoKey(r);const s=this.prepareAlgorithm(e),o=c.toArrayBuffer(n),a=this.getProvider(s.name);return await a.sign({...s,name:a.name},r,o,...i)}async verify(...t){this.checkRequiredArguments(t,4,"verify");const[e,r,n,i,...s]=t;this.checkCryptoKey(r);const o=this.prepareAlgorithm(e),a=c.toArrayBuffer(i),h=c.toArrayBuffer(n),u=this.getProvider(o.name);return await u.verify({...o,name:u.name},r,h,a,...s)}async encrypt(...t){this.checkRequiredArguments(t,3,"encrypt");const[e,r,n,...i]=t;this.checkCryptoKey(r);const s=this.prepareAlgorithm(e),o=c.toArrayBuffer(n),a=this.getProvider(s.name);return await a.encrypt({...s,name:a.name},r,o,{keyUsage:!0},...i)}async decrypt(...t){this.checkRequiredArguments(t,3,"decrypt");const[e,r,n,...i]=t;this.checkCryptoKey(r);const s=this.prepareAlgorithm(e),o=c.toArrayBuffer(n),a=this.getProvider(s.name);return await a.decrypt({...s,name:a.name},r,o,{keyUsage:!0},...i)}async deriveBits(...t){this.checkRequiredArguments(t,3,"deriveBits");const[e,r,n,...i]=t;this.checkCryptoKey(r);const s=this.prepareAlgorithm(e),o=this.getProvider(s.name);return await o.deriveBits({...s,name:o.name},r,n,{keyUsage:!0},...i)}async deriveKey(...t){this.checkRequiredArguments(t,5,"deriveKey");const[e,r,n,i,s,...o]=t,c=this.prepareAlgorithm(n);this.getProvider(c.name).checkDerivedKeyParams(c);const a=this.prepareAlgorithm(e),h=this.getProvider(a.name);h.checkCryptoKey(r,"deriveKey");const u=await h.deriveBits({...a,name:h.name},r,n.length||512,{keyUsage:!1},...o);return this.importKey("raw",u,n,i,s,...o)}async exportKey(...t){this.checkRequiredArguments(t,2,"exportKey");const[e,r,...n]=t;this.checkCryptoKey(r);const i=this.getProvider(r.algorithm.name);return await i.exportKey(e,r,...n)}async importKey(...t){this.checkRequiredArguments(t,5,"importKey");const[e,r,n,i,s,...o]=t,a=this.prepareAlgorithm(n),h=this.getProvider(a.name);if(-1!==["pkcs8","spki","raw"].indexOf(e)){const t=c.toArrayBuffer(r);return h.importKey(e,t,{...a,name:h.name},i,s,...o)}if(!r.kty)throw new TypeError("keyData: Is not JSON");return h.importKey(e,r,{...a,name:h.name},i,s,...o)}async wrapKey(t,e,r,n,...i){let s=await this.exportKey(t,e,...i);if("jwk"===t){const t=JSON.stringify(s);s=h.FromUtf8String(t)}const o=this.prepareAlgorithm(n),a=c.toArrayBuffer(s),u=this.getProvider(o.name);return u.encrypt({...o,name:u.name},r,a,{keyUsage:!1},...i)}async unwrapKey(t,e,r,i,s,o,a,...u){const f=this.prepareAlgorithm(i),l=c.toArrayBuffer(e),y=this.getProvider(f.name);let d=await y.decrypt({...f,name:y.name},r,l,{keyUsage:!1},...u);if("jwk"===t)try{d=JSON.parse(h.ToUtf8String(d))}catch(n){const e=new TypeError("wrappedKey: Is not a JSON");throw e.internal=n,e}return this.importKey(t,d,s,o,a,...u)}checkRequiredArguments(t,e,r){if(t.length<e)throw new TypeError(`Failed to execute '${r}' on 'SubtleCrypto': ${e} arguments required, but only ${t.length} present`)}prepareAlgorithm(t){if("string"==typeof t)return{name:t};if(Xt.isHashedAlgorithm(t)){const e={...t};return e.hash=this.prepareAlgorithm(t.hash),e}return{...t}}getProvider(t){const e=this.providers.get(t);if(!e)throw new Bt("Unrecognized name");return e}checkCryptoKey(t){if(!(t instanceof Gt))throw new TypeError("Key is not of type 'CryptoKey'")}}let Qt=class{constructor(t){t&&(this.value=t)}};u([tt({type:g.ObjectIdentifier})],Qt.prototype,"value",void 0),Qt=u([Y({type:A.Choice})],Qt);class Yt{constructor(t){Object.assign(this,t)}}u([tt({type:g.ObjectIdentifier})],Yt.prototype,"algorithm",void 0),u([tt({type:g.Any,optional:!0})],Yt.prototype,"parameters",void 0);class te{constructor(){this.version=0,this.privateKeyAlgorithm=new Yt,this.privateKey=new ArrayBuffer(0)}}u([tt({type:g.Integer})],te.prototype,"version",void 0),u([tt({type:Yt})],te.prototype,"privateKeyAlgorithm",void 0),u([tt({type:g.OctetString})],te.prototype,"privateKey",void 0),u([tt({type:g.Any,optional:!0})],te.prototype,"attributes",void 0);class ee{constructor(){this.publicKeyAlgorithm=new Yt,this.publicKey=new ArrayBuffer(0)}}u([tt({type:Yt})],ee.prototype,"publicKeyAlgorithm",void 0),u([tt({type:g.BitString})],ee.prototype,"publicKey",void 0);const re={fromJSON:t=>h.FromBase64Url(t),toJSON:t=>h.ToBase64Url(new Uint8Array(t))},ne={fromASN:t=>new Uint8Array(t.valueBlock.valueHex)[0]?t.valueBlock.valueHex:t.valueBlock.valueHex.slice(1),toASN:t=>{const e=new Uint8Array(t)[0]>127?Buffer.concat([Buffer.from([0]),Buffer.from(t)]):Buffer.from(t);return new k.Integer({valueHex:new Uint8Array(e).buffer})}};class ie{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}}u([tt({type:g.Integer,converter:K})],ie.prototype,"version",void 0),u([tt({type:g.Integer,converter:ne}),kt({name:"n",converter:re})],ie.prototype,"modulus",void 0),u([tt({type:g.Integer,converter:ne}),kt({name:"e",converter:re})],ie.prototype,"publicExponent",void 0),u([tt({type:g.Integer,converter:ne}),kt({name:"d",converter:re})],ie.prototype,"privateExponent",void 0),u([tt({type:g.Integer,converter:ne}),kt({name:"p",converter:re})],ie.prototype,"prime1",void 0),u([tt({type:g.Integer,converter:ne}),kt({name:"q",converter:re})],ie.prototype,"prime2",void 0),u([tt({type:g.Integer,converter:ne}),kt({name:"dp",converter:re})],ie.prototype,"exponent1",void 0),u([tt({type:g.Integer,converter:ne}),kt({name:"dq",converter:re})],ie.prototype,"exponent2",void 0),u([tt({type:g.Integer,converter:ne}),kt({name:"qi",converter:re})],ie.prototype,"coefficient",void 0),u([tt({type:g.Any,optional:!0})],ie.prototype,"otherPrimeInfos",void 0);class se{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}}u([tt({type:g.Integer,converter:ne}),kt({name:"n",converter:re})],se.prototype,"modulus",void 0),u([tt({type:g.Integer,converter:ne}),kt({name:"e",converter:re})],se.prototype,"publicExponent",void 0);let oe=class{constructor(t){this.value=new ArrayBuffer(0),t&&(this.value=t)}toJSON(){let t=new Uint8Array(this.value);if(4!==t[0])throw new St("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");t=new Uint8Array(this.value.slice(1));const e=t.length/2;return{x:h.ToBase64Url(t.buffer.slice(0,0+e)),y:h.ToBase64Url(t.buffer.slice(0+e,0+e+e))}}fromJSON(t){if(!("x"in t))throw new Error("x: Missing required property");if(!("y"in t))throw new Error("y: Missing required property");const e=h.FromBase64Url(t.x),r=h.FromBase64Url(t.y),n=Buffer.concat([new Uint8Array([4]),new Uint8Array(e),new Uint8Array(r)]);return this.value=new Uint8Array(n).buffer,this}};u([tt({type:g.OctetString})],oe.prototype,"value",void 0),oe=u([Y({type:A.Choice})],oe);class ce{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(t){if(!("d"in t))throw new Error("d: Missing required property");if(this.privateKey=h.FromBase64Url(t.d),"x"in t){const e=new oe;e.fromJSON(t),this.publicKey=rt.toASN(e).valueBlock.valueHex}return this}toJSON(){const t={};return t.d=h.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(t,new oe(this.publicKey).toJSON()),t}}u([tt({type:g.Integer,converter:K})],ce.prototype,"version",void 0),u([tt({type:g.OctetString})],ce.prototype,"privateKey",void 0),u([tt({context:0,type:g.Any,optional:!0})],ce.prototype,"parameters",void 0),u([tt({context:1,type:g.BitString,optional:!0})],ce.prototype,"publicKey",void 0);const ae={fromASN:t=>{const e=new Uint8Array(t.valueBlock.valueHex);return 0===e[0]?e.buffer.slice(1):e.buffer},toASN:t=>{const e=new Uint8Array(t);if(e[0]>127){const t=new Uint8Array(e.length+1);return t.set(e,1),new k.Integer({valueHex:t.buffer})}return new k.Integer({valueHex:t})}};var he=Object.freeze({__proto__:null,AsnIntegerWithoutPaddingConverter:ae});class ue{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}static fromWebCryptoSignature(t){const e=c.toUint8Array(t),r=e.byteLength/2,n=new this;return n.r=n.removePadding(e.slice(0,r)),n.s=n.removePadding(e.slice(r,2*r)),n}toWebCryptoSignature(t){t=this.getPointSize();const e=this.addPadding(t,c.toUint8Array(this.r)),r=this.addPadding(t,c.toUint8Array(this.s)),n=new Uint8Array(e.byteLength+r.byteLength);return n.set(e,0),n.set(r,e.length),n.buffer}getPointSize(){switch(Math.max(this.r.byteLength,this.s.byteLength)){case 31:case 32:return 32;case 47:case 48:return 48;case 65:case 66:return 66}throw new Error("Unsupported EC point size")}addPadding(t,e){const r=new Uint8Array(t),n=c.toUint8Array(e);return r.set(n,t-n.length),r}removePadding(t){const e=c.toUint8Array(t);for(let r=0;r<e.length;r++)if(e[r])return e.slice(r);return new Uint8Array(0)}}u([tt({type:g.Integer,converter:ae})],ue.prototype,"r",void 0),u([tt({type:g.Integer,converter:ae})],ue.prototype,"s",void 0);let fe=class{};u([tt({type:g.OctetString}),kt({type:ut.String,converter:re})],fe.prototype,"d",void 0),fe=u([Y({type:A.Choice})],fe);var le,ye=Object.freeze({__proto__:null,converters:he,get ObjectIdentifier(){return Qt},AlgorithmIdentifier:Yt,PrivateKeyInfo:te,PublicKeyInfo:ee,RsaPrivateKey:ie,RsaPublicKey:se,EcPrivateKey:ce,get EcPublicKey(){return oe},EcDsaSignature:ue,get CurvePrivateKey(){return fe},idX25519:"1.3.101.110",idX448:"1.3.101.111",idEd25519:"1.3.101.112",idEd448:"1.3.101.113"});class de{static get enabled(){return"undefined"!=typeof self&&self.PV_WEBCRYPTO_LINER_LOG}static log(...t){this.enabled&&console.log.apply(console,t)}static error(...t){this.enabled&&console.error.apply(console,t)}static info(...t){this.enabled&&console.info.apply(console,t)}static warn(...t){this.enabled&&console.warn.apply(console,t)}static trace(...t){this.enabled&&console.trace.apply(console,t)}}function we(...t){const e=new Uint8Array(t.map(t=>t.length).reduce((t,e)=>t+e));let r=0;return t.forEach(t=>{for(let n=0;n<t.length;n++)e[r+n]=t[n];r+=t.length}),e}!function(t){t.Unknown="Unknown",t.IE="Internet Explorer",t.Safari="Safari",t.Edge="Edge",t.Chrome="Chrome",t.Firefox="Firefox Mozilla",t.Mobile="Mobile"}(le||(le={}));class pe extends Gt{constructor(t,e,r,n){super(),this.extractable=e,this.type=r,this.usages=n,this.algorithm=Object.assign({},t)}}function ve(t,e){return t.name.toUpperCase()===e.toUpperCase()}class me extends pe{constructor(t,e,r,n){super(t,e,"secret",r),this.raw=n}toJSON(){return{kty:"oct",alg:this.getJwkAlgorithm(),k:h.ToBase64Url(this.raw),ext:this.extractable,key_ops:this.usages}}getJwkAlgorithm(){switch(this.algorithm.name.toUpperCase()){case"AES-CBC":return`A${this.algorithm.length}CBC`;case"AES-CTR":return`A${this.algorithm.length}CTR`;case"AES-GCM":return`A${this.algorithm.length}GCM`;case"AES-ECB":return`A${this.algorithm.length}ECB`;default:throw new Bt("Unsupported algorithm name")}}}class Ae{static checkCryptoKey(t){if(!(t instanceof me))throw new TypeError("key: Is not AesCryptoKey")}static generateKey(e,r,n){return f(this,void 0,void 0,(function*(){const i=t.nativeCrypto.getRandomValues(new Uint8Array(e.length/8));return new me(e,r,n,i)}))}static encrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,c.toUint8Array(r),!0)}))}static decrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,c.toUint8Array(r),!1)}))}static exportKey(t,e){return f(this,void 0,void 0,(function*(){switch(t){case"jwk":return e.toJSON();case"raw":return e.raw.buffer;default:throw new Kt("format: Must be 'jwk' or 'raw'")}}))}static importKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){let t;switch(t=Nt(e)?h.FromBase64Url(e.k):c.toArrayBuffer(e),t.byteLength<<3){case 128:case 192:case 256:break;default:throw new Kt("keyData: Is wrong key length")}return new me({name:r.name,length:t.byteLength<<3},n,i,new Uint8Array(t))}))}static cipher(t,r,n,i){return f(this,void 0,void 0,(function*(){const s=i?"encrypt":"decrypt";let o;if(ve(t,Ae.AesCBC)){const i=c.toUint8Array(t.iv);o=e.AES_CBC[s](n,r.raw,void 0,i)}else if(ve(t,Ae.AesGCM)){const i=c.toUint8Array(t.iv);let a;t.additionalData&&(a=c.toArrayBuffer(t.additionalData)),o=e.AES_GCM[s](n,r.raw,i,a,(t.tagLength||128)/8)}else{if(!ve(t,Ae.AesECB))throw new Kt("algorithm: Is not recognized");o=e.AES_ECB[s](n,r.raw,!0)}return c.toArrayBuffer(o)}))}}Ae.AesCBC="AES-CBC",Ae.AesECB="AES-ECB",Ae.AesGCM="AES-GCM";class ge extends Ot{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ae.generateKey(t,e,r)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ae.encrypt(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ae.decrypt(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ae.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Ae.importKey(t,e,r,n,i)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ae.checkCryptoKey(t)}}class be extends Tt{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ae.generateKey(t,e,r)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ae.encrypt(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ae.decrypt(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ae.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Ae.importKey(t,e,r,n,i)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ae.checkCryptoKey(t)}}class ke extends jt{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ae.generateKey(t,e,r)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ae.encrypt(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Ae.decrypt(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ae.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Ae.importKey(t,e,r,n,i)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ae.checkCryptoKey(t)}}class Se extends It{onEncrypt(t,r,n){return f(this,void 0,void 0,(function*(){const i=new e.AES_CTR(r.raw,c.toUint8Array(t.counter)).encrypt(c.toUint8Array(n));return c.toArrayBuffer(i)}))}onDecrypt(t,r,n){return f(this,void 0,void 0,(function*(){const i=new e.AES_CTR(r.raw,c.toUint8Array(t.counter)).decrypt(c.toUint8Array(n));return c.toArrayBuffer(i)}))}onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ae.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ae.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Ae.importKey(t,e,r,n,i)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ae.checkCryptoKey(t)}}class Be extends Pt{onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){throw new Error("Method not implemented.")}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){throw new Error("Method not implemented.")}))}onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){throw new Error("Method not implemented.")}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){throw new Error("Method not implemented.")}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){throw new Error("Method not implemented.")}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ae.checkCryptoKey(t)}}class Ee extends pe{constructor(t,e,r,n,i){super(t,e,r,n),this.data=i}}class Ke{static checkCryptoKey(t){if(!(t instanceof Ee))throw new TypeError("key: Is not RsaCryptoKey")}static generateKey(e,r,n){return f(this,void 0,void 0,(function*(){const i={name:"RSA-PSS",hash:"SHA-256",publicExponent:e.publicExponent,modulusLength:e.modulusLength},s=yield t.nativeSubtle.generateKey(i,!0,["sign","verify"]),o=new jr,c=yield o.subtle.exportKey("pkcs8",s.privateKey),a=yield o.subtle.importKey("pkcs8",c,e,r,n.filter(t=>this.privateUsages.includes(t))),h=yield o.subtle.exportKey("spki",s.publicKey);return{privateKey:a,publicKey:yield o.subtle.importKey("spki",h,e,!0,n.filter(t=>this.publicUsages.includes(t)))}}))}static exportKey(t,e){return f(this,void 0,void 0,(function*(){switch(t){case"pkcs8":return this.exportPkcs8Key(e);case"spki":return this.exportSpkiKey(e);case"jwk":return this.exportJwkKey(e);default:throw new Kt("format: Must be 'jwk', 'pkcs8' or 'spki'")}}))}static importKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){let s;switch(t){case"pkcs8":s=this.importPkcs8Key(e);break;case"spki":s=this.importSpkiKey(e);break;case"jwk":s=this.importJwkKey(e);break;default:throw new Kt("format: Must be 'jwk', 'pkcs8' or 'spki'")}return new Ee(Object.assign({publicExponent:s[1].slice(1===s[1][1]?1:3),modulusLength:s[0].byteLength<<3},r),n,2===s.length?"public":"private",i,s)}))}static randomNonZeroValues(e){return(e=t.nativeCrypto.getRandomValues(e)).map(e=>{for(;!e;)e=t.nativeCrypto.getRandomValues(new Uint8Array(1))[0];return e})}static exportPkcs8Key(t){const e=new ye.PrivateKeyInfo;return e.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",e.privateKeyAlgorithm.parameters=null,e.privateKey=nt.serialize(this.exportAsmKey(t.data)),nt.serialize(e)}static importPkcs8Key(t){const e=nt.parse(t,ye.PrivateKeyInfo),r=nt.parse(e.privateKey,ye.RsaPrivateKey);return this.importAsmKey(r)}static importSpkiKey(t){const e=nt.parse(t,ye.PublicKeyInfo),r=nt.parse(e.publicKey,ye.RsaPublicKey);return this.importAsmKey(r)}static exportSpkiKey(t){const e=new ye.RsaPublicKey;e.modulus=t.data[0].buffer,e.publicExponent=t.data[1].buffer.slice(1===t.data[1][1]?1:3);const r=new ye.PublicKeyInfo;return r.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1",r.publicKeyAlgorithm.parameters=null,r.publicKey=nt.serialize(e),nt.serialize(r)}static importJwkKey(t){let e;return e=bt.fromJSON(t,t.d?{targetSchema:ye.RsaPrivateKey}:{targetSchema:ye.RsaPublicKey}),this.importAsmKey(e)}static exportJwkKey(t){const e=this.exportAsmKey(t.data),r=gt.toJSON(e);return r.ext=!0,r.key_ops=t.usages,r.kty="RSA",r.alg=this.getJwkAlgorithm(t.algorithm),r}static getJwkAlgorithm(t){switch(t.name.toUpperCase()){case"RSA-OAEP":const e=/(\d+)$/.exec(t.hash.name)[1];return"RSA-OAEP"+("1"!==e?"-"+e:"");case"RSASSA-PKCS1-V1_5":return"RS"+/(\d+)$/.exec(t.hash.name)[1];case"RSA-PSS":return"PS"+/(\d+)$/.exec(t.hash.name)[1];case"RSAES-PKCS1-V1_5":return"PS1";default:throw new Kt("algorithm: Is not recognized")}}static exportAsmKey(t){let e;if(t.length>2){const r=new ye.RsaPrivateKey;r.privateExponent=t[2].buffer,r.prime1=t[3].buffer,r.prime2=t[4].buffer,r.exponent1=t[5].buffer,r.exponent2=t[6].buffer,r.coefficient=t[7].buffer,e=r}else e=new ye.RsaPublicKey;return e.modulus=t[0].buffer,e.publicExponent=t[1].buffer.slice(1===t[1][1]?1:3),e}static importAsmKey(t){const e=new Uint8Array(4-t.publicExponent.byteLength),r=[new Uint8Array(t.modulus),we(e,new Uint8Array(t.publicExponent))];return t instanceof ye.RsaPrivateKey&&(r.push(new Uint8Array(t.privateExponent)),r.push(new Uint8Array(t.prime1)),r.push(new Uint8Array(t.prime2)),r.push(new Uint8Array(t.exponent1)),r.push(new Uint8Array(t.exponent2)),r.push(new Uint8Array(t.coefficient))),r}}Ke.RsaSsa="RSASSA-PKCS1-v1_5",Ke.RsaPss="RSA-PSS",Ke.RsaOaep="RSA-OAEP",Ke.privateUsages=["sign","decrypt","unwrapKey"],Ke.publicUsages=["verify","encrypt","wrapKey"];class xe{static getDigest(t){switch(t){case"SHA-1":return new e.Sha1;case"SHA-256":return new e.Sha256;case"SHA-512":return new e.Sha512;default:throw new Bt("keyAlgorithm.hash: Is not recognized")}}static digest(t,e){return f(this,void 0,void 0,(function*(){const r=this.getDigest(t.name).process(c.toUint8Array(e)).finish().result;return c.toArrayBuffer(r)}))}}class Ne extends Ht{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ke.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ke.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Ke.importKey(t,e,r,n,i)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,r)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ke.checkCryptoKey(t)}cipher(t,r,n){const i=xe.getDigest(r.algorithm.hash.name);let s;t.label&&(s=c.toUint8Array(t.label));const o=new e.RSA_OAEP(r.data,i,s);let a;const h=c.toUint8Array(n);return a="public"===r.type?o.encrypt(h):o.decrypt(h),c.toArrayBuffer(a)}}class Ue extends $t{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ke.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ke.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Ke.importKey(t,e,r,n,i)}))}onSign(t,r,n){return f(this,void 0,void 0,(function*(){const i=new e.RSA_PSS(r.data,xe.getDigest(r.algorithm.hash.name),t.saltLength).sign(c.toUint8Array(n));return c.toArrayBuffer(i)}))}onVerify(t,r,n,i){return f(this,void 0,void 0,(function*(){const s=new e.RSA_PSS(r.data,xe.getDigest(r.algorithm.hash.name),t.saltLength);try{s.verify(c.toUint8Array(n),c.toUint8Array(i))}catch(o){return!1}return!0}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ke.checkCryptoKey(t)}}class Ce extends Mt{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ke.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ke.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Ke.importKey(t,e,r,n,i)}))}onSign(t,r,n){return f(this,void 0,void 0,(function*(){const t=new e.RSA_PKCS1_v1_5(r.data,xe.getDigest(r.algorithm.hash.name)).sign(c.toUint8Array(n));return c.toArrayBuffer(t)}))}onVerify(t,r,n,i){return f(this,void 0,void 0,(function*(){const t=new e.RSA_PKCS1_v1_5(r.data,xe.getDigest(r.algorithm.hash.name));try{t.verify(c.toUint8Array(n),c.toUint8Array(i))}catch(s){return!1}return!0}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ke.checkCryptoKey(t)}}class Oe extends Ut{constructor(){super(...arguments),this.name="RSAES-PKCS1-v1_5",this.usages={publicKey:["encrypt","wrapKey"],privateKey:["decrypt","unwrapKey"]},this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"]}onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Ke.generateKey(t,e,r)}))}checkGenerateKeyParams(t){if(this.checkRequiredProperty(t,"publicExponent"),!(t.publicExponent&&t.publicExponent instanceof Uint8Array))throw new TypeError("publicExponent: Missing or not a Uint8Array");const e=h.ToBase64(t.publicExponent);if("Aw=="!==e&&"AQAB"!==e)throw new TypeError("publicExponent: Must be [3] or [1,0,1]");switch(this.checkRequiredProperty(t,"modulusLength"),t.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}onDecrypt(t,r,n){return f(this,void 0,void 0,(function*(){const t=new e.RSA(r.data).decrypt(new e.BigNumber(c.toUint8Array(n))).result;if(n.byteLength!==r.algorithm.modulusLength>>3)throw new St("Decryption error. Encrypted message size doesn't match to key length");let i=0;if(t[i++]||2!==t[i++])throw new St("Decryption error");do{if(0===t[i++])break}while(i<t.length);if(i<11)throw new St("Decryption error. PS is less than 8 octets.");if(i===t.length)throw new St("Decryption error. There is no octet with hexadecimal value 0x00 to separate PS from M");return t.buffer.slice(i)}))}onEncrypt(t,r,n){return f(this,void 0,void 0,(function*(){const t=r.algorithm.modulusLength>>3;if(n.byteLength>t-11)throw new St("Message too long");const i=t-n.byteLength-3,s=Ke.randomNonZeroValues(new Uint8Array(i)),o=new Uint8Array(t);o[0]=0,o[1]=2,o.set(s,2),o[2+i]=0,o.set(new Uint8Array(n),3+i);const a=new e.RSA(r.data).encrypt(new e.BigNumber(o)).result;return c.toArrayBuffer(a)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ke.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return yield Ke.importKey(t,e,Object.assign(Object.assign({},r),{name:this.name}),n,i)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Ke.checkCryptoKey(t)}prepareSignData(t,e){return f(this,void 0,void 0,(function*(){return(new jr).subtle.digest(t.hash,e)}))}}const Ie={"1.2.840.10045.3.1.7":"P-256","P-256":"1.2.840.10045.3.1.7","1.3.132.0.34":"P-384","P-384":"1.3.132.0.34","1.3.132.0.35":"P-521","P-521":"1.3.132.0.35","1.3.132.0.10":"K-256","K-256":"1.3.132.0.10"};function Te(t){const e=Ie[t];if(!e)throw new Kt(`Cannot convert WebCrypto named curve '${t}' to OID`);return e}class je extends pe{constructor(t,e,r,n,i){super(t,e,r,n),this.data=i}}class Pe{static checkLib(){if(void 0===i)throw new Kt("Cannot implement EC mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/elliptic.js' script to your project")}static generateKey(t,e,r){return f(this,void 0,void 0,(function*(){this.checkLib();const n=this.initEcKey(t.namedCurve).genKeyPair();return n.getPublic(),{privateKey:new je(Object.assign({},t),e,"private",r.filter(t=>~this.privateUsages.indexOf(t)),n),publicKey:new je(Object.assign({},t),!0,"public",r.filter(t=>~this.publicUsages.indexOf(t)),n)}}))}static checkCryptoKey(t){if(!(t instanceof je))throw new TypeError("key: Is not EcCryptoKey")}static concat(...t){const e=new Uint8Array(t.map(t=>t.length).reduce((t,e)=>t+e));let r=0;return t.forEach(t=>{for(let n=0;n<t.length;n++)e[r+n]=t[n];r+=t.length}),e}static exportKey(t,e){return f(this,void 0,void 0,(function*(){switch(this.checkLib(),t){case"pkcs8":return this.exportPkcs8Key(e);case"spki":return this.exportSpkiKey(e);case"jwk":return this.exportJwkKey(e);case"raw":return new Uint8Array(e.data.getPublic("der")).buffer;default:throw new Kt("format: Must be 'jwk', 'raw, 'pkcs8' or 'spki'")}}))}static importKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){let s;switch(this.checkLib(),t){case"pkcs8":s=this.importPkcs8Key(e,r.namedCurve);break;case"spki":s=this.importSpkiKey(e,r.namedCurve);break;case"raw":s=this.importEcKey(new ye.EcPublicKey(e),r.namedCurve);break;case"jwk":s=this.importJwkKey(e);break;default:throw new Kt("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}return new je(Object.assign({},r),n,s.priv?"private":"public",i,s)}))}static getNamedCurve(t){const e=t.toUpperCase();let r="";if(["P-256","P-384","P-521"].indexOf(e)>-1)r=e.replace("-","").toLowerCase();else{if("K-256"!==e)throw new Kt(`Unsupported named curve '${t}'`);r="secp256k1"}return r}static initEcKey(t){return r.ec(this.getNamedCurve(t))}static exportPkcs8Key(t){const e=new ye.PrivateKeyInfo;return e.privateKeyAlgorithm.algorithm=this.ASN_ALGORITHM,e.privateKeyAlgorithm.parameters=nt.serialize(new ye.ObjectIdentifier(Te(t.algorithm.namedCurve))),e.privateKey=nt.serialize(this.exportEcKey(t)),nt.serialize(e)}static importPkcs8Key(t,e){const r=nt.parse(t,ye.PrivateKeyInfo),n=nt.parse(r.privateKey,ye.EcPrivateKey);return this.importEcKey(n,e)}static importSpkiKey(t,e){const r=nt.parse(t,ye.PublicKeyInfo),n=new ye.EcPublicKey(r.publicKey);return this.importEcKey(n,e)}static exportSpkiKey(t){const e=new ye.EcPublicKey(new Uint8Array(t.data.getPublic("der")).buffer),r=new ye.PublicKeyInfo;return r.publicKeyAlgorithm.algorithm=this.ASN_ALGORITHM,r.publicKeyAlgorithm.parameters=nt.serialize(new ye.ObjectIdentifier(Te(t.algorithm.namedCurve))),r.publicKey=e.value,nt.serialize(r)}static importJwkKey(t){let e;return e=bt.fromJSON(t,t.d?{targetSchema:ye.EcPrivateKey}:{targetSchema:ye.EcPublicKey}),this.importEcKey(e,t.crv)}static exportJwkKey(t){const e=this.exportEcKey(t),r=gt.toJSON(e);return r.ext=!0,r.key_ops=t.usages,r.crv=t.algorithm.namedCurve,r.kty="EC",r}static exportEcKey(t){if("private"===t.type){const e=new ye.EcPrivateKey,r=new Uint8Array(t.data.getPrivate("der").toArray()),n=new Uint8Array(this.getPointSize(t.algorithm.namedCurve)-r.length);return e.privateKey=we(n,r),e.publicKey=new Uint8Array(t.data.getPublic("der")),e}if(t.data.pub)return new ye.EcPublicKey(new Uint8Array(t.data.getPublic("der")).buffer);throw new Error("Cannot get private or public key")}static importEcKey(t,e){const r=this.initEcKey(e);return t instanceof ye.EcPublicKey?r.keyFromPublic(new Uint8Array(t.value)):r.keyFromPrivate(new Uint8Array(t.privateKey))}static getPointSize(t){switch(t){case"P-256":case"K-256":return 32;case"P-384":return 48;case"P-521":return 66}throw new Error("namedCurve: Is not recognized")}}Pe.privateUsages=["sign","deriveKey","deriveBits"],Pe.publicUsages=["verify"],Pe.ASN_ALGORITHM="1.2.840.10045.2.1";class De extends _t{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Pe.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Pe.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Pe.importKey(t,e,r,n,i)}))}onDeriveBits(t,e,r){return f(this,void 0,void 0,(function*(){Pe.checkLib();const n=e.data.derive(t.public.data.getPublic());let i=new Uint8Array(n.toArray()),s=i.length;return s=s>32?s>48?66:48:32,i.length<s&&(i=Pe.concat(new Uint8Array(s-i.length),i)),i.slice(0,r/8).buffer}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Pe.checkCryptoKey(t)}}function Re(t){const e=new Uint8Array(t),r=[];for(let n=0;n<e.length;n++)r.push(e[n]);return r}function Me(t,e){let r="";for(let n=0;n<t.length;n++){const e=t[n].toString(16);r+=e.length%2?"0"+e:e}if(e){let e=t.length;e=e>32?e>48?66:48:32,r.length/2<e&&(r=new Array(2*e-r.length+1).join("0")+r)}return r}class $e extends Vt{onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Pe.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Pe.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Pe.importKey(t,e,r,n,i)}))}onSign(t,e,r){return f(this,void 0,void 0,(function*(){Pe.checkLib();const n=new jr;let i;i=Re(yield n.subtle.digest(t.hash,r));const s=yield e.data.sign(i);return function(t){t.length%2&&(t="0"+t);let e=new Uint8Array(t.length/2);for(let r=0;r<t.length;r++){const n=t.slice(r,1+ ++r);e[(r-1)/2]=parseInt(n,16)}return e}(Me(s.r.toArray(),!0)+Me(s.s.toArray(),!0)).buffer}))}onVerify(t,e,r,n){return f(this,void 0,void 0,(function*(){Pe.checkLib();const i=new jr,s={r:new Uint8Array(r.slice(0,r.byteLength/2)),s:new Uint8Array(r.slice(r.byteLength/2))},o=Re(yield i.subtle.digest(t.hash,n));return e.data.verify(o,s)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Pe.checkCryptoKey(t)}}const He={[ye.idEd448]:"Ed448",ed448:ye.idEd448,[ye.idX448]:"X448",x448:ye.idX448,[ye.idEd25519]:"Ed25519",ed25519:ye.idEd25519,[ye.idX25519]:"X25519",x25519:ye.idX25519};function Je(t){const e=He[t.toLowerCase()];if(!e)throw new Kt(`Cannot convert WebCrypto named curve '${t}' to OID`);return e}class Ve extends pe{constructor(t,e,r,n){super(t,e,"private",r),this.data=n}toJSON(){const t={kty:"OKP",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(t,{d:h.ToBase64Url(h.FromHex(/^ed/i.test(t.crv)?this.data.getSecret("hex"):this.data.getPrivate("hex")))})}fromJSON(t){if(!t.d)throw new Kt("Cannot get private data from JWK. Property 'd' is required");if(!t.crv)throw new Kt("Cannot get named curve from JWK. Property 'crv' is required");const e=h.ToHex(h.FromBase64Url(t.d));if(/^ed/i.test(t.crv)){const n=new r.eddsa(t.crv.toLowerCase());this.data=n.keyFromSecret(e)}else{const n=r.ec(t.crv.replace(/^x/i,"curve"));this.data=n.keyFromPrivate(e,"hex")}return this}}class We extends pe{constructor(t,e,r,n){super(t,e,"public",r),this.data=n}toJSON(){return Object.assign({kty:"OKP",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable},{x:h.ToBase64Url(h.FromHex(this.data.getPublic("hex")))})}fromJSON(t){if(!t.crv)throw new Kt("Cannot get named curve from JWK. Property 'crv' is required");if(!t.x)throw new Kt("Cannot get property from JWK. Property 'x' is required");const e=h.ToHex(h.FromBase64Url(t.x));if(/^ed/i.test(t.crv)){const n=new r.eddsa(t.crv.toLowerCase());this.data=n.keyFromPublic(e,"hex")}else{const n=r.ec(t.crv.replace(/^x/i,"curve"));this.data=n.keyFromPublic(e,"hex")}return this}}class Ge{static checkLib(){if(void 0===i)throw new Kt("Cannot implement EC mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/elliptic.js' script to your project")}static concat(...t){const e=new Uint8Array(t.map(t=>t.length).reduce((t,e)=>t+e));let r=0;return t.forEach(t=>{for(let n=0;n<t.length;n++)e[r+n]=t[n];r+=t.length}),e}static generateKey(e,n,i){return f(this,void 0,void 0,(function*(){this.checkLib();const s="x25519"===e.namedCurve.toLowerCase()?"curve25519":"ed25519";let o;if("ed25519"===s){const e=t.nativeCrypto.getRandomValues(new Uint8Array(32));o=new r.eddsa(s).keyFromSecret(e)}else o=r.ec(s).genKeyPair(),o.getPublic();return{privateKey:new Ve(e,n,i.filter(t=>-1!==this.privateKeyUsages.indexOf(t)),o),publicKey:new We(e,!0,i.filter(t=>-1!==this.publicKeyUsages.indexOf(t)),o)}}))}static sign(t,e,r){return f(this,void 0,void 0,(function*(){this.checkLib();const t=Re(r),n=e.data.sign(t).toHex();return h.FromHex(n)}))}static verify(t,e,r,n){return f(this,void 0,void 0,(function*(){this.checkLib();const t=Re(n);return e.data.verify(t,h.ToHex(r))}))}static deriveBits(t,e,r){return f(this,void 0,void 0,(function*(){this.checkLib();const n=e.data.derive(t.public.data.getPublic());let i=new Uint8Array(n.toArray()),s=i.length;return s=s>32?s>48?66:48:32,i.length<s&&(i=Ge.concat(new Uint8Array(s-i.length),i)),i.slice(0,r/8).buffer}))}static exportKey(t,e){return f(this,void 0,void 0,(function*(){switch(this.checkLib(),t.toLowerCase()){case"jwk":return gt.toJSON(e);case"pkcs8":{const t=h.FromHex(/^x/i.test(e.algorithm.namedCurve)?e.data.getPrivate("hex"):e.data.getSecret("hex")),r=new ye.PrivateKeyInfo;return r.privateKeyAlgorithm.algorithm=Je(e.algorithm.namedCurve),r.privateKey=nt.serialize(new F(t)),nt.serialize(r)}case"spki":{const t=h.FromHex(e.data.getPublic("hex")),r=new ye.PublicKeyInfo;return r.publicKeyAlgorithm.algorithm=Je(e.algorithm.namedCurve),r.publicKey=t,nt.serialize(r)}case"raw":return h.FromHex(e.data.getPublic("hex"));default:throw new Kt("format: Must be 'jwk', 'raw', pkcs8' or 'spki'")}}))}static importKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){switch(this.checkLib(),t.toLowerCase()){case"jwk":{const t=e;if(t.d){const t=bt.fromJSON(e,{targetSchema:ye.CurvePrivateKey});return this.importPrivateKey(t,r,n,i)}if(!t.x)throw new TypeError("keyData: Cannot get required 'x' filed");return this.importPublicKey(h.FromBase64Url(t.x),r,n,i)}case"raw":return this.importPublicKey(e,r,n,i);case"spki":{const t=nt.parse(new Uint8Array(e),ye.PublicKeyInfo);return this.importPublicKey(t.publicKey,r,n,i)}case"pkcs8":{const t=nt.parse(new Uint8Array(e),ye.PrivateKeyInfo),s=nt.parse(t.privateKey,ye.CurvePrivateKey);return this.importPrivateKey(s,r,n,i)}default:throw new Kt("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}}))}static importPrivateKey(t,e,r,n){const i=new Ve(Object.assign({},e),r,n,null);return i.fromJSON({crv:e.namedCurve,d:h.ToBase64Url(t.d)}),i}static importPublicKey(t,e,r,n){return f(this,void 0,void 0,(function*(){const i=new We(Object.assign({},e),r,n,null);return i.fromJSON({crv:e.namedCurve,x:h.ToBase64Url(t)}),i}))}}Ge.publicKeyUsages=["verify"],Ge.privateKeyUsages=["sign","deriveKey","deriveBits"];class _e extends zt{constructor(){super(...arguments),this.namedCurves=["Ed25519"]}onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return yield Ge.generateKey({name:this.name,namedCurve:t.namedCurve.replace(/^ed/i,"Ed")},e,r)}))}onSign(t,e,r){return f(this,void 0,void 0,(function*(){return Ge.sign(t,e,new Uint8Array(r))}))}onVerify(t,e,r,n){return f(this,void 0,void 0,(function*(){return Ge.verify(t,e,new Uint8Array(r),new Uint8Array(n))}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Ge.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return yield Ge.importKey(t,e,Object.assign(Object.assign({},r),{name:this.name}),n,i)}))}}class ze extends Ut{constructor(){super(...arguments),this.name="SHA-1",this.usages=[]}onDigest(t,e){return f(this,void 0,void 0,(function*(){return xe.digest(t,e)}))}}class qe extends ze{constructor(){super(...arguments),this.name="SHA-256"}}class Le extends ze{constructor(){super(...arguments),this.name="SHA-512"}}class Fe extends pe{constructor(t,e,r,n){super(t,e,"secret",r),this.raw=n}}class Ze extends Lt{onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return new Fe(r,n,i,c.toUint8Array(e))}))}onDeriveBits(t,r,n){return f(this,void 0,void 0,(function*(){let i;const s=c.toUint8Array(t.salt),o=r.raw;switch(t.hash.name.toUpperCase()){case"SHA-1":i=e.Pbkdf2HmacSha1(o,s,t.iterations,n>>3);break;case"SHA-256":i=e.Pbkdf2HmacSha256(o,s,t.iterations,n>>3);break;case"SHA-512":i=e.Pbkdf2HmacSha512(o,s,t.iterations,n>>3);break;default:throw new Kt(`algorithm.hash: '${t.hash.name}' hash algorithm is not supported`)}return c.toArrayBuffer(i)}))}checkCryptoKey(t,e){if(super.checkCryptoKey(t,e),!(t instanceof Fe))throw new TypeError("key: Is not PbkdfCryptoKey")}}var Xe=[14,11,17,4,27,23,25,0,13,22,7,18,5,9,16,24,2,20,12,21,1,8,15,26,15,4,25,19,9,1,26,16,5,11,23,8,12,7,17,0,22,3,10,14,6,20,27,24],Qe=[14,0,4,15,13,7,1,4,2,14,15,2,11,13,8,1,3,10,10,6,6,12,12,11,5,9,9,5,0,3,7,8,4,15,1,12,14,8,8,2,13,4,6,9,2,1,11,7,15,5,12,11,9,3,7,14,3,10,10,0,5,6,0,13,15,3,1,13,8,4,14,7,6,15,11,2,3,8,4,14,9,12,7,0,2,1,13,10,12,6,0,9,5,11,10,5,0,13,14,8,7,10,11,1,10,3,4,15,13,4,1,2,5,11,8,6,12,7,6,12,9,0,3,5,2,14,15,9,10,13,0,7,9,0,14,9,6,3,3,4,15,6,5,10,1,2,13,8,12,5,7,14,11,12,4,11,2,15,8,1,13,1,6,10,4,13,9,0,8,6,15,9,3,8,0,7,11,4,1,15,2,14,12,3,5,11,10,5,14,2,7,12,7,13,13,8,14,11,3,5,0,6,6,15,9,0,10,3,1,4,2,7,8,2,5,12,11,1,12,10,4,14,15,9,10,3,6,15,9,0,0,6,12,10,11,1,7,13,13,8,15,9,1,4,3,5,14,11,5,12,2,7,8,2,4,14,2,14,12,11,4,2,1,12,7,4,10,7,11,13,6,1,8,5,5,0,3,15,15,10,13,3,0,9,14,8,9,6,4,11,2,8,1,12,11,7,10,1,13,14,7,2,8,13,15,6,9,15,12,0,5,9,6,10,3,4,0,5,14,3,12,10,1,15,10,4,15,2,9,7,2,12,6,9,8,5,0,6,13,1,3,13,4,14,14,0,7,11,5,3,11,8,9,4,14,3,15,2,5,12,2,9,8,5,12,15,3,10,7,11,0,14,4,1,10,7,1,6,13,0,11,8,6,13,4,13,11,0,2,11,14,7,15,4,0,9,8,1,13,10,3,14,12,3,9,5,7,12,5,2,10,15,6,8,1,6,1,6,4,11,11,13,13,8,12,1,3,4,7,10,14,7,10,9,15,5,6,0,8,15,0,14,5,2,9,3,2,12,13,1,2,15,8,13,4,8,6,10,15,3,11,7,1,4,10,12,9,5,3,6,14,11,5,0,0,14,12,9,7,2,7,2,11,1,4,14,1,7,9,4,12,10,14,8,2,13,0,15,6,12,10,9,13,0,15,3,3,5,5,6,8,11],Ye=[16,25,12,11,3,20,4,15,31,17,9,6,27,14,1,22,30,24,8,18,0,5,29,23,13,19,2,26,10,21,28,7],tr={readUInt32BE:function(t,e){return(t[0+e]<<24|t[1+e]<<16|t[2+e]<<8|t[3+e])>>>0},writeUInt32BE:function(t,e,r){t[0+r]=e>>>24,t[1+r]=e>>>16&255,t[2+r]=e>>>8&255,t[3+r]=255&e},ip:function(t,e,r,n){for(var i=0,s=0,o=6;o>=0;o-=2){for(var c=0;c<=24;c+=8)i<<=1,i|=e>>>c+o&1;for(c=0;c<=24;c+=8)i<<=1,i|=t>>>c+o&1}for(o=6;o>=0;o-=2){for(c=1;c<=25;c+=8)s<<=1,s|=e>>>c+o&1;for(c=1;c<=25;c+=8)s<<=1,s|=t>>>c+o&1}r[n+0]=i>>>0,r[n+1]=s>>>0},rip:function(t,e,r,n){for(var i=0,s=0,o=0;o<4;o++)for(var c=24;c>=0;c-=8)i<<=1,i|=e>>>c+o&1,i<<=1,i|=t>>>c+o&1;for(o=4;o<8;o++)for(c=24;c>=0;c-=8)s<<=1,s|=e>>>c+o&1,s<<=1,s|=t>>>c+o&1;r[n+0]=i>>>0,r[n+1]=s>>>0},pc1:function(t,e,r,n){for(var i=0,s=0,o=7;o>=5;o--){for(var c=0;c<=24;c+=8)i<<=1,i|=e>>c+o&1;for(c=0;c<=24;c+=8)i<<=1,i|=t>>c+o&1}for(c=0;c<=24;c+=8)i<<=1,i|=e>>c+o&1;for(o=1;o<=3;o++){for(c=0;c<=24;c+=8)s<<=1,s|=e>>c+o&1;for(c=0;c<=24;c+=8)s<<=1,s|=t>>c+o&1}for(c=0;c<=24;c+=8)s<<=1,s|=t>>c+o&1;r[n+0]=i>>>0,r[n+1]=s>>>0},r28shl:function(t,e){return t<<e&268435455|t>>>28-e},pc2:function(t,e,r,n){for(var i=0,s=0,o=Xe.length>>>1,c=0;c<o;c++)i<<=1,i|=t>>>Xe[c]&1;for(c=o;c<Xe.length;c++)s<<=1,s|=e>>>Xe[c]&1;r[n+0]=i>>>0,r[n+1]=s>>>0},expand:function(t,e,r){var n=0,i=0;n=(1&t)<<5|t>>>27;for(var s=23;s>=15;s-=4)n<<=6,n|=t>>>s&63;for(s=11;s>=3;s-=4)i|=t>>>s&63,i<<=6;i|=(31&t)<<1|t>>>31,e[r+0]=n>>>0,e[r+1]=i>>>0},substitute:function(t,e){for(var r=0,n=0;n<4;n++)r<<=4,r|=Qe[64*n+(t>>>18-6*n&63)];for(n=0;n<4;n++)r<<=4,r|=Qe[256+64*n+(e>>>18-6*n&63)];return r>>>0},permute:function(t){for(var e=0,r=0;r<Ye.length;r++)e<<=1,e|=t>>>Ye[r]&1;return e>>>0},padSplit:function(t,e,r){for(var n=t.toString(2);n.length<e;)n="0"+n;for(var i=[],s=0;s<e;s+=r)i.push(n.slice(s,s+r));return i.join(" ")}},er=rr;function rr(t,e){if(!t)throw new Error(e||"Assertion failed")}function nr(t){this.options=t,this.type=this.options.type,this.blockSize=8,this._init(),this.buffer=new Array(this.blockSize),this.bufferOff=0}rr.equal=function(t,e,r){if(t!=e)throw new Error(r||"Assertion failed: "+t+" != "+e)};var ir=nr;nr.prototype._init=function(){},nr.prototype.update=function(t){return 0===t.length?[]:"decrypt"===this.type?this._updateDecrypt(t):this._updateEncrypt(t)},nr.prototype._buffer=function(t,e){for(var r=Math.min(this.buffer.length-this.bufferOff,t.length-e),n=0;n<r;n++)this.buffer[this.bufferOff+n]=t[e+n];return this.bufferOff+=r,r},nr.prototype._flushBuffer=function(t,e){return this._update(this.buffer,0,t,e),this.bufferOff=0,this.blockSize},nr.prototype._updateEncrypt=function(t){var e=0,r=0,n=new Array(((this.bufferOff+t.length)/this.blockSize|0)*this.blockSize);0!==this.bufferOff&&(e+=this._buffer(t,e),this.bufferOff===this.buffer.length&&(r+=this._flushBuffer(n,r)));for(var i=t.length-(t.length-e)%this.blockSize;e<i;e+=this.blockSize)this._update(t,e,n,r),r+=this.blockSize;for(;e<t.length;e++,this.bufferOff++)this.buffer[this.bufferOff]=t[e];return n},nr.prototype._updateDecrypt=function(t){for(var e=0,r=0,n=Math.ceil((this.bufferOff+t.length)/this.blockSize)-1,i=new Array(n*this.blockSize);n>0;n--)e+=this._buffer(t,e),r+=this._flushBuffer(i,r);return e+=this._buffer(t,e),i},nr.prototype.final=function(t){var e,r;return t&&(e=this.update(t)),r="encrypt"===this.type?this._finalEncrypt():this._finalDecrypt(),e?e.concat(r):r},nr.prototype._pad=function(t,e){if(0===e)return!1;for(;e<t.length;)t[e++]=0;return!0},nr.prototype._finalEncrypt=function(){if(!this._pad(this.buffer,this.bufferOff))return[];var t=new Array(this.blockSize);return this._update(this.buffer,0,t,0),t},nr.prototype._unpad=function(t){return t},nr.prototype._finalDecrypt=function(){er.equal(this.bufferOff,this.blockSize,"Not enough data to decrypt");var t=new Array(this.blockSize);return this._flushBuffer(t,0),this._unpad(t)};var sr=l((function(t){t.exports="function"==typeof Object.create?function(t,e){e&&(t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:function(t,e){if(e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}}})),or=l((function(t){try{var e=s.default;if("function"!=typeof e.inherits)throw"";t.exports=e.inherits}catch(n){t.exports=sr}}));function cr(){this.tmp=new Array(2),this.keys=null}function ar(t){ir.call(this,t);var e=new cr;this._desState=e,this.deriveKeys(e,t.key)}or(ar,ir);var hr=ar;ar.create=function(t){return new ar(t)};var ur=[1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1];ar.prototype.deriveKeys=function(t,e){t.keys=new Array(32),er.equal(e.length,this.blockSize,"Invalid key length");var r=tr.readUInt32BE(e,0),n=tr.readUInt32BE(e,4);tr.pc1(r,n,t.tmp,0),r=t.tmp[0],n=t.tmp[1];for(var i=0;i<t.keys.length;i+=2){var s=ur[i>>>1];r=tr.r28shl(r,s),n=tr.r28shl(n,s),tr.pc2(r,n,t.keys,i)}},ar.prototype._update=function(t,e,r,n){var i=this._desState,s=tr.readUInt32BE(t,e),o=tr.readUInt32BE(t,e+4);tr.ip(s,o,i.tmp,0),s=i.tmp[0],o=i.tmp[1],"encrypt"===this.type?this._encrypt(i,s,o,i.tmp,0):this._decrypt(i,s,o,i.tmp,0),o=i.tmp[1],tr.writeUInt32BE(r,s=i.tmp[0],n),tr.writeUInt32BE(r,o,n+4)},ar.prototype._pad=function(t,e){for(var r=t.length-e,n=e;n<t.length;n++)t[n]=r;return!0},ar.prototype._unpad=function(t){for(var e=t[t.length-1],r=t.length-e;r<t.length;r++)er.equal(t[r],e);return t.slice(0,t.length-e)},ar.prototype._encrypt=function(t,e,r,n,i){for(var s=e,o=r,c=0;c<t.keys.length;c+=2){var a=t.keys[c],h=t.keys[c+1];tr.expand(o,t.tmp,0);var u=tr.substitute(a^=t.tmp[0],h^=t.tmp[1]),f=o;o=(s^tr.permute(u))>>>0,s=f}tr.rip(o,s,n,i)},ar.prototype._decrypt=function(t,e,r,n,i){for(var s=r,o=e,c=t.keys.length-2;c>=0;c-=2){var a=t.keys[c],h=t.keys[c+1];tr.expand(s,t.tmp,0);var u=tr.substitute(a^=t.tmp[0],h^=t.tmp[1]),f=s;s=(o^tr.permute(u))>>>0,o=f}tr.rip(s,o,n,i)};var fr={};function lr(t){er.equal(t.length,8,"Invalid IV length"),this.iv=new Array(8);for(var e=0;e<this.iv.length;e++)this.iv[e]=t[e]}fr._cbcInit=function(){var t=new lr(this.options.iv);this._cbcState=t},fr._update=function(t,e,r,n){var i=this.constructor.super_.prototype,s=this._cbcState.iv;if("encrypt"===this.type){for(var o=0;o<this.blockSize;o++)s[o]^=t[e+o];for(i._update.call(this,s,0,r,n),o=0;o<this.blockSize;o++)s[o]=r[n+o]}else{for(i._update.call(this,t,e,r,n),o=0;o<this.blockSize;o++)r[n+o]^=s[o];for(o=0;o<this.blockSize;o++)s[o]=t[e+o]}};var yr={instantiate:function(t){function e(e){t.call(this,e),this._cbcInit()}or(e,t);for(var r=Object.keys(fr),n=0;n<r.length;n++){var i=r[n];e.prototype[i]=fr[i]}return e.create=function(t){return new e(t)},e}};function dr(t,e){er.equal(e.length,24,"Invalid key length");var r=e.slice(0,8),n=e.slice(8,16),i=e.slice(16,24);this.ciphers="encrypt"===t?[hr.create({type:"encrypt",key:r}),hr.create({type:"decrypt",key:n}),hr.create({type:"encrypt",key:i})]:[hr.create({type:"decrypt",key:i}),hr.create({type:"encrypt",key:n}),hr.create({type:"decrypt",key:r})]}function wr(t){ir.call(this,t);var e=new dr(this.type,this.options.key);this._edeState=e}or(wr,ir);var pr=wr;wr.create=function(t){return new wr(t)},wr.prototype._update=function(t,e,r,n){var i=this._edeState;i.ciphers[0]._update(t,e,r,n),i.ciphers[1]._update(r,n,r,n),i.ciphers[2]._update(r,n,r,n)},wr.prototype._pad=hr.prototype._pad,wr.prototype._unpad=hr.prototype._unpad;var vr=tr,mr=ir,Ar=hr,gr=yr,br=pr,kr={utils:vr,Cipher:mr,DES:Ar,CBC:gr,EDE:br},Sr=Object.freeze(Object.assign(Object.create(null),kr,{default:kr,utils:vr,Cipher:mr,DES:Ar,CBC:gr,EDE:br}));class Br extends pe{constructor(t,e,r,n){super(t,e,"secret",r),this.raw=n}toJSON(){return{kty:"oct",alg:this.getJwkAlgorithm(),k:h.ToBase64Url(this.raw),ext:this.extractable,key_ops:this.usages}}getJwkAlgorithm(){switch(this.algorithm.name.toUpperCase()){case"DES-CBC":return"DES-CBC";case"DES-EDE3-CBC":return"3DES-CBC";default:throw new Bt("Unsupported algorithm name")}}}class Er{static checkLib(){if(void 0===Sr)throw new Kt("Cannot implement DES mechanism. Add 'https://peculiarventures.github.io/pv-webcrypto-tests/src/des.js' script to your project")}static checkCryptoKey(t){if(!(t instanceof Br))throw new TypeError("key: Is not DesCryptoKey")}static generateKey(e,r,n){return f(this,void 0,void 0,(function*(){this.checkLib();const i=t.nativeCrypto.getRandomValues(new Uint8Array(e.length/8));return new Br(e,r,n,i)}))}static exportKey(t,e){return f(this,void 0,void 0,(function*(){switch(this.checkLib(),t){case"jwk":return e.toJSON();case"raw":return e.raw.buffer;default:throw new Kt("format: Must be 'jwk' or 'raw'")}}))}static importKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){let t;if(this.checkLib(),t=Nt(e)?h.FromBase64Url(e.k):c.toArrayBuffer(e),"DES-CBC"===r.name&&8!==t.byteLength||"DES-EDE3-CBC"===r.name&&24!==t.byteLength)throw new Kt("keyData: Is wrong key length");return new Br({name:r.name,length:t.byteLength<<3},n,i,new Uint8Array(t))}))}static encrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,r,!0)}))}static decrypt(t,e,r){return f(this,void 0,void 0,(function*(){return this.cipher(t,e,r,!1)}))}static cipher(t,e,r,n){return f(this,void 0,void 0,(function*(){this.checkLib();const i=n?"encrypt":"decrypt";let s;const o=c.toUint8Array(t.iv);switch(t.name.toUpperCase()){case"DES-CBC":s=gr.instantiate(Ar).create({key:e.raw,type:i,iv:o});break;case"DES-EDE3-CBC":s=gr.instantiate(br).create({key:e.raw,type:i,iv:o});break;default:throw new Kt("algorithm: Is not recognized")}const a=s.update(new Uint8Array(r)).concat(s.final());return new Uint8Array(a).buffer}))}}class Kr extends Dt{constructor(){super(...arguments),this.keySizeBits=64,this.ivSize=8,this.name="DES-CBC"}onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Er.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Er.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Er.importKey(t,e,r,n,i)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Er.encrypt(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Er.decrypt(t,e,r)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Er.checkCryptoKey(t)}}class xr extends Dt{constructor(){super(...arguments),this.keySizeBits=192,this.ivSize=8,this.name="DES-EDE3-CBC"}onGenerateKey(t,e,r){return f(this,void 0,void 0,(function*(){return Er.generateKey(t,e,r)}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){return Er.exportKey(t,e)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){return Er.importKey(t,e,r,n,i)}))}onEncrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Er.encrypt(t,e,r)}))}onDecrypt(t,e,r){return f(this,void 0,void 0,(function*(){return Er.decrypt(t,e,r)}))}checkCryptoKey(t,e){super.checkCryptoKey(t,e),Er.checkCryptoKey(t)}}const Nr={fromJSON:t=>Buffer.from(h.FromBase64Url(t)),toJSON:t=>h.ToBase64Url(t)};class Ur extends pe{constructor(t={name:"HMAC"},e=!1,r=[],n=new Uint8Array(0)){super(t,e,"secret",r),this.kty="oct",this.data=n}get alg(){return"HS"+this.algorithm.hash.name.toUpperCase().replace("SHA-","")}set alg(t){}}u([kt({name:"ext",type:ut.Boolean,optional:!0})],Ur.prototype,"extractable",void 0),u([kt({name:"key_ops",type:ut.String,repeated:!0,optional:!0})],Ur.prototype,"usages",void 0),u([kt({name:"k",converter:Nr})],Ur.prototype,"data",void 0),u([kt({type:ut.String})],Ur.prototype,"kty",void 0),u([kt({type:ut.String})],Ur.prototype,"alg",null);class Cr extends qt{onGenerateKey(e,r,n){return f(this,void 0,void 0,(function*(){const i=e.length||this.getDefaultLength(e.hash.name),s=t.nativeCrypto.getRandomValues(new Uint8Array(i>>3));return new Ur(e,r,n,s)}))}onSign(t,r,n){return f(this,void 0,void 0,(function*(){let t;switch(r.algorithm.hash.name.toUpperCase()){case"SHA-1":t=e.HmacSha1;break;case"SHA-256":t=e.HmacSha256;break;case"SHA-512":t=e.HmacSha512;break;default:throw new Kt("key.algorithm.hash: Is not recognized")}const i=new t(r.data).process(c.toUint8Array(n)).finish().result;return c.toArrayBuffer(i)}))}onVerify(t,e,r,n){return f(this,void 0,void 0,(function*(){const i=yield this.onSign(t,e,n);return h.ToHex(i)===h.ToHex(r)}))}onImportKey(t,e,r,n,i){return f(this,void 0,void 0,(function*(){let s;switch(t.toLowerCase()){case"jwk":s=bt.fromJSON(e,{targetSchema:Ur});break;case"raw":if(!c.isBufferSource(e))throw new TypeError("keyData: Is not ArrayBuffer or ArrayBufferView");s=new Ur(r,n,i,c.toUint8Array(e));break;default:throw new Kt("format: Must be 'jwk' or 'raw'")}return s.algorithm={hash:{name:r.hash.name},name:this.name,length:s.data.length<<3},s.extractable=n,s.usages=i,s}))}onExportKey(t,e){return f(this,void 0,void 0,(function*(){switch(t.toLowerCase()){case"jwk":return gt.toJSON(e);case"raw":return new Uint8Array(e.data).buffer;default:throw new Kt("format: Must be 'jwk' or 'raw'")}}))}checkCryptoKey(t,e){if(super.checkCryptoKey(t,e),!(t instanceof Ur))throw new TypeError("key: Is not HMAC CryptoKey")}}var Or;class Ir extends pe{constructor(t,e,r,n,i){super(t,e,r,n),Or.set(this,void 0),function(t,e,r){if(!e.has(t))throw new TypeError("attempted to set private field on non-instance");e.set(t,r)}(this,Or,i)}getNative(){return function(t,e){if(!e.has(t))throw new TypeError("attempted to get private field on non-instance");return e.get(t)}(this,Or)}}Or=new WeakMap;class Tr extends Xt{constructor(){super(),this.browserInfo=function(){const t={name:le.Unknown,version:"0"};if("undefined"==typeof self)return t;const e=self.navigator.userAgent;let r;return(r=/edge\/([\d\.]+)/i.exec(e))?(t.name=le.Edge,t.version=r[1]):/msie/i.test(e)?(t.name=le.IE,t.version=/msie ([\d\.]+)/i.exec(e)[1]):/Trident/i.test(e)?(t.name=le.IE,t.version=/rv:([\d\.]+)/i.exec(e)[1]):/chrome/i.test(e)?(t.name=le.Chrome,t.version=/chrome\/([\d\.]+)/i.exec(e)[1]):/firefox/i.test(e)?(t.name=le.Firefox,t.version=/firefox\/([\d\.]+)/i.exec(e)[1]):/mobile/i.test(e)?(t.name=le.Mobile,t.version=/mobile\/([\w]+)/i.exec(e)[1]):/safari/i.test(e)&&(t.name=le.Safari,t.version=/version\/([\d\.]+)/i.exec(e)[1]),t}(),this.providers.set(new ge),this.providers.set(new Se),this.providers.set(new be),this.providers.set(new ke),this.providers.set(new Be),this.providers.set(new Kr),this.providers.set(new xr),this.providers.set(new Ce),this.providers.set(new Ue),this.providers.set(new Ne),this.providers.set(new Oe),this.providers.set(new $e),this.providers.set(new De),this.providers.set(new ze),this.providers.set(new qe),this.providers.set(new Le),this.providers.set(new Ze),this.providers.set(new Cr),this.providers.set(new _e)}static isAnotherKey(t){return"object"==typeof t&&"string"==typeof t.type&&"boolean"==typeof t.extractable&&"object"==typeof t.algorithm&&!(t instanceof pe)}digest(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("digest",...t)}))}importKey(...t){return f(this,void 0,void 0,(function*(){return this.fixFirefoxEcImportPkcs8(t),this.wrapNative("importKey",...t)}))}exportKey(...t){return f(this,void 0,void 0,(function*(){return(yield this.fixFirefoxEcExportPkcs8(t))||(yield this.wrapNative("exportKey",...t))}))}generateKey(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("generateKey",...t)}))}sign(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("sign",...t)}))}verify(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("verify",...t)}))}encrypt(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("encrypt",...t)}))}decrypt(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("decrypt",...t)}))}wrapKey(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("wrapKey",...t)}))}unwrapKey(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("unwrapKey",...t)}))}deriveBits(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("deriveBits",...t)}))}deriveKey(...t){return f(this,void 0,void 0,(function*(){return this.wrapNative("deriveKey",...t)}))}wrapNative(e,...r){const i=t=>super[t];return f(this,void 0,void 0,(function*(){~["generateKey","unwrapKey","deriveKey","importKey"].indexOf(e)&&this.fixAlgorithmName(r);try{if("digest"!==e||!r.some(t=>t instanceof pe)){const n=this.fixNativeArguments(e,r);de.info(`Call native '${e}' method`,n);const i=yield t.nativeSubtle[e].apply(t.nativeSubtle,n);return this.fixNativeResult(e,r,i)}}catch(n){de.warn(`Error on native '${e}' calling. ${n.message}`,n)}if("wrapKey"===e)try{de.info("Trying to wrap key by using native functions",r);const t=yield this.exportKey(r[0],r[1]),e="jwk"===r[0]?h.FromUtf8String(JSON.stringify(t)):t;return yield this.encrypt(r[3],r[2],e)}catch(n){de.warn("Cannot wrap key by native functions. "+n.message,n)}if("unwrapKey"===e)try{de.info("Trying to unwrap key by using native functions",r);const t=yield this.decrypt(r[3],r[2],r[1]),e="jwk"===r[0]?JSON.parse(h.ToUtf8String(t)):t;return yield this.importKey(r[0],e,r[4],r[5],r[6])}catch(n){de.warn("Cannot unwrap key by native functions. "+n.message,n)}if("deriveKey"===e)try{de.info("Trying to derive key by using native functions",r);const t=yield this.deriveBits(r[0],r[1],r[2].length);return yield this.importKey("raw",t,r[2],r[3],r[4])}catch(n){de.warn("Cannot derive key by native functions. "+n.message,n)}if("deriveBits"===e||"deriveKey"===e)for(const t of r)"object"==typeof t&&t.public&&Tr.isAnotherKey(t.public)&&(t.public=yield this.castKey(t.public));for(let t=0;t<r.length;t++){const e=r[t];Tr.isAnotherKey(e)&&(r[t]=yield this.castKey(e))}return i(e).apply(this,r)}))}fixNativeArguments(t,e){var r,n,i,s,o,a,u,f;const l=[...e];if("importKey"===t&&(this.browserInfo.name!==le.IE||"jwk"!==(null===(n=null===(r=l[0])||void 0===r?void 0:r.toLowerCase)||void 0===n?void 0:n.call(r))||c.isBufferSource(l[1])||(l[1]=h.FromUtf8String(JSON.stringify(l[1])))),this.browserInfo.name===le.IE&&e[1]instanceof Ir)switch(t){case"sign":case"verify":case"encrypt":case"decrypt":l[0]=Object.assign(Object.assign({},this.prepareAlgorithm(l[0])),{hash:null===(o=null===(s=null===(i=l[1])||void 0===i?void 0:i.algorithm)||void 0===s?void 0:s.hash)||void 0===o?void 0:o.name});break;case"wrapKey":case"unwrapKey":l[4]=Object.assign(Object.assign({},this.prepareAlgorithm(l[4])),{hash:null===(f=null===(u=null===(a=l[3])||void 0===a?void 0:a.algorithm)||void 0===u?void 0:u.hash)||void 0===f?void 0:f.name})}for(let c=0;c<l.length;c++){const t=l[c];t instanceof Ir&&(l[c]=t.getNative())}return l}fixNativeResult(t,e,r){var n,i;if(this.browserInfo.name===le.IE){if("exportKey"===t&&"jwk"===(null===(i=null===(n=e[0])||void 0===n?void 0:n.toLowerCase)||void 0===i?void 0:i.call(n))&&r instanceof ArrayBuffer)return JSON.parse(h.ToUtf8String(r));if("privateKey"in r){const t=["sign","decrypt","unwrapKey","deriveKey","deriveBits"],n=["verify","encrypt","wrapKey"];return{privateKey:this.wrapNativeKey(r.privateKey,e[0],e[1],e[2].filter(e=>t.includes(e))),publicKey:this.wrapNativeKey(r.publicKey,e[0],e[1],e[2].filter(t=>n.includes(t)))}}if("extractable"in r){let n,i;switch(t){case"importKey":n=e[2],i=e[4];break;case"unwrapKey":n=e[4],i=e[6];break;case"generateKey":n=e[0],i=e[2];break;default:throw new Kt("Cannot wrap native key. Unsupported method in use")}return this.wrapNativeKey(r,n,r.extractable,i)}}return r}wrapNativeKey(t,e,r,n){if(this.browserInfo.name===le.IE){const i=["RSASSA-PKCS1-v1_5","RSA-PSS","RSA-OAEP","AES-CBC","AES-CTR","AES-KW","HMAC"],s=i.map(t=>t.toLowerCase()).indexOf(t.algorithm.name.toLowerCase());if(-1!==s){const o=this.prepareAlgorithm(e),c=Object.assign(Object.assign({},t.algorithm),{name:i[s]});return Xt.isHashedAlgorithm(o)&&(c.hash={name:o.hash.name.toUpperCase()}),de.info(`Wrapping ${i[s]} crypto key to WrappedNativeCryptoKey`),new Ir(c,r,t.type,n,t)}}return t}castKey(t){return f(this,void 0,void 0,(function*(){if(de.info("Cast native CryptoKey to linter key.",t),!t.extractable)throw new Error("Cannot cast unextractable crypto key");const e=this.getProvider(t.algorithm.name),r=yield this.exportKey("jwk",t);return e.importKey("jwk",r,t.algorithm,!0,t.usages)}))}fixAlgorithmName(t){if(this.browserInfo.name===le.Edge)for(let e=0;e<t.length;e++){const r=t[0];if("string"==typeof r){for(const n of this.providers.algorithms)if(n.toLowerCase()===r.toLowerCase()){t[e]=n;break}}else if("object"==typeof r&&"string"==typeof r.name)for(const t of this.providers.algorithms)t.toLowerCase()===r.name.toLowerCase()&&(r.name=t),("string"==typeof r.hash&&t.toLowerCase()===r.hash.toLowerCase()||"object"==typeof r.hash&&"string"==typeof r.hash.name&&t.toLowerCase()===r.hash.name.toLowerCase())&&(r.hash={name:t})}}fixFirefoxEcImportPkcs8(t){const e=this.prepareAlgorithm(t[2]),r=e.name.toUpperCase();if(this.browserInfo.name===le.Firefox&&"pkcs8"===t[0]&&~["ECDSA","ECDH"].indexOf(r)&&~["P-256","P-384","P-521"].indexOf(e.namedCurve)){if(!c.isBufferSource(t[1]))throw new TypeError("data: Is not ArrayBuffer or ArrayBufferView");const r=c.toArrayBuffer(t[1]),n=nt.parse(r,ye.PrivateKeyInfo),i=nt.parse(n.privateKey,ye.EcPrivateKey),s=gt.toJSON(i);s.ext=!0,s.key_ops=t[4],s.crv=e.namedCurve,s.kty="EC",t[0]="jwk",t[1]=s}}fixFirefoxEcExportPkcs8(t){return f(this,void 0,void 0,(function*(){try{if(this.browserInfo.name===le.Firefox&&"pkcs8"===t[0]&&~["ECDSA","ECDH"].indexOf(t[1].algorithm.name)&&~["P-256","P-384","P-521"].indexOf(t[1].algorithm.namedCurve)){const e=yield this.exportKey("jwk",t[1]),r=bt.fromJSON(e,{targetSchema:ye.EcPrivateKey}),n=new ye.PrivateKeyInfo;return n.privateKeyAlgorithm.algorithm=Pe.ASN_ALGORITHM,n.privateKeyAlgorithm.parameters=nt.serialize(new ye.ObjectIdentifier(Te(t[1].algorithm.namedCurve))),n.privateKey=nt.serialize(r),nt.serialize(n)}}catch(Mr){return de.error(Mr),null}}))}}Tr.methods=["digest","importKey","exportKey","sign","verify","generateKey","encrypt","decrypt","deriveBits","deriveKey","wrapKey","unwrapKey"];class jr extends Ft{constructor(){super(...arguments),this.subtle=new Tr}get nativeCrypto(){return t.nativeCrypto}getRandomValues(e){return t.nativeCrypto.getRandomValues(e)}}function Pr(t,e){const r=t[e];t[e]=function(){const n=arguments;return new Promise((i,s)=>{const o=r.apply(t,n);o.oncomplete=t=>{i(t.target.result)},o.onerror=()=>{s(`Error on running '${e}' function`)}})}}"undefined"!=typeof self&&self.msCrypto&&(Pr(t.nativeSubtle,"generateKey"),Pr(t.nativeSubtle,"digest"),Pr(t.nativeSubtle,"sign"),Pr(t.nativeSubtle,"verify"),Pr(t.nativeSubtle,"encrypt"),Pr(t.nativeSubtle,"decrypt"),Pr(t.nativeSubtle,"importKey"),Pr(t.nativeSubtle,"exportKey"),Pr(t.nativeSubtle,"wrapKey"),Pr(t.nativeSubtle,"unwrapKey"),Pr(t.nativeSubtle,"deriveKey"),Pr(t.nativeSubtle,"deriveBits")),Math.imul||(Math.imul=function(t,e){const r=65535&t,n=65535&e;return r*n+((t>>>16&65535)*n+r*(e>>>16&65535)<<16>>>0)|0});const Dr=self;t.nativeCrypto&&Object.freeze(t.nativeCrypto.getRandomValues);try{delete self.crypto,Dr.crypto=new jr,Object.freeze(Dr.crypto)}catch(n){de.error(n)}const Rr=Dr.crypto;t.Crypto=jr,t.CryptoKey=pe,t.crypto=Rr,t.setCrypto=function(e){t.nativeCrypto=e,t.nativeSubtle=e.subtle},Object.defineProperty(t,"__esModule",{value:!0})}({},self.asmCrypto,self.elliptic);