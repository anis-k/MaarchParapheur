import{c as e,a as t,u as r}from"./p-7005d10f.js";import{ag as s,ah as i,ai as a,aj as n,ak as o,al as c,am as h,an as u,ao as l,ap as m,aq as w,ar as f,as as d,at as y,au as p,av as b,aw as g,ax as A,ay as v,az as S,aA as k,aB as C,aC as P,aD as E,aE as I,aF as N,aG as B,aH as x,P as U,aI as H,aJ as j,aK as O,aL as D,aM as K,aN as R,aO as V,aP as M,aQ as T,aR as L,aS as q,aT as F,aU as J,f as _,n as W,u as Q,j as G,Q as z,a3 as $,C as Z,L as X,M as Y,m as ee}from"./p-e1655586.js";
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */
Uint8Array.prototype.slice||Object.defineProperty(Uint8Array.prototype,"slice",{value(e,t){return new Uint8Array(Array.prototype.slice.call(this,e,t))}});var te=/iPhone/i,re=/iPod/i,se=/iPad/i,ie=/\biOS-universal(?:.+)Mac\b/i,ae=/\bAndroid(?:.+)Mobile\b/i,ne=/Android/i,oe=/(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,ce=/Silk/i,he=/Windows Phone/i,ue=/\bWindows(?:.+)ARM\b/i,le=/BlackBerry/i,me=/BB10/i,we=/Opera Mini/i,fe=/\b(CriOS|Chrome)(?:.+)Mobile/i,de=/Mobile(?:.+)Firefox\b/i,ye=function(e){return void 0!==e&&"MacIntel"===e.platform&&"number"==typeof e.maxTouchPoints&&e.maxTouchPoints>1&&"undefined"==typeof MSStream};const pe=r(e((function(e,t){!function(e){class t{static isArrayBuffer(e){return"[object ArrayBuffer]"===Object.prototype.toString.call(e)}static toArrayBuffer(e){const t=this.toUint8Array(e);return t.byteOffset||t.length?t.buffer.slice(t.byteOffset,t.byteOffset+t.length):t.buffer}static toUint8Array(e){return this.toView(e,Uint8Array)}static toView(e,t){if("undefined"!=typeof Buffer&&Buffer.isBuffer(e))return new t(e.buffer,e.byteOffset,e.byteLength);if(this.isArrayBuffer(e))return new t(e);if(this.isArrayBufferView(e))return new t(e.buffer,e.byteOffset,e.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(e){return this.isArrayBufferView(e)||this.isArrayBuffer(e)}static isArrayBufferView(e){return ArrayBuffer.isView(e)||e&&this.isArrayBuffer(e.buffer)}}class r{static isHex(e){return"string"==typeof e&&/^[a-z0-9]+$/i.test(e)}static isBase64(e){return"string"==typeof e&&/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}static isBase64Url(e){return"string"==typeof e&&/^[a-zA-Z0-9-_]+$/i.test(e)}static ToString(e,r="utf8"){const s=t.toUint8Array(e);switch(r.toLowerCase()){case"utf8":return this.ToUtf8String(s);case"binary":return this.ToBinary(s);case"hex":return this.ToHex(s);case"base64":return this.ToBase64(s);case"base64url":return this.ToBase64Url(s);default:throw new Error(`Unknown type of encoding '${r}'`)}}static FromString(e,t="utf8"){if(!e)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(e);case"binary":return this.FromBinary(e);case"hex":return this.FromHex(e);case"base64":return this.FromBase64(e);case"base64url":return this.FromBase64Url(e);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(e){const r=t.toUint8Array(e);if("undefined"!=typeof btoa){const e=this.ToString(r,"binary");return btoa(e)}return Buffer.from(r).toString("base64")}static FromBase64(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!r.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(e){const t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!r.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(e){return this.ToBase64(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(e){const t=unescape(encodeURIComponent(e)),r=new Uint8Array(t.length);for(let s=0;s<t.length;s++)r[s]=t.charCodeAt(s);return r.buffer}static ToUtf8String(e){const r=t.toUint8Array(e);let s="";for(let t=0;t<r.length;t++)s+=String.fromCharCode(r[t]);return decodeURIComponent(escape(s))}static FromBinary(e){const t=e.length,r=new Uint8Array(t);for(let s=0;s<t;s++)r[s]=e.charCodeAt(s);return r.buffer}static ToBinary(e){const r=t.toUint8Array(e);let s="";for(let t=0;t<r.length;t++)s+=String.fromCharCode(r[t]);return s}static ToHex(e){const r=t.toUint8Array(e),s=[],i=r.length;for(let t=0;t<i;t++){const e=r[t].toString(16).padStart(2,"0");s.push(e)}return s.join("")}static FromHex(e){let t=this.formatString(e);if(!t)return new ArrayBuffer(0);if(!r.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t="0"+t);const s=new Uint8Array(t.length/2);for(let r=0;r<t.length;r+=2){const e=t.slice(r,r+2);s[r/2]=parseInt(e,16)}return s.buffer}static Base64Padding(e){const t=4-e.length%4;if(t<4)for(let r=0;r<t;r++)e+="=";return e}static formatString(e){return(null==e?void 0:e.replace(/[\n\r\t ]/g,""))||""}}e.BufferSourceConverter=t,e.Convert=r,e.assign=function(e){const t=arguments[0];for(let r=1;r<arguments.length;r++){const e=arguments[r];for(const r in e)t[r]=e[r]}return t},e.combine=function(...e){const t=e.map(e=>e.byteLength).reduce((e,t)=>e+t),r=new Uint8Array(t);let s=0;return e.map(e=>new Uint8Array(e)).forEach(e=>{for(const t of e)r[s++]=t}),r.buffer},e.isEqual=function(e,t){if(!e||!t)return!1;if(e.byteLength!==t.byteLength)return!1;const r=new Uint8Array(e),s=new Uint8Array(t);for(let i=0;i<e.byteLength;i++)if(r[i]!==s[i])return!1;return!0},Object.defineProperty(e,"__esModule",{value:!0})}(t)})));class be{constructor(e={}){this.algorithmId=s(e,"algorithmId",be.defaultValues("algorithmId")),"algorithmParams"in e&&(this.algorithmParams=s(e,"algorithmParams",be.defaultValues("algorithmParams"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"algorithmId":return"";case"algorithmParams":return new i;default:throw new Error("Invalid member name for AlgorithmIdentifier class: "+e)}}static compareWithDefault(e,t){switch(e){case"algorithmId":return""===t;case"algorithmParams":return t instanceof i;default:throw new Error("Invalid member name for AlgorithmIdentifier class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",optional:t.optional||!1,value:[new n({name:t.algorithmIdentifier||""}),new i({name:t.algorithmParams||"",optional:!0})]})}fromSchema(e){o(e,["algorithm","params"]);const t=c(e,e,be.schema({names:{algorithmIdentifier:"algorithm",algorithmParams:"params"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");this.algorithmId=t.result.algorithm.valueBlock.toString(),"params"in t.result&&(this.algorithmParams=t.result.params)}toSchema(){const e=[];return e.push(new n({value:this.algorithmId})),"algorithmParams"in this&&this.algorithmParams instanceof i==0&&e.push(this.algorithmParams),new a({value:e})}toJSON(){const e={algorithmId:this.algorithmId};return"algorithmParams"in this&&this.algorithmParams instanceof i==0&&(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof be!=0&&this.algorithmId===e.algorithmId&&("algorithmParams"in this?"algorithmParams"in e&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!("algorithmParams"in e))}}class ge{constructor(e={}){this.x=s(e,"x",ge.defaultValues("x")),this.y=s(e,"y",ge.defaultValues("y")),this.namedCurve=s(e,"namedCurve",ge.defaultValues("namedCurve")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"x":case"y":return new ArrayBuffer(0);case"namedCurve":return"";default:throw new Error("Invalid member name for ECCPublicKey class: "+e)}}static compareWithDefault(e,t){switch(e){case"x":case"y":return h(t,ge.defaultValues(e));case"namedCurve":return""===t;default:throw new Error("Invalid member name for ECCPublicKey class: "+e)}}static schema(e={}){return new u}fromSchema(e){if(e instanceof ArrayBuffer==0)throw new Error("Object's schema was not verified against input data for ECPublicKey");if(4!==new Uint8Array(e)[0])throw new Error("Object's schema was not verified against input data for ECPublicKey");let t;switch(this.namedCurve){case"1.2.840.10045.3.1.7":t=32;break;case"1.3.132.0.34":t=48;break;case"1.3.132.0.35":t=66;break;default:throw new Error("Incorrect curve OID: "+this.namedCurve)}if(e.byteLength!==2*t+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.x=e.slice(1,t+1),this.y=e.slice(1+t,2*t+1)}toSchema(){return new u({data:l(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}return{crv:e,x:m(w(this.x),!0,!0,!1),y:m(w(this.y),!0,!0,!1)}}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("x"in e))throw new Error('Absent mandatory parameter "x"');{const r=f(d(e.x,!0));if(r.byteLength<t){this.x=new ArrayBuffer(t);const e=new Uint8Array(this.x),s=new Uint8Array(r);e.set(s,1)}else this.x=r.slice(0,t)}if(!("y"in e))throw new Error('Absent mandatory parameter "y"');{const r=f(d(e.y,!0));if(r.byteLength<t){this.y=new ArrayBuffer(t);const e=new Uint8Array(this.y),s=new Uint8Array(r);e.set(s,1)}else this.y=r.slice(0,t)}}}class Ae{constructor(e={}){this.modulus=s(e,"modulus",Ae.defaultValues("modulus")),this.publicExponent=s(e,"publicExponent",Ae.defaultValues("publicExponent")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"modulus":case"publicExponent":return new y;default:throw new Error("Invalid member name for RSAPublicKey class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new y({name:t.modulus||""}),new y({name:t.publicExponent||""})]})}fromSchema(e){o(e,["modulus","publicExponent"]);const t=c(e,e,Ae.schema({names:{modulus:"modulus",publicExponent:"publicExponent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPublicKey");this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new a({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:m(w(this.modulus.valueBlock.valueHex),!0,!0,!0),e:m(w(this.publicExponent.valueBlock.valueHex),!0,!0,!0)}}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');{const t=f(d(e.n,!0));this.modulus=new y({valueHex:t.slice(0,Math.pow(2,p(t.byteLength)))})}if(!("e"in e))throw new Error('Absent mandatory parameter "e"');this.publicExponent=new y({valueHex:f(d(e.e,!0)).slice(0,3)})}}class ve{constructor(e={}){this.algorithm=s(e,"algorithm",ve.defaultValues("algorithm")),this.subjectPublicKey=s(e,"subjectPublicKey",ve.defaultValues("subjectPublicKey")),"parsedKey"in e&&(this.parsedKey=s(e,"parsedKey",ve.defaultValues("parsedKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"algorithm":return new be;case"subjectPublicKey":return new b;default:throw new Error("Invalid member name for PublicKeyInfo class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[be.schema(t.algorithm||{}),new b({name:t.subjectPublicKey||""})]})}fromSchema(e){o(e,["algorithm","subjectPublicKey"]);const t=c(e,e,ve.schema({names:{algorithm:{names:{blockName:"algorithm"}},subjectPublicKey:"subjectPublicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PublicKeyInfo");switch(this.algorithm=new be({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey,this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams.constructor.blockName()===n.blockName())try{this.parsedKey=new ge({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHex})}catch(r){}break;case"1.2.840.113549.1.1.1":{const e=g(this.subjectPublicKey.valueBlock.valueHex);if(-1!==e.offset)try{this.parsedKey=new Ae({schema:e.result})}catch(r){}}}}toSchema(){return new a({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if("parsedKey"in this==0)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};const e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const r of Object.keys(t))e[r]=t[r];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new ge({json:e}),this.algorithm=new be({algorithmId:"1.2.840.10045.2.1",algorithmParams:new n({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Ae({json:e}),this.algorithm=new be({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new A});break;default:throw new Error('Invalid value for "kty" parameter: '+e.kty)}this.subjectPublicKey=new b({valueHex:this.parsedKey.toSchema().toBER(!1)})}}importKey(e){let t=Promise.resolve();const r=this;if(void 0===e)return Promise.reject("Need to provide publicKey input parameter");const s=Ke();return void 0===s?Promise.reject("Unable to create WebCrypto object"):(t=t.then(()=>s.exportKey("spki",e)),t=t.then(e=>{const t=g(e);try{r.fromSchema(t.result)}catch(s){return Promise.reject("Error during initializing object from schema")}},e=>Promise.reject("Error during exporting public key: "+e)),t)}}class Se{constructor(e={}){this.type=s(e,"type",Se.defaultValues("type")),this.values=s(e,"values",Se.defaultValues("values")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return"";case"values":return[];default:throw new Error("Invalid member name for Attribute class: "+e)}}static compareWithDefault(e,t){switch(e){case"type":return""===t;case"values":return 0===t.length;default:throw new Error("Invalid member name for Attribute class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new n({name:t.type||""}),new v({name:t.setName||"",value:[new S({name:t.values||"",value:new i})]})]})}fromSchema(e){o(e,["type","values"]);const t=c(e,e,Se.schema({names:{type:"type",values:"values"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Attribute");this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new a({value:[new n({value:this.type}),new v({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}}class ke{constructor(e={}){this.version=s(e,"version",ke.defaultValues("version")),this.privateKey=s(e,"privateKey",ke.defaultValues("privateKey")),"namedCurve"in e&&(this.namedCurve=s(e,"namedCurve",ke.defaultValues("namedCurve"))),"publicKey"in e&&(this.publicKey=s(e,"publicKey",ke.defaultValues("publicKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 1;case"privateKey":return new k;case"namedCurve":return"";case"publicKey":return new ge;default:throw new Error("Invalid member name for ECCPrivateKey class: "+e)}}static compareWithDefault(e,t){switch(e){case"version":return t===ke.defaultValues(e);case"privateKey":return t.isEqual(ke.defaultValues(e));case"namedCurve":return""===t;case"publicKey":return ge.compareWithDefault("namedCurve",t.namedCurve)&&ge.compareWithDefault("x",t.x)&&ge.compareWithDefault("y",t.y);default:throw new Error("Invalid member name for ECCPrivateKey class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new y({name:t.version||""}),new k({name:t.privateKey||""}),new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new n({name:t.namedCurve||""})]}),new C({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new b({name:t.publicKey||""})]})]})}fromSchema(e){o(e,["version","privateKey","namedCurve","publicKey"]);const t=c(e,e,ke.schema({names:{version:"version",privateKey:"privateKey",namedCurve:"namedCurve",publicKey:"publicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ECPrivateKey");if(this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,"namedCurve"in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),"publicKey"in t.result){const e={schema:t.result.publicKey.valueBlock.valueHex};"namedCurve"in this&&(e.namedCurve=this.namedCurve),this.publicKey=new ge(e)}}toSchema(){const e=[new y({value:this.version}),this.privateKey];return"namedCurve"in this&&e.push(new C({idBlock:{tagClass:3,tagNumber:0},value:[new n({value:this.namedCurve})]})),"publicKey"in this&&e.push(new C({idBlock:{tagClass:3,tagNumber:1},value:[new b({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new a({value:e})}toJSON(){if("namedCurve"in this==0||ke.compareWithDefault("namedCurve",this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}const t={crv:e,d:m(w(this.privateKey.valueBlock.valueHex),!0,!0,!1)};if("publicKey"in this){const e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("d"in e))throw new Error('Absent mandatory parameter "d"');{const r=f(d(e.d,!0));if(r.byteLength<t){const e=new ArrayBuffer(t),s=new Uint8Array(e),i=new Uint8Array(r);s.set(i,1),this.privateKey=new k({valueHex:e})}else this.privateKey=new k({valueHex:r.slice(0,t)})}"x"in e&&"y"in e&&(this.publicKey=new ge({json:e}))}}class Ce{constructor(e={}){this.prime=s(e,"prime",Ce.defaultValues("prime")),this.exponent=s(e,"exponent",Ce.defaultValues("exponent")),this.coefficient=s(e,"coefficient",Ce.defaultValues("coefficient")),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"prime":case"exponent":case"coefficient":return new y;default:throw new Error("Invalid member name for OtherPrimeInfo class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new y({name:t.prime||""}),new y({name:t.exponent||""}),new y({name:t.coefficient||""})]})}fromSchema(e){o(e,["prime","exponent","coefficient"]);const t=c(e,e,Ce.schema({names:{prime:"prime",exponent:"exponent",coefficient:"coefficient"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherPrimeInfo");this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new a({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:m(w(this.prime.valueBlock.valueHex),!0,!0),d:m(w(this.exponent.valueBlock.valueHex),!0,!0),t:m(w(this.coefficient.valueBlock.valueHex),!0,!0)}}fromJSON(e){if(!("r"in e))throw new Error('Absent mandatory parameter "r"');if(this.prime=new y({valueHex:f(d(e.r,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.exponent=new y({valueHex:f(d(e.d,!0))}),!("t"in e))throw new Error('Absent mandatory parameter "t"');this.coefficient=new y({valueHex:f(d(e.t,!0))})}}class Pe{constructor(e={}){this.version=s(e,"version",Pe.defaultValues("version")),this.modulus=s(e,"modulus",Pe.defaultValues("modulus")),this.publicExponent=s(e,"publicExponent",Pe.defaultValues("publicExponent")),this.privateExponent=s(e,"privateExponent",Pe.defaultValues("privateExponent")),this.prime1=s(e,"prime1",Pe.defaultValues("prime1")),this.prime2=s(e,"prime2",Pe.defaultValues("prime2")),this.exponent1=s(e,"exponent1",Pe.defaultValues("exponent1")),this.exponent2=s(e,"exponent2",Pe.defaultValues("exponent2")),this.coefficient=s(e,"coefficient",Pe.defaultValues("coefficient")),"otherPrimeInfos"in e&&(this.otherPrimeInfos=s(e,"otherPrimeInfos",Pe.defaultValues("otherPrimeInfos"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 0;case"modulus":case"publicExponent":case"privateExponent":case"prime1":case"prime2":case"exponent1":case"exponent2":case"coefficient":return new y;case"otherPrimeInfos":return[];default:throw new Error("Invalid member name for RSAPrivateKey class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new y({name:t.version||""}),new y({name:t.modulus||""}),new y({name:t.publicExponent||""}),new y({name:t.privateExponent||""}),new y({name:t.prime1||""}),new y({name:t.prime2||""}),new y({name:t.exponent1||""}),new y({name:t.exponent2||""}),new y({name:t.coefficient||""}),new a({optional:!0,value:[new S({name:t.otherPrimeInfosName||"",value:Ce.schema(t.otherPrimeInfo||{})})]})]})}fromSchema(e){o(e,["version","modulus","publicExponent","privateExponent","prime1","prime2","exponent1","exponent2","coefficient","otherPrimeInfos"]);const t=c(e,e,Pe.schema({names:{version:"version",modulus:"modulus",publicExponent:"publicExponent",privateExponent:"privateExponent",prime1:"prime1",prime2:"prime2",exponent1:"exponent1",exponent2:"exponent2",coefficient:"coefficient",otherPrimeInfo:{names:{blockName:"otherPrimeInfos"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPrivateKey");this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),"otherPrimeInfos"in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,e=>new Ce({schema:e})))}toSchema(){const e=[];return e.push(new y({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),"otherPrimeInfos"in this&&e.push(new a({value:Array.from(this.otherPrimeInfos,e=>e.toSchema())})),new a({value:e})}toJSON(){const e={n:m(w(this.modulus.valueBlock.valueHex),!0,!0,!0),e:m(w(this.publicExponent.valueBlock.valueHex),!0,!0,!0),d:m(w(this.privateExponent.valueBlock.valueHex),!0,!0,!0),p:m(w(this.prime1.valueBlock.valueHex),!0,!0,!0),q:m(w(this.prime2.valueBlock.valueHex),!0,!0,!0),dp:m(w(this.exponent1.valueBlock.valueHex),!0,!0,!0),dq:m(w(this.exponent2.valueBlock.valueHex),!0,!0,!0),qi:m(w(this.coefficient.valueBlock.valueHex),!0,!0,!0)};return"otherPrimeInfos"in this&&(e.oth=Array.from(this.otherPrimeInfos,e=>e.toJSON())),e}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');if(this.modulus=new y({valueHex:f(d(e.n,!0,!0))}),!("e"in e))throw new Error('Absent mandatory parameter "e"');if(this.publicExponent=new y({valueHex:f(d(e.e,!0,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.privateExponent=new y({valueHex:f(d(e.d,!0,!0))}),!("p"in e))throw new Error('Absent mandatory parameter "p"');if(this.prime1=new y({valueHex:f(d(e.p,!0,!0))}),!("q"in e))throw new Error('Absent mandatory parameter "q"');if(this.prime2=new y({valueHex:f(d(e.q,!0,!0))}),!("dp"in e))throw new Error('Absent mandatory parameter "dp"');if(this.exponent1=new y({valueHex:f(d(e.dp,!0,!0))}),!("dq"in e))throw new Error('Absent mandatory parameter "dq"');if(this.exponent2=new y({valueHex:f(d(e.dq,!0,!0))}),!("qi"in e))throw new Error('Absent mandatory parameter "qi"');this.coefficient=new y({valueHex:f(d(e.qi,!0,!0))}),"oth"in e&&(this.otherPrimeInfos=Array.from(e.oth,e=>new Ce({json:e})))}}class Ee{constructor(e={}){this.version=s(e,"version",Ee.defaultValues("version")),this.privateKeyAlgorithm=s(e,"privateKeyAlgorithm",Ee.defaultValues("privateKeyAlgorithm")),this.privateKey=s(e,"privateKey",Ee.defaultValues("privateKey")),"attributes"in e&&(this.attributes=s(e,"attributes",Ee.defaultValues("attributes"))),"parsedKey"in e&&(this.parsedKey=s(e,"parsedKey",Ee.defaultValues("parsedKey"))),"schema"in e&&this.fromSchema(e.schema),"json"in e&&this.fromJSON(e.json)}static defaultValues(e){switch(e){case"version":return 0;case"privateKeyAlgorithm":return new be;case"privateKey":return new k;case"attributes":return[];case"parsedKey":return{};default:throw new Error("Invalid member name for PrivateKeyInfo class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new y({name:t.version||""}),be.schema(t.privateKeyAlgorithm||{}),new k({name:t.privateKey||""}),new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new S({name:t.attributes||"",value:Se.schema()})]})]})}fromSchema(e){o(e,["version","privateKeyAlgorithm","privateKey","attributes"]);const t=c(e,e,Ee.schema({names:{version:"version",privateKeyAlgorithm:{names:{blockName:"privateKeyAlgorithm"}},privateKey:"privateKey",attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyInfo");switch(this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new be({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,"attributes"in t.result&&(this.attributes=Array.from(t.result.attributes,e=>new Se({schema:e}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{const e=g(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Pe({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof n){const e=g(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new ke({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){const e=[new y({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return"attributes"in this&&e.push(new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new a({value:e})}toJSON(){if("parsedKey"in this==0){const e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return"attributes"in this&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}const e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const r of Object.keys(t))e[r]=t[r];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new ke({json:e}),this.privateKeyAlgorithm=new be({algorithmId:"1.2.840.10045.2.1",algorithmParams:new n({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Pe({json:e}),this.privateKeyAlgorithm=new be({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new A});break;default:throw new Error('Invalid value for "kty" parameter: '+e.kty)}this.privateKey=new k({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}class Ie{constructor(e={}){if(this.contentType=s(e,"contentType",Ie.defaultValues("contentType")),this.contentEncryptionAlgorithm=s(e,"contentEncryptionAlgorithm",Ie.defaultValues("contentEncryptionAlgorithm")),"encryptedContent"in e&&(this.encryptedContent=e.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed)){const e=new k({idBlock:{isConstructed:!0},isConstructed:!0});let t=0,r=this.encryptedContent.valueBlock.valueHex.byteLength;for(;r>0;){const s=new Uint8Array(this.encryptedContent.valueBlock.valueHex,t,t+1024>this.encryptedContent.valueBlock.valueHex.byteLength?this.encryptedContent.valueBlock.valueHex.byteLength-t:1024),i=new ArrayBuffer(s.length),a=new Uint8Array(i);for(let e=0;e<a.length;e++)a[e]=s[e];e.valueBlock.value.push(new k({valueHex:i})),r-=s.length,t+=s.length}this.encryptedContent=e}"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"contentType":return"";case"contentEncryptionAlgorithm":return new be;case"encryptedContent":return new k;default:throw new Error("Invalid member name for EncryptedContentInfo class: "+e)}}static compareWithDefault(e,t){switch(e){case"contentType":return""===t;case"contentEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==0;case"encryptedContent":return t.isEqual(Ie.defaultValues(e));default:throw new Error("Invalid member name for EncryptedContentInfo class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new n({name:t.contentType||""}),be.schema(t.contentEncryptionAlgorithm||{}),new P({value:[new C({name:t.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0},value:[new S({value:new k})]}),new E({name:t.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){o(e,["contentType","contentEncryptionAlgorithm","encryptedContent"]);const t=c(e,e,Ie.schema({names:{contentType:"contentType",contentEncryptionAlgorithm:{names:{blockName:"contentEncryptionAlgorithm"}},encryptedContent:"encryptedContent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EncryptedContentInfo");this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new be({schema:t.result.contentEncryptionAlgorithm}),"encryptedContent"in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){const e={isIndefiniteForm:!1},t=[];if(t.push(new n({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),"encryptedContent"in this){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;const r=this.encryptedContent;r.idBlock.tagClass=3,r.idBlock.tagNumber=0,r.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(r)}return new a({lenBlock:e,value:t})}toJSON(){const e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return"encryptedContent"in this&&(e.encryptedContent=this.encryptedContent.toJSON()),e}}class Ne{constructor(e={}){this.hashAlgorithm=s(e,"hashAlgorithm",Ne.defaultValues("hashAlgorithm")),this.maskGenAlgorithm=s(e,"maskGenAlgorithm",Ne.defaultValues("maskGenAlgorithm")),this.saltLength=s(e,"saltLength",Ne.defaultValues("saltLength")),this.trailerField=s(e,"trailerField",Ne.defaultValues("trailerField")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new be({algorithmId:"1.3.14.3.2.26",algorithmParams:new A});case"maskGenAlgorithm":return new be({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new be({algorithmId:"1.3.14.3.2.26",algorithmParams:new A}).toSchema()});case"saltLength":return 20;case"trailerField":return 1;default:throw new Error("Invalid member name for RSASSAPSSParams class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new C({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[be.schema(t.hashAlgorithm||{})]}),new C({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[be.schema(t.maskGenAlgorithm||{})]}),new C({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new y({name:t.saltLength||""})]}),new C({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new y({name:t.trailerField||""})]})]})}fromSchema(e){o(e,["hashAlgorithm","maskGenAlgorithm","saltLength","trailerField"]);const t=c(e,e,Ne.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},maskGenAlgorithm:{names:{blockName:"maskGenAlgorithm"}},saltLength:"saltLength",trailerField:"trailerField"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSASSAPSSParams");"hashAlgorithm"in t.result&&(this.hashAlgorithm=new be({schema:t.result.hashAlgorithm})),"maskGenAlgorithm"in t.result&&(this.maskGenAlgorithm=new be({schema:t.result.maskGenAlgorithm})),"saltLength"in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),"trailerField"in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){const e=[];return this.hashAlgorithm.isEqual(Ne.defaultValues("hashAlgorithm"))||e.push(new C({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(Ne.defaultValues("maskGenAlgorithm"))||e.push(new C({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==Ne.defaultValues("saltLength")&&e.push(new C({idBlock:{tagClass:3,tagNumber:2},value:[new y({value:this.saltLength})]})),this.trailerField!==Ne.defaultValues("trailerField")&&e.push(new C({idBlock:{tagClass:3,tagNumber:3},value:[new y({value:this.trailerField})]})),new a({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(Ne.defaultValues("hashAlgorithm"))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(Ne.defaultValues("maskGenAlgorithm"))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==Ne.defaultValues("saltLength")&&(e.saltLength=this.saltLength),this.trailerField!==Ne.defaultValues("trailerField")&&(e.trailerField=this.trailerField),e}}class Be{constructor(e={}){this.salt=s(e,"salt",Be.defaultValues("salt")),this.iterationCount=s(e,"iterationCount",Be.defaultValues("iterationCount")),"keyLength"in e&&(this.keyLength=s(e,"keyLength",Be.defaultValues("keyLength"))),"prf"in e&&(this.prf=s(e,"prf",Be.defaultValues("prf"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"salt":return{};case"iterationCount":return-1;case"keyLength":return 0;case"prf":return new be({algorithmId:"1.3.14.3.2.26",algorithmParams:new A});default:throw new Error("Invalid member name for PBKDF2Params class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new P({value:[new k({name:t.saltPrimitive||""}),be.schema(t.saltConstructed||{})]}),new y({name:t.iterationCount||""}),new y({name:t.keyLength||"",optional:!0}),be.schema(t.prf||{names:{optional:!0}})]})}fromSchema(e){o(e,["salt","iterationCount","keyLength","prf"]);const t=c(e,e,Be.schema({names:{saltPrimitive:"salt",saltConstructed:{names:{blockName:"salt"}},iterationCount:"iterationCount",keyLength:"keyLength",prf:{names:{blockName:"prf",optional:!0}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBKDF2Params");this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,"keyLength"in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),"prf"in t.result&&(this.prf=new be({schema:t.result.prf}))}toSchema(){const e=[];return e.push(this.salt),e.push(new y({value:this.iterationCount})),"keyLength"in this&&Be.defaultValues("keyLength")!==this.keyLength&&e.push(new y({value:this.keyLength})),"prf"in this&&!1===Be.defaultValues("prf").isEqual(this.prf)&&e.push(this.prf.toSchema()),new a({value:e})}toJSON(){const e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return"keyLength"in this&&Be.defaultValues("keyLength")!==this.keyLength&&(e.keyLength=this.keyLength),"prf"in this&&!1===Be.defaultValues("prf").isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}class xe{constructor(e={}){this.keyDerivationFunc=s(e,"keyDerivationFunc",xe.defaultValues("keyDerivationFunc")),this.encryptionScheme=s(e,"encryptionScheme",xe.defaultValues("encryptionScheme")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyDerivationFunc":case"encryptionScheme":return new be;default:throw new Error("Invalid member name for PBES2Params class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[be.schema(t.keyDerivationFunc||{}),be.schema(t.encryptionScheme||{})]})}fromSchema(e){o(e,["keyDerivationFunc","encryptionScheme"]);const t=c(e,e,xe.schema({names:{keyDerivationFunc:{names:{blockName:"keyDerivationFunc"}},encryptionScheme:{names:{blockName:"encryptionScheme"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBES2Params");this.keyDerivationFunc=new be({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new be({schema:t.result.encryptionScheme})}toSchema(){return new a({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}function Ue(e,t,r,s,i,a){let n,o;const c=[];switch(t.toUpperCase()){case"SHA-1":n=20,o=64;break;case"SHA-256":n=32,o=64;break;case"SHA-384":n=48,o=128;break;case"SHA-512":n=64,o=128;break;default:throw new Error("Unsupported hashing algorithm")}const h=new Uint8Array(s),u=new ArrayBuffer(2*s.byteLength+2),l=new Uint8Array(u);for(let N=0;N<h.length;N++)l[2*N]=0,l[2*N+1]=h[N];l[l.length-2]=0,l[l.length-1]=0,s=u.slice(0);const m=new ArrayBuffer(o),w=new Uint8Array(m);for(let N=0;N<m.byteLength;N++)w[N]=3;const f=i.byteLength,d=o*Math.ceil(f/o),y=new ArrayBuffer(d),p=new Uint8Array(y),b=new Uint8Array(i);for(let N=0;N<d;N++)p[N]=b[N%f];const g=s.byteLength,A=o*Math.ceil(g/o),v=new ArrayBuffer(A),S=new Uint8Array(v),k=new Uint8Array(s);for(let N=0;N<A;N++)S[N]=k[N%g];let C=new ArrayBuffer(y.byteLength+v.byteLength),P=new Uint8Array(C);P.set(p),P.set(S,p.length);const E=Math.ceil((r>>3)/n);let I=Promise.resolve(C);for(let N=0;N<=E;N++){I=I.then(e=>{const t=new ArrayBuffer(m.byteLength+e.byteLength),r=new Uint8Array(t);return r.set(w),r.set(P,w.length),t});for(let r=0;r<a;r++)I=I.then(r=>e.digest({name:t},new Uint8Array(r)));I=I.then(e=>{const t=new ArrayBuffer(o),r=new Uint8Array(t);for(let o=0;o<t.byteLength;o++)r[o]=e[o%e.length];const s=Math.ceil(f/o)+Math.ceil(g/o),i=[];let a=0,n=o;for(let c=0;c<s;c++){const e=Array.from(new Uint8Array(C.slice(a,a+n)));a+=o,a+o>C.byteLength&&(n=C.byteLength-a);let s=511;for(let i=t.byteLength-1;i>=0;i--)s>>=8,s+=r[i]+e[i],e[i]=255&s;i.push(...e)}return C=new ArrayBuffer(i.length),P=new Uint8Array(C),P.set(i),c.push(...new Uint8Array(e)),C})}return I=I.then(()=>{const e=new ArrayBuffer(r>>3);return new Uint8Array(e).set(new Uint8Array(c).slice(0,r>>3)),e}),I}class He{constructor(e={}){this.crypto=s(e,"crypto",{}),this.subtle=s(e,"subtle",{}),this.name=s(e,"name","")}importKey(e,t,r,s,i){let a={};switch(t instanceof Uint8Array&&(t=t.buffer),e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,r,s,i);case"spki":{const e=g(t);if(-1===e.offset)return Promise.reject("Incorrect keyData");const o=new ve;try{o.fromSchema(e.result)}catch(n){return Promise.reject("Incorrect keyData")}switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="PS1";break;case"SHA-256":a.alg="PS256";break;case"SHA-384":a.alg="PS384";break;case"SHA-512":a.alg="PS512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}case"RSASSA-PKCS1-V1_5":{if(i=["verify"],a.kty="RSA",a.ext=s,a.key_ops=i,"1.2.840.113549.1.1.1"!==o.algorithm.algorithmId)return Promise.reject("Incorrect public key algorithm: "+o.algorithm.algorithmId);if("alg"in a==0)switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="RS1";break;case"SHA-256":a.alg="RS256";break;case"SHA-384":a.alg="RS384";break;case"SHA-512":a.alg="RS512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}const e=o.toJSON();for(const t of Object.keys(e))a[t]=e[t]}break;case"ECDSA":i=["verify"];case"ECDH":{if(a={kty:"EC",ext:s,key_ops:i},"1.2.840.10045.2.1"!==o.algorithm.algorithmId)return Promise.reject("Incorrect public key algorithm: "+o.algorithm.algorithmId);const e=o.toJSON();for(const t of Object.keys(e))a[t]=e[t]}break;case"RSA-OAEP":{if(a.kty="RSA",a.ext=s,a.key_ops=i,"safari"===this.name.toLowerCase())a.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="RSA-OAEP";break;case"SHA-256":a.alg="RSA-OAEP-256";break;case"SHA-384":a.alg="RSA-OAEP-384";break;case"SHA-512":a.alg="RSA-OAEP-512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}const e=o.toJSON();for(const t of Object.keys(e))a[t]=e[t]}break;case"RSAES-PKCS1-V1_5":{a.kty="RSA",a.ext=s,a.key_ops=i,a.alg="PS1";const e=o.toJSON();for(const t of Object.keys(e))a[t]=e[t]}break;default:return Promise.reject("Incorrect algorithm name: "+r.name.toUpperCase())}}break;case"pkcs8":{const e=new Ee,o=g(t);if(-1===o.offset)return Promise.reject("Incorrect keyData");try{e.fromSchema(o.result)}catch(n){return Promise.reject("Incorrect keyData")}if("parsedKey"in e==0)return Promise.reject("Incorrect keyData");switch(r.name.toUpperCase()){case"RSA-PSS":switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="PS1";break;case"SHA-256":a.alg="PS256";break;case"SHA-384":a.alg="PS384";break;case"SHA-512":a.alg="PS512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}case"RSASSA-PKCS1-V1_5":{if(i=["sign"],a.kty="RSA",a.ext=s,a.key_ops=i,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject("Incorrect private key algorithm: "+e.privateKeyAlgorithm.algorithmId);if("alg"in a==0)switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="RS1";break;case"SHA-256":a.alg="RS256";break;case"SHA-384":a.alg="RS384";break;case"SHA-512":a.alg="RS512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}const t=e.toJSON();for(const e of Object.keys(t))a[e]=t[e]}break;case"ECDSA":i=["sign"];case"ECDH":{if(a={kty:"EC",ext:s,key_ops:i},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject("Incorrect algorithm: "+e.privateKeyAlgorithm.algorithmId);const t=e.toJSON();for(const e of Object.keys(t))a[e]=t[e]}break;case"RSA-OAEP":{if(a.kty="RSA",a.ext=s,a.key_ops=i,"safari"===this.name.toLowerCase())a.alg="RSA-OAEP";else switch(r.hash.name.toUpperCase()){case"SHA-1":a.alg="RSA-OAEP";break;case"SHA-256":a.alg="RSA-OAEP-256";break;case"SHA-384":a.alg="RSA-OAEP-384";break;case"SHA-512":a.alg="RSA-OAEP-512";break;default:return Promise.reject("Incorrect hash algorithm: "+r.hash.name.toUpperCase())}const t=e.toJSON();for(const e of Object.keys(t))a[e]=t[e]}break;case"RSAES-PKCS1-V1_5":{i=["decrypt"],a.kty="RSA",a.ext=s,a.key_ops=i,a.alg="PS1";const t=e.toJSON();for(const e of Object.keys(t))a[e]=t[e]}break;default:return Promise.reject("Incorrect algorithm name: "+r.name.toUpperCase())}}break;case"jwk":a=t;break;default:return Promise.reject("Incorrect format: "+e)}return"safari"===this.name.toLowerCase()?Promise.resolve().then(()=>this.subtle.importKey("jwk",f(JSON.stringify(a)),r,s,i)).then(e=>e,()=>this.subtle.importKey("jwk",a,r,s,i)):this.subtle.importKey("jwk",a,r,s,i)}exportKey(e,t){let r=this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&(r=r.then(e=>e instanceof ArrayBuffer?JSON.parse(w(e)):e)),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":r=r.then(e=>{const t=new ve;try{t.fromJSON(e)}catch(r){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"pkcs8":r=r.then(e=>{const t=new Ee;try{t.fromJSON(e)}catch(r){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"jwk":break;default:return Promise.reject("Incorrect format: "+e)}return r}convert(e,t,r,s,i,a){switch(e.toLowerCase()){case"raw":switch(t.toLowerCase()){case"raw":return Promise.resolve(r);case"spki":return Promise.resolve().then(()=>this.importKey("raw",r,s,i,a)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("raw",r,s,i,a)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve().then(()=>this.importKey("raw",r,s,i,a)).then(e=>this.exportKey("jwk",e));default:return Promise.reject("Incorrect outputFormat: "+t)}case"spki":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("spki",r,s,i,a)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve(r);case"pkcs8":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"jwk":return Promise.resolve().then(()=>this.importKey("spki",r,s,i,a)).then(e=>this.exportKey("jwk",e));default:return Promise.reject("Incorrect outputFormat: "+t)}case"pkcs8":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,i,a)).then(e=>this.exportKey("raw",e));case"spki":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"pkcs8":return Promise.resolve(r);case"jwk":return Promise.resolve().then(()=>this.importKey("pkcs8",r,s,i,a)).then(e=>this.exportKey("jwk",e));default:return Promise.reject("Incorrect outputFormat: "+t)}case"jwk":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("jwk",r,s,i,a)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve().then(()=>this.importKey("jwk",r,s,i,a)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("jwk",r,s,i,a)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve(r);default:return Promise.reject("Incorrect outputFormat: "+t)}default:return Promise.reject("Incorrect inputFormat: "+e)}}encrypt(...e){return this.subtle.encrypt(...e)}decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}verify(...e){return this.subtle.verify(...e)}digest(...e){return this.subtle.digest(...e)}generateKey(...e){return this.subtle.generateKey(...e)}deriveKey(...e){return this.subtle.deriveKey(...e)}deriveBits(...e){return this.subtle.deriveBits(...e)}wrapKey(...e){return this.subtle.wrapKey(...e)}unwrapKey(...e){return this.subtle.unwrapKey(...e)}getRandomValues(e){if("getRandomValues"in this.crypto==0)throw new Error("No support for getRandomValues");return this.crypto.getRandomValues(e)}getAlgorithmByOID(e){switch(e){case"1.2.840.113549.1.1.1":return{name:"RSAES-PKCS1-v1_5"};case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}return{}}getOIDByAlgorithm(e){let t="";switch(e.name.toUpperCase()){case"RSAES-PKCS1-V1_5":t="1.2.840.113549.1.1.1";break;case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.1.1.5";break;case"SHA-256":t="1.2.840.113549.1.1.11";break;case"SHA-384":t="1.2.840.113549.1.1.12";break;case"SHA-512":t="1.2.840.113549.1.1.13"}break;case"RSA-PSS":t="1.2.840.113549.1.1.10";break;case"RSA-OAEP":t="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.10045.4.1";break;case"SHA-256":t="1.2.840.10045.4.3.2";break;case"SHA-384":t="1.2.840.10045.4.3.3";break;case"SHA-512":t="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":t="1.3.133.16.840.63.0.2";break;case"SHA-256":t="1.3.132.1.11.1";break;case"SHA-384":t="1.3.132.1.11.2";break;case"SHA-512":t="1.3.132.1.11.3"}break;case"AES-CTR":break;case"AES-CBC":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.2";break;case 192:t="2.16.840.1.101.3.4.1.22";break;case 256:t="2.16.840.1.101.3.4.1.42"}break;case"AES-CMAC":break;case"AES-GCM":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.6";break;case 192:t="2.16.840.1.101.3.4.1.26";break;case 256:t="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.4";break;case 192:t="2.16.840.1.101.3.4.1.24";break;case 256:t="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.5";break;case 192:t="2.16.840.1.101.3.4.1.25";break;case 256:t="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.2.7";break;case"SHA-256":t="1.2.840.113549.2.9";break;case"SHA-384":t="1.2.840.113549.2.10";break;case"SHA-512":t="1.2.840.113549.2.11"}break;case"DH":t="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":t="1.3.14.3.2.26";break;case"SHA-256":t="2.16.840.1.101.3.4.2.1";break;case"SHA-384":t="2.16.840.1.101.3.4.2.2";break;case"SHA-512":t="2.16.840.1.101.3.4.2.3";break;case"CONCAT":case"HKDF":break;case"PBKDF2":t="1.2.840.113549.1.5.12";break;case"P-256":t="1.2.840.10045.3.1.7";break;case"P-384":t="1.3.132.0.34";break;case"P-521":t="1.3.132.0.35"}return t}getAlgorithmParameters(e,t){let r={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSAES-PKCS1-V1_5":case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":r={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":r={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":r={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":r={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":r={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;case"exportkey":default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":r={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":r={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":r={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":r={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":r={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":r={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":r={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":r={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":switch(t.toLowerCase()){case"derivekey":r={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"HKDF"},usages:[]}}break;case"PBKDF2":switch(t.toLowerCase()){case"derivekey":r={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"PBKDF2"},usages:[]}}}return r}getHashAlgorithm(e){let t="";switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{const r=new Ne({schema:e.algorithmParams});if("hashAlgorithm"in r){const e=this.getAlgorithmByOID(r.hashAlgorithm.algorithmId);if("name"in e==0)return"";t=e.name}else t="SHA-1"}catch(r){}}return t}encryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("contentEncryptionAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "contentEncryptionAlgorithm"');if("hmacHashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hmacHashAlgorithm"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("contentToEncrypt"in e==0)return Promise.reject('Absent mandatory parameter "contentToEncrypt"');if("contentType"in e==0)return Promise.reject('Absent mandatory parameter "contentType"');const t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm);if(""===t)return Promise.reject('Wrong "contentEncryptionAlgorithm" value');const r=this.getOIDByAlgorithm({name:"PBKDF2"});if(""===r)return Promise.reject("Can not find OID for PBKDF2");const s=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}});if(""===s)return Promise.reject('Incorrect value for "hmacHashAlgorithm": '+e.hmacHashAlgorithm);let i=Promise.resolve();const a=new ArrayBuffer(16),n=new Uint8Array(a);this.getRandomValues(n);const o=new ArrayBuffer(64),c=new Uint8Array(o);this.getRandomValues(c);const h=new Uint8Array(e.contentToEncrypt),u=new Be({salt:new k({valueHex:o}),iterationCount:e.iterationCount,prf:new be({algorithmId:s,algorithmParams:new A})});return i=i.then(()=>{const t=new Uint8Array(e.password);return this.importKey("raw",t,"PBKDF2",!1,["deriveKey"])},e=>Promise.reject(e)),i=i.then(t=>this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:c,iterations:e.iterationCount},t,e.contentEncryptionAlgorithm,!1,["encrypt"]),e=>Promise.reject(e)),i=i.then(t=>this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:n},t,h),e=>Promise.reject(e)),i=i.then(s=>{const i=new xe({keyDerivationFunc:new be({algorithmId:r,algorithmParams:u.toSchema()}),encryptionScheme:new be({algorithmId:t,algorithmParams:new k({valueHex:a})})});return new Ie({contentType:e.contentType,contentEncryptionAlgorithm:new be({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:i.toSchema()}),encryptedContent:new k({valueHex:s})})},e=>Promise.reject(e)),i}decryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("encryptedContentInfo"in e==0)return Promise.reject('Absent mandatory parameter "encryptedContentInfo"');if("1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)return Promise.reject('Unknown "contentEncryptionAlgorithm": '+e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);let t,r,s=Promise.resolve();try{t=new xe({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(h){return Promise.reject('Incorrectly encoded "pbes2Parameters"')}try{r=new Be({schema:t.keyDerivationFunc.algorithmParams})}catch(h){return Promise.reject('Incorrectly encoded "pbkdf2Params"')}const i=this.getAlgorithmByOID(t.encryptionScheme.algorithmId);if("name"in i==0)return Promise.reject('Incorrect OID for "contentEncryptionAlgorithm": '+t.encryptionScheme.algorithmId);const a=new Uint8Array(t.encryptionScheme.algorithmParams.valueBlock.valueHex),n=new Uint8Array(r.salt.valueBlock.valueHex),o=r.iterationCount;let c="SHA-1";if("prf"in r){const e=this.getAlgorithmByOID(r.prf.algorithmId);if("name"in e==0)return Promise.reject("Incorrect OID for HMAC hash algorithm");c=e.hash.name}return s=s.then(()=>this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),e=>Promise.reject(e)),s=s.then(e=>this.deriveKey({name:"PBKDF2",hash:{name:c},salt:n,iterations:o},e,i,!1,["decrypt"]),e=>Promise.reject(e)),s=s.then(t=>{let r=new ArrayBuffer(0);if(!1===e.encryptedContentInfo.encryptedContent.idBlock.isConstructed)r=e.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else for(const s of e.encryptedContentInfo.encryptedContent.valueBlock.value)r=l(r,s.valueBlock.valueHex);return this.decrypt({name:i.name,iv:a},t,r)},e=>Promise.reject(e)),s}stampDataWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToStamp"in e==0)return Promise.reject('Absent mandatory parameter "contentToStamp"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject('Incorrect "parameters.hashAlgorithm" parameter: '+e.hashAlgorithm)}let r=Promise.resolve();const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return r=r.then(()=>Ue(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount)),r=r.then(e=>this.importKey("raw",new Uint8Array(e),s,!1,["sign"])),r=r.then(t=>this.sign(s,t,new Uint8Array(e.contentToStamp)),e=>Promise.reject(e)),r}verifyDataStampedWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToVerify"in e==0)return Promise.reject('Absent mandatory parameter "contentToVerify"');if("signatureToVerify"in e==0)return Promise.reject('Absent mandatory parameter "signatureToVerify"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject('Incorrect "parameters.hashAlgorithm" parameter: '+e.hashAlgorithm)}let r=Promise.resolve();const s={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return r=r.then(()=>Ue(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount)),r=r.then(e=>this.importKey("raw",new Uint8Array(e),s,!1,["verify"])),r=r.then(t=>this.verify(s,t,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify)),e=>Promise.reject(e)),r}getSignatureParameters(e,t="SHA-1"){if(""===this.getOIDByAlgorithm({name:t}))return Promise.reject("Unsupported hash algorithm: "+t);const r=new be,s=this.getAlgorithmParameters(e.algorithm.name,"sign");switch(s.algorithm.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":r.algorithmId=this.getOIDByAlgorithm(s.algorithm);break;case"RSA-PSS":{switch(t.toUpperCase()){case"SHA-256":s.algorithm.saltLength=32;break;case"SHA-384":s.algorithm.saltLength=48;break;case"SHA-512":s.algorithm.saltLength=64}const e={};if("SHA-1"!==t.toUpperCase()){const r=this.getOIDByAlgorithm({name:t});if(""===r)return Promise.reject("Unsupported hash algorithm: "+t);e.hashAlgorithm=new be({algorithmId:r,algorithmParams:new A}),e.maskGenAlgorithm=new be({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==s.algorithm.saltLength&&(e.saltLength=s.algorithm.saltLength);const i=new Ne(e);r.algorithmId="1.2.840.113549.1.1.10",r.algorithmParams=i.toSchema()}break;default:return Promise.reject("Unsupported signature algorithm: "+e.algorithm.name)}return Promise.resolve().then(()=>({signatureAlgorithm:r,parameters:s}))}signWithPrivateKey(e,t,r){return this.sign(r.algorithm,t,new Uint8Array(e)).then(e=>("ECDSA"===r.algorithm.name&&(e=function(e){if(e.byteLength%2!=0)return new ArrayBuffer(0);const t=e.byteLength/2,r=new ArrayBuffer(t);new Uint8Array(r).set(new Uint8Array(e,0,t));const s=new y({valueHex:r}),i=new ArrayBuffer(t);new Uint8Array(i).set(new Uint8Array(e,t,t));const n=new y({valueHex:i});return new a({value:[s.convertToDER(),n.convertToDER()]}).toBER(!1)}(e)),e),e=>Promise.reject("Signing error: "+e))}fillPublicKeyParameters(e,t){const r={},s=this.getHashAlgorithm(t);if(""===s)return Promise.reject("Unsupported signature algorithm: "+t.algorithmId);let i;i="1.2.840.113549.1.1.10"===t.algorithmId?t.algorithmId:e.algorithm.algorithmId;const a=this.getAlgorithmByOID(i);if("name"in a==="")return Promise.reject("Unsupported public key algorithm: "+t.algorithmId);if(r.algorithm=this.getAlgorithmParameters(a.name,"importkey"),"hash"in r.algorithm.algorithm&&(r.algorithm.algorithm.hash.name=s),"ECDSA"===a.name){let t=!1;if("algorithmParams"in e.algorithm==1&&"idBlock"in e.algorithm.algorithmParams&&1===e.algorithm.algorithmParams.idBlock.tagClass&&6===e.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)return Promise.reject("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(e.algorithm.algorithmParams.valueBlock.toString());if("name"in s==0)return Promise.reject("Unsupported named curve algorithm: "+e.algorithm.algorithmParams.valueBlock.toString());r.algorithm.algorithm.namedCurve=s.name}return r}getPublicKey(e,t,r=null){null===r&&(r=this.fillPublicKeyParameters(e,t));const s=e.toSchema().toBER(!1),i=new Uint8Array(s);return this.importKey("spki",i,r.algorithm.algorithm,!0,r.algorithm.usages)}verifyWithPublicKey(e,t,r,s,i=null){let n=Promise.resolve();if(null===i){if(""===(i=this.getHashAlgorithm(s)))return Promise.reject("Unsupported signature algorithm: "+s.algorithmId);n=n.then(()=>this.getPublicKey(r,s))}else{const e={};let t;t="1.2.840.113549.1.1.10"===s.algorithmId?s.algorithmId:r.algorithm.algorithmId;const a=this.getAlgorithmByOID(t);if("name"in a==="")return Promise.reject("Unsupported public key algorithm: "+s.algorithmId);if(e.algorithm=this.getAlgorithmParameters(a.name,"importkey"),"hash"in e.algorithm.algorithm&&(e.algorithm.algorithm.hash.name=i),"ECDSA"===a.name){let t=!1;if("algorithmParams"in r.algorithm==1&&"idBlock"in r.algorithm.algorithmParams&&1===r.algorithm.algorithmParams.idBlock.tagClass&&6===r.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)return Promise.reject("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(r.algorithm.algorithmParams.valueBlock.toString());if("name"in s==0)return Promise.reject("Unsupported named curve algorithm: "+r.algorithm.algorithmParams.valueBlock.toString());e.algorithm.algorithm.namedCurve=s.name}n=n.then(()=>this.getPublicKey(r,null,e))}return n=n.then(r=>{const n=this.getAlgorithmParameters(r.algorithm.name,"verify");"hash"in n.algorithm&&(n.algorithm.hash.name=i);let o=t.valueBlock.valueHex;if("ECDSA"===r.algorithm.name&&(o=function(e){if(e instanceof a==0)return new ArrayBuffer(0);if(2!==e.valueBlock.value.length)return new ArrayBuffer(0);if(e.valueBlock.value[0]instanceof y==0)return new ArrayBuffer(0);if(e.valueBlock.value[1]instanceof y==0)return new ArrayBuffer(0);const t=e.valueBlock.value[0].convertFromDER(),r=e.valueBlock.value[1].convertFromDER();switch(!0){case t.valueBlock.valueHex.byteLength<r.valueBlock.valueHex.byteLength:{if(r.valueBlock.valueHex.byteLength-t.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=r.valueBlock.valueHex.byteLength,s=new Uint8Array(t.valueBlock.valueHex),i=new ArrayBuffer(e),a=new Uint8Array(i);return a.set(s,1),a[0]=0,l(i,r.valueBlock.valueHex)}case t.valueBlock.valueHex.byteLength>r.valueBlock.valueHex.byteLength:{if(t.valueBlock.valueHex.byteLength-r.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=t.valueBlock.valueHex.byteLength,s=new Uint8Array(r.valueBlock.valueHex),i=new ArrayBuffer(e),a=new Uint8Array(i);return a.set(s,1),a[0]=0,l(t.valueBlock.valueHex,i)}default:if(t.valueBlock.valueHex.byteLength%2){const e=t.valueBlock.valueHex.byteLength+1,s=new Uint8Array(t.valueBlock.valueHex),i=new ArrayBuffer(e),a=new Uint8Array(i);a.set(s,1),a[0]=0;const n=new Uint8Array(r.valueBlock.valueHex),o=new ArrayBuffer(e),c=new Uint8Array(o);return c.set(n,1),c[0]=0,l(i,o)}}return l(t.valueBlock.valueHex,r.valueBlock.valueHex)}(g(o).result)),"RSA-PSS"===r.algorithm.name){let e;try{e=new Ne({schema:s.algorithmParams})}catch(c){return Promise.reject(c)}n.algorithm.saltLength="saltLength"in e?e.saltLength:20;let t="SHA-1";if("hashAlgorithm"in e){const r=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId);if("name"in r==0)return Promise.reject("Unrecognized hash algorithm: "+e.hashAlgorithm.algorithmId);t=r.name}n.algorithm.hash.name=t}return this.verify(n.algorithm,r,new Uint8Array(o),new Uint8Array(e))}),n}}let je={name:"none",crypto:null,subtle:null};function Oe(e,t,r){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){if(void 0===global[process.pid])global[process.pid]={};else if("object"!=typeof global[process.pid])throw new Error(`Name global.${process.pid} already exists and it is not an object`);if(void 0===global[process.pid].pkijs)global[process.pid].pkijs={};else if("object"!=typeof global[process.pid].pkijs)throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);global[process.pid].pkijs.engine={name:e,crypto:t,subtle:r}}else je.name!==e&&(je={name:e,crypto:t,subtle:r})}function De(){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){let t;try{t=global[process.pid].pkijs.engine}catch(e){throw new Error('Please call "setEngine" before call to "getEngine"')}return t}return je}function Ke(){const e=De();if(null!==e.subtle)return e.subtle}function Re(e){let t=!1,r="";const s=e.trim();for(let i=0;i<s.length;i++)32===s.charCodeAt(i)?!1===t&&(t=!0):(t&&(r+=" ",t=!1),r+=s[i]);return r.toLowerCase()}!function(){if("undefined"!=typeof self&&"crypto"in self){let t="webcrypto";const r=self.crypto;let s;if("webkitSubtle"in self.crypto){try{s=self.crypto.webkitSubtle}catch(e){s=self.crypto.subtle}t="safari"}"subtle"in self.crypto&&(s=self.crypto.subtle),je=void 0===s?{name:t,crypto:r,subtle:null}:{name:t,crypto:r,subtle:new He({name:t,crypto:self.crypto,subtle:s})}}Oe(je.name,je.crypto,je.subtle)}();class Ve{constructor(e={}){this.type=s(e,"type",Ve.defaultValues("type")),this.value=s(e,"value",Ve.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return"";case"value":return{};default:throw new Error("Invalid member name for AttributeTypeAndValue class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new n({name:t.type||""}),new i({name:t.value||""})]})}static blockName(){return"AttributeTypeAndValue"}fromSchema(e){o(e,["type","typeValue"]);const t=c(e,e,Ve.schema({names:{type:"type",value:"typeValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AttributeTypeAndValue");this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new a({value:[new n({value:this.type}),this.value]})}toJSON(){const e={type:this.type};return e.value=0!==Object.keys(this.value).length?this.value.toJSON():this.value,e}isEqual(e){const t=[I.blockName(),N.blockName(),B.blockName(),x.blockName(),U.blockName(),H.blockName(),j.blockName(),O.blockName(),D.blockName(),K.blockName(),R.blockName(),V.blockName()];if(e.constructor.blockName()===Ve.blockName()){if(this.type!==e.type)return!1;let r=[!1,!1];const s=this.value.constructor.blockName();for(const i of t)s===i&&(r[0]=!0),e.value.constructor.blockName()===i&&(r[1]=!0);if(r[0]^r[1])return!1;if(r=r[0]&&r[1],r){const t=Re(this.value.valueBlock.value),r=Re(e.value.valueBlock.value);if(0!==t.localeCompare(r))return!1}else if(!1===h(this.value.valueBeforeDecode,e.value.valueBeforeDecode))return!1;return!0}return e instanceof ArrayBuffer&&h(this.value.valueBeforeDecode,e)}}class Me{constructor(e={}){this.typesAndValues=s(e,"typesAndValues",Me.defaultValues("typesAndValues")),this.valueBeforeDecode=s(e,"valueBeforeDecode",Me.defaultValues("valueBeforeDecode")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"typesAndValues":return[];case"valueBeforeDecode":return new ArrayBuffer(0);default:throw new Error("Invalid member name for RelativeDistinguishedNames class: "+e)}}static compareWithDefault(e,t){switch(e){case"typesAndValues":return 0===t.length;case"valueBeforeDecode":return 0===t.byteLength;default:throw new Error("Invalid member name for RelativeDistinguishedNames class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new S({name:t.repeatedSequence||"",value:new v({value:[new S({name:t.repeatedSet||"",value:Ve.schema(t.typeAndValue||{})})]})})]})}fromSchema(e){o(e,["RDN","typesAndValues"]);const t=c(e,e,Me.schema({names:{blockName:"RDN",repeatedSet:"typesAndValues"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RelativeDistinguishedNames");"typesAndValues"in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,e=>new Ve({schema:e}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecode}toSchema(){return 0===this.valueBeforeDecode.byteLength?new a({value:[new v({value:Array.from(this.typesAndValues,e=>e.toSchema())})]}):g(this.valueBeforeDecode).result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof Me){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(const[t,r]of this.typesAndValues.entries())if(!1===r.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&h(this.valueBeforeDecode,e)}}class Te{constructor(e={}){this.type=s(e,"type",Te.defaultValues("type")),this.value=s(e,"value",Te.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return 0;case"value":return new Date(0,0,0);default:throw new Error("Invalid member name for Time class: "+e)}}static schema(e={},t=!1){const r=s(e,"names",{});return new P({optional:t,value:[new M({name:r.utcTimeName||""}),new T({name:r.generalTimeName||""})]})}fromSchema(e){o(e,["utcTimeName","generalTimeName"]);const t=c(e,e,Te.schema({names:{utcTimeName:"utcTimeName",generalTimeName:"generalTimeName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Time");"utcTimeName"in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),"generalTimeName"in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){let e={};return 0===this.type&&(e=new M({valueDate:this.value})),1===this.type&&(e=new T({valueDate:this.value})),e}toJSON(){return{type:this.type,value:this.value}}}class Le{constructor(e={}){this.attributes=s(e,"attributes",Le.defaultValues("attributes")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"attributes":return[];default:throw new Error("Invalid member name for SubjectDirectoryAttributes class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new S({name:t.attributes||"",value:Se.schema()})]})}fromSchema(e){o(e,["attributes"]);const t=c(e,e,Le.schema({names:{attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes");this.attributes=Array.from(t.result.attributes,e=>new Se({schema:e}))}toSchema(){return new a({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}}class qe{constructor(e={}){"notBefore"in e&&(this.notBefore=s(e,"notBefore",qe.defaultValues("notBefore"))),"notAfter"in e&&(this.notAfter=s(e,"notAfter",qe.defaultValues("notAfter"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"notBefore":case"notAfter":return new Date;default:throw new Error("Invalid member name for PrivateKeyUsagePeriod class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new E({name:t.notBefore||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new E({name:t.notAfter||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){o(e,["notBefore","notAfter"]);const t=c(e,e,qe.schema({names:{notBefore:"notBefore",notAfter:"notAfter"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod");if("notBefore"in t.result){const e=new T;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if("notAfter"in t.result){const e=new T({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){const e=[];return"notBefore"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:0},valueHex:new T({valueDate:this.notBefore}).valueBlock.valueHex})),"notAfter"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:1},valueHex:new T({valueDate:this.notAfter}).valueBlock.valueHex})),new a({value:e})}toJSON(){const e={};return"notBefore"in this&&(e.notBefore=this.notBefore),"notAfter"in this&&(e.notAfter=this.notAfter),e}}function Fe(e={},t=!1){const r=s(e,"names",{});return new a({optional:t,value:[new C({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:r.country_name||"",value:[new P({value:[new x,new U]})]}),new C({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:r.administration_domain_name||"",value:[new P({value:[new x,new U]})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:r.network_address||"",isHexOnly:!0}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:r.terminal_identifier||"",isHexOnly:!0}),new C({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:r.private_domain_name||"",value:[new P({value:[new x,new U]})]}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:r.organization_name||"",isHexOnly:!0}),new E({optional:!0,name:r.numeric_user_identifier||"",idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new C({optional:!0,name:r.personal_name||"",idBlock:{tagClass:3,tagNumber:5},value:[new E({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new E({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new C({optional:!0,name:r.organizational_unit_names||"",idBlock:{tagClass:3,tagNumber:6},value:[new S({value:new U})]})]})}function Je(e=!1){return new a({optional:e,value:[new U,new U]})}function _e(e=!1){return new v({optional:e,value:[new E({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new C({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new i]})]})}class We{constructor(e={}){this.type=s(e,"type",We.defaultValues("type")),this.value=s(e,"value",We.defaultValues("value")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"type":return 9;case"value":return{};default:throw new Error("Invalid member name for GeneralName class: "+e)}}static compareWithDefault(e,t){switch(e){case"type":return t===We.defaultValues(e);case"value":return 0===Object.keys(t).length;default:throw new Error("Invalid member name for GeneralName class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new P({value:[new C({idBlock:{tagClass:3,tagNumber:0},name:t.blockName||"",value:[new n,new C({idBlock:{tagClass:3,tagNumber:0},value:[new i]})]}),new E({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:1}}),new E({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:2}}),new C({idBlock:{tagClass:3,tagNumber:3},name:t.blockName||"",value:[Fe(t.builtInStandardAttributes||{},!1),Je(!0),_e(!0)]}),new C({idBlock:{tagClass:3,tagNumber:4},name:t.blockName||"",value:[Me.schema(t.directoryName||{})]}),new C({idBlock:{tagClass:3,tagNumber:5},name:t.blockName||"",value:[new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new P({value:[new H,new U,new B,new I,new N]})]}),new C({idBlock:{tagClass:3,tagNumber:1},value:[new P({value:[new H,new U,new B,new I,new N]})]})]}),new E({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:6}}),new E({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:7}}),new E({name:t.blockName||"",idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){o(e,["blockName","otherName","rfc822Name","dNSName","x400Address","directoryName","ediPartyName","uniformResourceIdentifier","iPAddress","registeredID"]);const t=c(e,e,We.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralName");switch(this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:this.value=t.result.blockName;break;case 1:case 2:case 6:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;const r=e.toBER(!1);this.value=g(r).result.valueBlock.value}break;case 3:this.value=t.result.blockName;break;case 4:this.value=new Me({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new k({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;const r=e.toBER(!1);this.value=g(r).result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new C({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{const e=new O({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new C({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{const e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{const e=new n({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return We.schema()}}toJSON(){const e={type:this.type,value:""};if("string"==typeof this.value)e.value=this.value;else try{e.value=this.value.toJSON()}catch(t){}return e}}class Qe{constructor(e={}){this.altNames=s(e,"altNames",Qe.defaultValues("altNames")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"altNames":return[];default:throw new Error("Invalid member name for AltName class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new S({name:t.altNames||"",value:We.schema()})]})}fromSchema(e){o(e,["altNames"]);const t=c(e,e,Qe.schema({names:{altNames:"altNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AltName");"altNames"in t.result&&(this.altNames=Array.from(t.result.altNames,e=>new We({schema:e})))}toSchema(){return new a({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}}class Ge{constructor(e={}){this.cA=s(e,"cA",!1),"pathLenConstraint"in e&&(this.pathLenConstraint=s(e,"pathLenConstraint",0)),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"cA":return!1;default:throw new Error("Invalid member name for BasicConstraints class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new L({optional:!0,name:t.cA||""}),new y({optional:!0,name:t.pathLenConstraint||""})]})}fromSchema(e){o(e,["cA","pathLenConstraint"]);const t=c(e,e,Ge.schema({names:{cA:"cA",pathLenConstraint:"pathLenConstraint"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for BasicConstraints");"cA"in t.result&&(this.cA=t.result.cA.valueBlock.value),"pathLenConstraint"in t.result&&(this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.isHexOnly?t.result.pathLenConstraint:t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){const e=[];return this.cA!==Ge.defaultValues("cA")&&e.push(new L({value:this.cA})),"pathLenConstraint"in this&&e.push(this.pathLenConstraint instanceof y?this.pathLenConstraint:new y({value:this.pathLenConstraint})),new a({value:e})}toJSON(){const e={};return this.cA!==Ge.defaultValues("cA")&&(e.cA=this.cA),"pathLenConstraint"in this&&(e.pathLenConstraint=this.pathLenConstraint instanceof y?this.pathLenConstraint.toJSON():this.pathLenConstraint),e}}class ze{constructor(e={}){"distributionPoint"in e&&(this.distributionPoint=s(e,"distributionPoint",ze.defaultValues("distributionPoint"))),this.onlyContainsUserCerts=s(e,"onlyContainsUserCerts",ze.defaultValues("onlyContainsUserCerts")),this.onlyContainsCACerts=s(e,"onlyContainsCACerts",ze.defaultValues("onlyContainsCACerts")),"onlySomeReasons"in e&&(this.onlySomeReasons=s(e,"onlySomeReasons",ze.defaultValues("onlySomeReasons"))),this.indirectCRL=s(e,"indirectCRL",ze.defaultValues("indirectCRL")),this.onlyContainsAttributeCerts=s(e,"onlyContainsAttributeCerts",ze.defaultValues("onlyContainsAttributeCerts")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"onlyContainsUserCerts":case"onlyContainsCACerts":return!1;case"onlySomeReasons":return 0;case"indirectCRL":case"onlyContainsAttributeCerts":return!1;default:throw new Error("Invalid member name for IssuingDistributionPoint class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new P({value:[new C({name:t.distributionPoint||"",idBlock:{tagClass:3,tagNumber:0},value:[new S({name:t.distributionPointNames||"",value:We.schema()})]}),new C({name:t.distributionPoint||"",idBlock:{tagClass:3,tagNumber:1},value:Me.schema().valueBlock.value})]})]}),new E({name:t.onlyContainsUserCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new E({name:t.onlyContainsCACerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new E({name:t.onlySomeReasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new E({name:t.indirectCRL||"",optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new E({name:t.onlyContainsAttributeCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){o(e,["distributionPoint","distributionPointNames","onlyContainsUserCerts","onlyContainsCACerts","onlySomeReasons","indirectCRL","onlyContainsAttributeCerts"]);const t=c(e,e,ze.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",onlyContainsUserCerts:"onlyContainsUserCerts",onlyContainsCACerts:"onlyContainsCACerts",onlySomeReasons:"onlySomeReasons",indirectCRL:"indirectCRL",onlyContainsAttributeCerts:"onlyContainsAttributeCerts"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint");if("distributionPoint"in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new We({schema:e}));break;case 1===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=new Me({schema:new a({value:t.result.distributionPoint.valueBlock.value})});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if("onlyContainsUserCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if("onlyContainsCACerts"in t.result){const e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if("onlySomeReasons"in t.result){const e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if("indirectCRL"in t.result){const e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if("onlyContainsAttributeCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){const e=[];if("distributionPoint"in this){let t;this.distributionPoint instanceof Array?t=new C({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):(t=this.distributionPoint.toSchema(),t.idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(new C({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(this.onlyContainsUserCerts!==ze.defaultValues("onlyContainsUserCerts")&&e.push(new E({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==ze.defaultValues("onlyContainsCACerts")&&e.push(new E({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),"onlySomeReasons"in this){const t=new ArrayBuffer(1);new Uint8Array(t)[0]=this.onlySomeReasons,e.push(new E({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==ze.defaultValues("indirectCRL")&&e.push(new E({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==ze.defaultValues("onlyContainsAttributeCerts")&&e.push(new E({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new a({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(e.distributionPoint=this.distributionPoint instanceof Array?Array.from(this.distributionPoint,e=>e.toJSON()):this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==ze.defaultValues("onlyContainsUserCerts")&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==ze.defaultValues("onlyContainsCACerts")&&(e.onlyContainsCACerts=this.onlyContainsCACerts),"onlySomeReasons"in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==ze.defaultValues("indirectCRL")&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==ze.defaultValues("onlyContainsAttributeCerts")&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}class $e{constructor(e={}){this.names=s(e,"names",$e.defaultValues("names")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"names":return[];default:throw new Error("Invalid member name for GeneralNames class: "+e)}}static schema(e={},t=!1){const r=s(e,"names",{});return new a({optional:t,name:r.blockName||"",value:[new S({name:r.generalNames||"",value:We.schema()})]})}fromSchema(e){o(e,["names","generalNames"]);const t=c(e,e,$e.schema({names:{blockName:"names",generalNames:"generalNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralNames");this.names=Array.from(t.result.generalNames,e=>new We({schema:e}))}toSchema(){return new a({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}}class Ze{constructor(e={}){this.base=s(e,"base",Ze.defaultValues("base")),this.minimum=s(e,"minimum",Ze.defaultValues("minimum")),"maximum"in e&&(this.maximum=s(e,"maximum",Ze.defaultValues("maximum"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"base":return new We;case"minimum":case"maximum":return 0;default:throw new Error("Invalid member name for GeneralSubtree class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[We.schema(t.base||{}),new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new y({name:t.minimum||""})]}),new C({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new y({name:t.maximum||""})]})]})}fromSchema(e){o(e,["base","minimum","maximum"]);const t=c(e,e,Ze.schema({names:{base:{names:{blockName:"base"}},minimum:"minimum",maximum:"maximum"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralSubtree");this.base=new We({schema:t.result.base}),"minimum"in t.result&&(this.minimum=t.result.minimum.valueBlock.isHexOnly?t.result.minimum:t.result.minimum.valueBlock.valueDec),"maximum"in t.result&&(this.maximum=t.result.maximum.valueBlock.isHexOnly?t.result.maximum:t.result.maximum.valueBlock.valueDec)}toSchema(){const e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof y?this.minimum:new y({value:this.minimum}),e.push(new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if("maximum"in this){let t=0;t=this.maximum instanceof y?this.maximum:new y({value:this.maximum}),e.push(new C({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new a({value:e})}toJSON(){const e={base:this.base.toJSON()};return 0!==this.minimum&&(e.minimum="number"==typeof this.minimum?this.minimum:this.minimum.toJSON()),"maximum"in this&&(e.maximum="number"==typeof this.maximum?this.maximum:this.maximum.toJSON()),e}}class Xe{constructor(e={}){"permittedSubtrees"in e&&(this.permittedSubtrees=s(e,"permittedSubtrees",Xe.defaultValues("permittedSubtrees"))),"excludedSubtrees"in e&&(this.excludedSubtrees=s(e,"excludedSubtrees",Xe.defaultValues("excludedSubtrees"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"permittedSubtrees":case"excludedSubtrees":return[];default:throw new Error("Invalid member name for NameConstraints class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new S({name:t.permittedSubtrees||"",value:Ze.schema()})]}),new C({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new S({name:t.excludedSubtrees||"",value:Ze.schema()})]})]})}fromSchema(e){o(e,["permittedSubtrees","excludedSubtrees"]);const t=c(e,e,Xe.schema({names:{permittedSubtrees:"permittedSubtrees",excludedSubtrees:"excludedSubtrees"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for NameConstraints");"permittedSubtrees"in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,e=>new Ze({schema:e}))),"excludedSubtrees"in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,e=>new Ze({schema:e})))}toSchema(){const e=[];return"permittedSubtrees"in this&&e.push(new C({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.permittedSubtrees,e=>e.toSchema())})),"excludedSubtrees"in this&&e.push(new C({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.excludedSubtrees,e=>e.toSchema())})),new a({value:e})}toJSON(){const e={};return"permittedSubtrees"in this&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,e=>e.toJSON())),"excludedSubtrees"in this&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,e=>e.toJSON())),e}}class Ye{constructor(e={}){"distributionPoint"in e&&(this.distributionPoint=s(e,"distributionPoint",Ye.defaultValues("distributionPoint"))),"reasons"in e&&(this.reasons=s(e,"reasons",Ye.defaultValues("reasons"))),"cRLIssuer"in e&&(this.cRLIssuer=s(e,"cRLIssuer",Ye.defaultValues("cRLIssuer"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"reasons":return new b;case"cRLIssuer":return[];default:throw new Error("Invalid member name for DistributionPoint class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new P({value:[new C({name:t.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new S({name:t.distributionPointNames||"",value:We.schema()})]}),new C({name:t.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Me.schema().valueBlock.value})]})]}),new E({name:t.reasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new C({name:t.cRLIssuer||"",optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new S({name:t.cRLIssuerNames||"",value:We.schema()})]})]})}fromSchema(e){o(e,["distributionPoint","distributionPointNames","reasons","cRLIssuer","cRLIssuerNames"]);const t=c(e,e,Ye.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",reasons:"reasons",cRLIssuer:"cRLIssuer",cRLIssuerNames:"cRLIssuerNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for DistributionPoint");"distributionPoint"in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new We({schema:e}))),1===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=new Me({schema:new a({value:t.result.distributionPoint.valueBlock.value})}))),"reasons"in t.result&&(this.reasons=new b({valueHex:t.result.reasons.valueBlock.valueHex})),"cRLIssuer"in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,e=>new We({schema:e})))}toSchema(){const e=[];if("distributionPoint"in this){let t;t=new C(this.distributionPoint instanceof Array?{idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}:{idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new C({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return"reasons"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHex})),"cRLIssuer"in this&&e.push(new C({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,e=>e.toSchema())})),new a({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(e.distributionPoint=this.distributionPoint instanceof Array?Array.from(this.distributionPoint,e=>e.toJSON()):this.distributionPoint.toJSON()),"reasons"in this&&(e.reasons=this.reasons.toJSON()),"cRLIssuer"in this&&(e.cRLIssuer=Array.from(this.cRLIssuer,e=>e.toJSON())),e}}class et{constructor(e={}){this.distributionPoints=s(e,"distributionPoints",et.defaultValues("distributionPoints")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"distributionPoints":return[];default:throw new Error("Invalid member name for CRLDistributionPoints class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new S({name:t.distributionPoints||"",value:Ye.schema()})]})}fromSchema(e){o(e,["distributionPoints"]);const t=c(e,e,et.schema({names:{distributionPoints:"distributionPoints"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CRLDistributionPoints");this.distributionPoints=Array.from(t.result.distributionPoints,e=>new Ye({schema:e}))}toSchema(){return new a({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}}class tt{constructor(e={}){this.policyQualifierId=s(e,"policyQualifierId",tt.defaultValues("policyQualifierId")),this.qualifier=s(e,"qualifier",tt.defaultValues("qualifier")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"policyQualifierId":return"";case"qualifier":return new i;default:throw new Error("Invalid member name for PolicyQualifierInfo class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new n({name:t.policyQualifierId||""}),new i({name:t.qualifier||""})]})}fromSchema(e){o(e,["policyQualifierId","qualifier"]);const t=c(e,e,tt.schema({names:{policyQualifierId:"policyQualifierId",qualifier:"qualifier"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo");this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new a({value:[new n({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}class rt{constructor(e={}){this.policyIdentifier=s(e,"policyIdentifier",rt.defaultValues("policyIdentifier")),"policyQualifiers"in e&&(this.policyQualifiers=s(e,"policyQualifiers",rt.defaultValues("policyQualifiers"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"policyIdentifier":return"";case"policyQualifiers":return[];default:throw new Error("Invalid member name for PolicyInformation class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new n({name:t.policyIdentifier||""}),new a({optional:!0,value:[new S({name:t.policyQualifiers||"",value:tt.schema()})]})]})}fromSchema(e){o(e,["policyIdentifier","policyQualifiers"]);const t=c(e,e,rt.schema({names:{policyIdentifier:"policyIdentifier",policyQualifiers:"policyQualifiers"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyInformation");this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),"policyQualifiers"in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,e=>new tt({schema:e})))}toSchema(){const e=[];return e.push(new n({value:this.policyIdentifier})),"policyQualifiers"in this&&e.push(new a({value:Array.from(this.policyQualifiers,e=>e.toSchema())})),new a({value:e})}toJSON(){const e={policyIdentifier:this.policyIdentifier};return"policyQualifiers"in this&&(e.policyQualifiers=Array.from(this.policyQualifiers,e=>e.toJSON())),e}}class st{constructor(e={}){this.certificatePolicies=s(e,"certificatePolicies",st.defaultValues("certificatePolicies")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certificatePolicies":return[];default:throw new Error("Invalid member name for CertificatePolicies class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new S({name:t.certificatePolicies||"",value:rt.schema()})]})}fromSchema(e){o(e,["certificatePolicies"]);const t=c(e,e,st.schema({names:{certificatePolicies:"certificatePolicies"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificatePolicies");this.certificatePolicies=Array.from(t.result.certificatePolicies,e=>new rt({schema:e}))}toSchema(){return new a({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}}class it{constructor(e={}){this.issuerDomainPolicy=s(e,"issuerDomainPolicy",it.defaultValues("issuerDomainPolicy")),this.subjectDomainPolicy=s(e,"subjectDomainPolicy",it.defaultValues("subjectDomainPolicy")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"issuerDomainPolicy":case"subjectDomainPolicy":return"";default:throw new Error("Invalid member name for PolicyMapping class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new n({name:t.issuerDomainPolicy||""}),new n({name:t.subjectDomainPolicy||""})]})}fromSchema(e){o(e,["issuerDomainPolicy","subjectDomainPolicy"]);const t=c(e,e,it.schema({names:{issuerDomainPolicy:"issuerDomainPolicy",subjectDomainPolicy:"subjectDomainPolicy"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMapping");this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new a({value:[new n({value:this.issuerDomainPolicy}),new n({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}class at{constructor(e={}){this.mappings=s(e,"mappings",at.defaultValues("mappings")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"mappings":return[];default:throw new Error("Invalid member name for PolicyMappings class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new S({name:t.mappings||"",value:it.schema()})]})}fromSchema(e){o(e,["mappings"]);const t=c(e,e,at.schema({names:{mappings:"mappings"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMappings");this.mappings=Array.from(t.result.mappings,e=>new it({schema:e}))}toSchema(){return new a({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}}class nt{constructor(e={}){"keyIdentifier"in e&&(this.keyIdentifier=s(e,"keyIdentifier",nt.defaultValues("keyIdentifier"))),"authorityCertIssuer"in e&&(this.authorityCertIssuer=s(e,"authorityCertIssuer",nt.defaultValues("authorityCertIssuer"))),"authorityCertSerialNumber"in e&&(this.authorityCertSerialNumber=s(e,"authorityCertSerialNumber",nt.defaultValues("authorityCertSerialNumber"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyIdentifier":return new k;case"authorityCertIssuer":return[];case"authorityCertSerialNumber":return new y;default:throw new Error("Invalid member name for AuthorityKeyIdentifier class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new E({name:t.keyIdentifier||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new C({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new S({name:t.authorityCertIssuer||"",value:We.schema()})]}),new E({name:t.authorityCertSerialNumber||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){o(e,["keyIdentifier","authorityCertIssuer","authorityCertSerialNumber"]);const t=c(e,e,nt.schema({names:{keyIdentifier:"keyIdentifier",authorityCertIssuer:"authorityCertIssuer",authorityCertSerialNumber:"authorityCertSerialNumber"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier");"keyIdentifier"in t.result&&(this.keyIdentifier=new k({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,e=>new We({schema:e}))),"authorityCertSerialNumber"in t.result&&(this.authorityCertSerialNumber=new y({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){const e=[];return"keyIdentifier"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:0},valueHex:this.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in this&&e.push(new C({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,e=>e.toSchema())})),"authorityCertSerialNumber"in this&&e.push(new E({idBlock:{tagClass:3,tagNumber:2},valueHex:this.authorityCertSerialNumber.valueBlock.valueHex})),new a({value:e})}toJSON(){const e={};return"keyIdentifier"in this&&(e.keyIdentifier=this.keyIdentifier.toJSON()),"authorityCertIssuer"in this&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,e=>e.toJSON())),"authorityCertSerialNumber"in this&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}class ot{constructor(e={}){"requireExplicitPolicy"in e&&(this.requireExplicitPolicy=s(e,"requireExplicitPolicy",ot.defaultValues("requireExplicitPolicy"))),"inhibitPolicyMapping"in e&&(this.inhibitPolicyMapping=s(e,"inhibitPolicyMapping",ot.defaultValues("inhibitPolicyMapping"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"requireExplicitPolicy":case"inhibitPolicyMapping":return 0;default:throw new Error("Invalid member name for PolicyConstraints class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new E({name:t.requireExplicitPolicy||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new E({name:t.inhibitPolicyMapping||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){o(e,["requireExplicitPolicy","inhibitPolicyMapping"]);const t=c(e,e,ot.schema({names:{requireExplicitPolicy:"requireExplicitPolicy",inhibitPolicyMapping:"inhibitPolicyMapping"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyConstraints");if("requireExplicitPolicy"in t.result){const e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=e.toBER(!1),s=g(r);this.requireExplicitPolicy=s.result.valueBlock.valueDec}if("inhibitPolicyMapping"in t.result){const e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const r=e.toBER(!1),s=g(r);this.inhibitPolicyMapping=s.result.valueBlock.valueDec}}toSchema(){const e=[];if("requireExplicitPolicy"in this){const t=new y({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if("inhibitPolicyMapping"in this){const t=new y({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new a({value:e})}toJSON(){const e={};return"requireExplicitPolicy"in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),"inhibitPolicyMapping"in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}class ct{constructor(e={}){this.keyPurposes=s(e,"keyPurposes",ct.defaultValues("keyPurposes")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"keyPurposes":return[];default:throw new Error("Invalid member name for ExtKeyUsage class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new S({name:t.keyPurposes||"",value:new n})]})}fromSchema(e){o(e,["keyPurposes"]);const t=c(e,e,ct.schema({names:{keyPurposes:"keyPurposes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ExtKeyUsage");this.keyPurposes=Array.from(t.result.keyPurposes,e=>e.valueBlock.toString())}toSchema(){return new a({value:Array.from(this.keyPurposes,e=>new n({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}class ht{constructor(e={}){this.accessMethod=s(e,"accessMethod",ht.defaultValues("accessMethod")),this.accessLocation=s(e,"accessLocation",ht.defaultValues("accessLocation")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"accessMethod":return"";case"accessLocation":return new We;default:throw new Error("Invalid member name for AccessDescription class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new n({name:t.accessMethod||""}),We.schema(t.accessLocation||{})]})}fromSchema(e){o(e,["accessMethod","accessLocation"]);const t=c(e,e,ht.schema({names:{accessMethod:"accessMethod",accessLocation:{names:{blockName:"accessLocation"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AccessDescription");this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new We({schema:t.result.accessLocation})}toSchema(){return new a({value:[new n({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}class ut{constructor(e={}){this.accessDescriptions=s(e,"accessDescriptions",ut.defaultValues("accessDescriptions")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"accessDescriptions":return[];default:throw new Error("Invalid member name for InfoAccess class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new S({name:t.accessDescriptions||"",value:ht.schema()})]})}fromSchema(e){o(e,["accessDescriptions"]);const t=c(e,e,ut.schema({names:{accessDescriptions:"accessDescriptions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for InfoAccess");this.accessDescriptions=Array.from(t.result.accessDescriptions,e=>new ht({schema:e}))}toSchema(){return new a({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}}class lt{constructor(e={}){this.clear();for(const t of Object.keys(e))switch(t){case"length":this.length=e.length;break;case"stub":for(let t=0;t<this._view.length;t++)this._view[t]=e.stub;break;case"view":this.fromUint8Array(e.view);break;case"buffer":this.fromArrayBuffer(e.buffer);break;case"string":this.fromString(e.string);break;case"hexstring":this.fromHexString(e.hexstring)}}set buffer(e){this._buffer=e.slice(0),this._view=new Uint8Array(this._buffer)}get buffer(){return this._buffer}set view(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}get view(){return this._view}get length(){return this._buffer.byteLength}set length(e){this._buffer=new ArrayBuffer(e),this._view=new Uint8Array(this._buffer)}clear(){this._buffer=new ArrayBuffer(0),this._view=new Uint8Array(this._buffer)}fromArrayBuffer(e){this.buffer=e}fromUint8Array(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}fromString(e){const t=e.length;this.length=t;for(let r=0;r<t;r++)this.view[r]=e.charCodeAt(r)}toString(e=0,t=this.view.length-e){let r="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let s=e;s<e+t;s++)r+=String.fromCharCode(this.view[s]);return r}fromHexString(e){const t=e.length;this.buffer=new ArrayBuffer(t>>1),this.view=new Uint8Array(this.buffer);const r=new Map;r.set("0",0),r.set("1",1),r.set("2",2),r.set("3",3),r.set("4",4),r.set("5",5),r.set("6",6),r.set("7",7),r.set("8",8),r.set("9",9),r.set("A",10),r.set("a",10),r.set("B",11),r.set("b",11),r.set("C",12),r.set("c",12),r.set("D",13),r.set("d",13),r.set("E",14),r.set("e",14),r.set("F",15),r.set("f",15);let s=0,i=0;for(let a=0;a<t;a++)a%2?(i|=r.get(e.charAt(a)),this.view[s]=i,s++):i=r.get(e.charAt(a))<<4}toHexString(e=0,t=this.view.length-e){let r="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let s=e;s<e+t;s++){const e=this.view[s].toString(16).toUpperCase();r=r+(1==e.length?"0":"")+e}return r}copy(e=0,t=this._buffer.byteLength-e){if(0===e&&0===this._buffer.byteLength)return new lt;if(e<0||e>this._buffer.byteLength-1)throw new Error("Wrong start position: "+e);const r=new lt;return r._buffer=this._buffer.slice(e,e+t),r._view=new Uint8Array(r._buffer),r}slice(e=0,t=this._buffer.byteLength){if(0===e&&0===this._buffer.byteLength)return new lt;if(e<0||e>this._buffer.byteLength-1)throw new Error("Wrong start position: "+e);const r=new lt;return r._buffer=this._buffer.slice(e,t),r._view=new Uint8Array(r._buffer),r}realloc(e){const t=new ArrayBuffer(e);new Uint8Array(t).set(e>this._view.length?this._view:new Uint8Array(this._buffer,0,e)),this._buffer=t.slice(0),this._view=new Uint8Array(this._buffer)}append(e){const t=this._buffer.byteLength,r=e._buffer.byteLength,s=e._view.slice();this.realloc(t+r),this._view.set(s,t)}insert(e,t=0,r=this._buffer.byteLength-t){return!(t>this._buffer.byteLength-1||(r>this._buffer.byteLength-t&&(r=this._buffer.byteLength-t),r>e._buffer.byteLength&&(r=e._buffer.byteLength),this._view.set(r==e._buffer.byteLength?e._view:e._view.slice(0,r),t),0))}isEqual(e){if(this._buffer.byteLength!=e._buffer.byteLength)return!1;for(let t=0;t<e._buffer.byteLength;t++)if(this.view[t]!=e.view[t])return!1;return!0}isEqualView(e){if(e.length!=this.view.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e[t])return!1;return!0}findPattern(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));const i=e.buffer.byteLength;if(i>r)return-1;const a=[];for(let n=0;n<i;n++)a.push(e.view[n]);for(let n=0;n<=r-i;n++){let e=!0;const r=s?t-i-n:t+n;for(let t=0;t<i;t++)if(this.view[t+r]!=a[t]){e=!1;break}if(e)return s?t-i-n:t+i+n}return-1}findFirstIn(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));const i={id:-1,position:s?0:t+r,length:0};for(let a=0;a<e.length;a++){const n=this.findPattern(e[a],t,r,s);if(-1!=n){let t=!1;const r=e[a].length;s?n-r>=i.position-i.length&&(t=!0):n-r<=i.position-i.length&&(t=!0),t&&(i.position=n,i.id=a,i.length=r)}}return i}findAllIn(e,t=0,r=this.buffer.byteLength-t){const s=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return s;null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t);let i={id:-1,position:t};for(;;){const t=i.position;if(i=this.findFirstIn(e,i.position,r),-1==i.id)break;r-=i.position-t,s.push({id:i.id,position:i.position})}return s}findAllPatternIn(e,t=0,r=this.buffer.byteLength-t){null==t&&(t=0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t);const s=[],i=e.buffer.byteLength;if(i>r)return-1;const a=Array.from(e.view);for(let n=0;n<=r-i;n++){let e=!0;const r=t+n;for(let t=0;t<i;t++)if(this.view[t+r]!=a[t]){e=!1;break}e&&(s.push(t+i+n),n+=i-1)}return s}findFirstNotIn(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));const i={left:{id:-1,position:t},right:{id:-1,position:0},value:new lt};let a=r;for(;a>0;){if(i.right=this.findFirstIn(e,s?t-r+a:t+r-a,a,s),-1==i.right.id){r=a,s?t-=r:t=i.left.position,i.value=new lt,i.value._buffer=this._buffer.slice(t,t+r),i.value._view=new Uint8Array(i.value._buffer);break}if(i.right.position!=(s?i.left.position-e[i.right.id].buffer.byteLength:i.left.position+e[i.right.id].buffer.byteLength)){s?(t=i.right.position+e[i.right.id].buffer.byteLength,r=i.left.position-i.right.position-e[i.right.id].buffer.byteLength):(t=i.left.position,r=i.right.position-i.left.position-e[i.right.id].buffer.byteLength),i.value=new lt,i.value._buffer=this._buffer.slice(t,t+r),i.value._view=new Uint8Array(i.value._buffer);break}i.left=i.right,a-=e[i.right.id]._buffer.byteLength}if(s){const e=i.right;i.right=i.left,i.left=e}return i}findAllNotIn(e,t=null,r=null){const s=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return s;null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t);let i={left:{id:-1,position:t},right:{id:-1,position:t},value:new lt};do{const t=i.right.position;i=this.findFirstNotIn(e,i.right.position,r),r-=i.right.position-t,s.push({left:{id:i.left.id,position:i.left.position},right:{id:i.right.id,position:i.right.position},value:i.value})}while(-1!=i.right.id);return s}findFirstSequence(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));const i=this.skipNotPatterns(e,t,r,s);if(-1==i)return{position:-1,value:new lt};const a=this.skipPatterns(e,i,r-(s?t-i:i-t),s);s?(t=a,r=i-a):(t=i,r=a-i);const n=new lt;return n._buffer=this._buffer.slice(t,t+r),n._view=new Uint8Array(n._buffer),{position:a,value:n}}findAllSequences(e,t=null,r=null){const s=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return s;null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t);let i={position:t,value:new lt};do{const t=i.position;i=this.findFirstSequence(e,i.position,r),-1!=i.position&&(r-=i.position-t,s.push({position:i.position,value:i.value}))}while(-1!=i.position);return s}findPairedPatterns(e,t,r=null,s=null){const i=[];if(e.isEqual(t))return i;if(null==r&&(r=0),r>this.buffer.byteLength-1)return i;null==s&&(s=this.buffer.byteLength-r),s>this.buffer.byteLength-r&&(s=this.buffer.byteLength-r);let a=0;const n=this.findAllPatternIn(e,r,s);if(0==n.length)return i;const o=this.findAllPatternIn(t,r,s);if(0==o.length)return i;for(;a<n.length&&0!=o.length;)if(n[0]!=o[0]){if(n[a]>o[0])break;for(;n[a]<o[0]&&(a++,!(a>=n.length)););i.push({left:n[a-1],right:o[0]}),n.splice(a-1,1),o.splice(0,1),a=0}else i.push({left:n[0],right:o[0]}),n.splice(0,1),o.splice(0,1);return i.sort((e,t)=>e.left-t.left),i}findPairedArrays(e,t,r=null,s=null){const i=[];if(null==r&&(r=0),r>this.buffer.byteLength-1)return i;null==s&&(s=this.buffer.byteLength-r),s>this.buffer.byteLength-r&&(s=this.buffer.byteLength-r);let a=0;const n=this.findAllIn(e,r,s);if(0==n.length)return i;const o=this.findAllIn(t,r,s);if(0==o.length)return i;for(;a<n.length&&0!=o.length;)if(n[0].position!=o[0].position){if(n[a].position>o[0].position)break;for(;n[a].position<o[0].position&&(a++,!(a>=n.length)););i.push({left:n[a-1],right:o[0]}),n.splice(a-1,1),o.splice(0,1),a=0}else i.push({left:n[0],right:o[0]}),n.splice(0,1),o.splice(0,1);return i.sort((e,t)=>e.left.position-t.left.position),i}replacePattern(e,t,r=null,s=null,i=null){let a,n;const o={status:-1,searchPatternPositions:[],replacePatternPositions:[]};if(null==r&&(r=0),r>this.buffer.byteLength-1)return!1;if(null==s&&(s=this.buffer.byteLength-r),s>this.buffer.byteLength-r&&(s=this.buffer.byteLength-r),null==i){if(a=this.findAllIn([e],r,s),0==a.length)return o}else a=i;o.searchPatternPositions.push(...Array.from(a,e=>e.position));const c=e.buffer.byteLength-t.buffer.byteLength,h=new ArrayBuffer(this.view.length-a.length*c),u=new Uint8Array(h);for(u.set(new Uint8Array(this.buffer,0,r)),n=0;n<a.length;n++){const s=0==n?r:a[n-1].position;u.set(new Uint8Array(this.buffer,s,a[n].position-e.buffer.byteLength-s),s-n*c),u.set(t.view,a[n].position-e.buffer.byteLength-n*c),o.replacePatternPositions.push(a[n].position-e.buffer.byteLength-n*c)}return n--,u.set(new Uint8Array(this.buffer,a[n].position,this.buffer.byteLength-a[n].position),a[n].position-e.buffer.byteLength+t.buffer.byteLength-n*c),this.buffer=h,this.view=new Uint8Array(this.buffer),o.status=1,o}skipPatterns(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));let i=t;for(let a=0;a<e.length;a++){const n=e[a].buffer.byteLength,o=s?i-n:i;let c=!0;for(let t=0;t<n;t++)if(this.view[t+o]!=e[a].view[t]){c=!1;break}if(c)if(a=-1,s){if(i-=n,i<=0)return i}else if(i+=n,i>=t+r)return i}return i}skipNotPatterns(e,t=null,r=null,s=!1){null==t&&(t=s?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),s?(null==r&&(r=t),r>t&&(r=t)):(null==r&&(r=this.buffer.byteLength-t),r>this.buffer.byteLength-t&&(r=this.buffer.byteLength-t));let i=-1;for(let a=0;a<r;a++){for(let r=0;r<e.length;r++){const n=e[r].buffer.byteLength,o=s?t-a-n:t+a;let c=!0;for(let t=0;t<n;t++)if(this.view[t+o]!=e[r].view[t]){c=!1;break}if(c){i=s?t-a:t+a;break}}if(-1!=i)break}return i}}class mt{constructor(e={}){this.stream=new lt,this._length=0,this.backward=!1,this._start=0,this.appendBlock=0,this.prevLength=0,this.prevStart=0;for(const t of Object.keys(e))switch(t){case"stream":this.stream=e.stream;break;case"backward":this.backward=e.backward,this._start=this.stream.buffer.byteLength;break;case"length":this._length=e.length;break;case"start":this._start=e.start;break;case"appendBlock":this.appendBlock=e.appendBlock;break;case"view":this.stream=new lt({view:e.view});break;case"buffer":this.stream=new lt({buffer:e.buffer});break;case"string":this.stream=new lt({string:e.string});break;case"hexstring":this.stream=new lt({hexstring:e.hexstring})}}set stream(e){this._stream=e,this.prevLength=this._length,this._length=e._buffer.byteLength,this.prevStart=this._start,this._start=0}get stream(){return this._stream}set length(e){this.prevLength=this._length,this._length=e}get length(){return this.appendBlock?this.start:this._length}set start(e){e>this.stream.buffer.byteLength||(this.prevStart=this._start,this.prevLength=this._length,this._length-=this.backward?this._start-e:e-this._start,this._start=e)}get start(){return this._start}get buffer(){return this._stream._buffer.slice(0,this._length)}resetPosition(){this._start=this.prevStart,this._length=this.prevLength}findPattern(e,t=null){(null==t||t>this.length)&&(t=this.length);const r=this.stream.findPattern(e,this.start,this.length,this.backward);if(-1==r)return r;if(this.backward){if(r<this.start-e.buffer.byteLength-t)return-1}else if(r>this.start+e.buffer.byteLength+t)return-1;return this.start=r,r}findFirstIn(e,t=null){(null==t||t>this.length)&&(t=this.length);const r=this.stream.findFirstIn(e,this.start,this.length,this.backward);if(-1==r.id)return r;if(this.backward){if(r.position<this.start-e[r.id].buffer.byteLength-t)return{id:-1,position:this.backward?0:this.start+this.length}}else if(r.position>this.start+e[r.id].buffer.byteLength+t)return{id:-1,position:this.backward?0:this.start+this.length};return this.start=r.position,r}findAllIn(e){return this.stream.findAllIn(e,this.backward?this.start-this.length:this.start,this.length)}findFirstNotIn(e,t=null){(null==t||t>this._length)&&(t=this._length);const r=this._stream.findFirstNotIn(e,this._start,this._length,this.backward);if(-1==r.left.id&&-1==r.right.id)return r;if(this.backward){if(-1!=r.right.id&&r.right.position<this._start-e[r.right.id]._buffer.byteLength-t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new lt}}else if(-1!=r.left.id&&r.left.position>this._start+e[r.left.id]._buffer.byteLength+t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new lt};return this.start=this.backward?-1==r.left.id?0:r.left.position:-1==r.right.id?this._start+this._length:r.right.position,r}findAllNotIn(e){return this._stream.findAllNotIn(e,this.backward?this._start-this._length:this._start,this._length)}findFirstSequence(e,t=null,r=null){(null==t||t>this._length)&&(t=this._length),(null==r||r>t)&&(r=t);const s=this._stream.findFirstSequence(e,this._start,t,this.backward);if(0==s.value.buffer.byteLength)return s;if(this.backward){if(s.position<this._start-s.value._buffer.byteLength-r)return{position:-1,value:new lt}}else if(s.position>this._start+s.value._buffer.byteLength+r)return{position:-1,value:new lt};return this.start=s.position,s}findAllSequences(e){return this.stream.findAllSequences(e,this.backward?this.start-this.length:this.start,this.length)}findPairedPatterns(e,t,r=null){(null==r||r>this.length)&&(r=this.length);const s=this.stream.findPairedPatterns(e,t,this.backward?this.start-this.length:this.start,this.length);if(s.length)if(this.backward){if(s[0].right<this.start-t.buffer.byteLength-r)return[]}else if(s[0].left>this.start+e.buffer.byteLength+r)return[];return s}findPairedArrays(e,t,r=null){(null==r||r>this.length)&&(r=this.length);const s=this.stream.findPairedArrays(e,t,this.backward?this.start-this.length:this.start,this.length);if(s.length)if(this.backward){if(s[0].right.position<this.start-t[s[0].right.id].buffer.byteLength-r)return[]}else if(s[0].left.position>this.start+e[s[0].left.id].buffer.byteLength+r)return[];return s}replacePattern(e,t){return this.stream.replacePattern(e,t,this.backward?this.start-this.length:this.start,this.length)}skipPatterns(e){const t=this.stream.skipPatterns(e,this.start,this.length,this.backward);return this.start=t,t}skipNotPatterns(e){const t=this.stream.skipNotPatterns(e,this.start,this.length,this.backward);return-1==t?-1:(this.start=t,t)}append(e){this._start+e._buffer.byteLength>this._stream._buffer.byteLength&&(e._buffer.byteLength>this.appendBlock&&(this.appendBlock=e._buffer.byteLength+1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view.set(e._view,this._start),this._length+=2*e._buffer.byteLength,this.start=this._start+e._buffer.byteLength,this.prevLength-=2*e._buffer.byteLength}appendView(e){this._start+e.length>this._stream._buffer.byteLength&&(e.length>this.appendBlock&&(this.appendBlock=e.length+1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view.set(e,this._start),this._length+=2*e.length,this.start=this._start+e.length,this.prevLength-=2*e.length}appendChar(e){this._start+1>this._stream._buffer.byteLength&&(1>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view[this._start]=e,this._length+=2,this.start=this._start+1,this.prevLength-=2}appendUint16(e){this._start+2>this._stream._buffer.byteLength&&(2>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint16Array([e]),r=new Uint8Array(t.buffer);this._stream._view[this._start]=r[1],this._stream._view[this._start+1]=r[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendUint24(e){this._start+3>this._stream._buffer.byteLength&&(3>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint32Array([e]),r=new Uint8Array(t.buffer);this._stream._view[this._start]=r[2],this._stream._view[this._start+1]=r[1],this._stream._view[this._start+2]=r[0],this._length+=6,this.start=this._start+3,this.prevLength-=6}appendUint32(e){this._start+4>this._stream._buffer.byteLength&&(4>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint32Array([e]),r=new Uint8Array(t.buffer);this._stream._view[this._start]=r[3],this._stream._view[this._start+1]=r[2],this._stream._view[this._start+2]=r[1],this._stream._view[this._start+3]=r[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}getBlock(e,t=!0){if(this._length<=0)return[];let r;if(this._length<e&&(e=this._length),this.backward){const t=this._stream._buffer.slice(this._length-e,this._length),s=new Uint8Array(t);r=new Array(e);for(let i=0;i<e;i++)r[e-1-i]=s[i]}else{const t=this._stream._buffer.slice(this._start,this._start+e);r=Array.from(new Uint8Array(t))}return t&&(this.start+=this.backward?-1*e:e),r}getUint16(e=!0){const t=this.getBlock(2,e);if(t.length<2)return 0;const r=new Uint16Array(1),s=new Uint8Array(r.buffer);return s[0]=t[1],s[1]=t[0],r[0]}getInt16(e=!0){const t=this.getBlock(2,e);if(t.length<2)return 0;const r=new Int16Array(1),s=new Uint8Array(r.buffer);return s[0]=t[1],s[1]=t[0],r[0]}getUint24(e=!0){const t=this.getBlock(3,e);if(t.length<3)return 0;const r=new Uint32Array(1),s=new Uint8Array(r.buffer);for(let i=3;i>=1;i--)s[3-i]=t[i-1];return r[0]}getUint32(e=!0){const t=this.getBlock(4,e);if(t.length<4)return 0;const r=new Uint32Array(1),s=new Uint8Array(r.buffer);for(let i=3;i>=0;i--)s[3-i]=t[i];return r[0]}getInt32(e=!0){const t=this.getBlock(4,e);if(t.length<4)return 0;const r=new Int32Array(1),s=new Uint8Array(r.buffer);for(let i=3;i>=0;i--)s[3-i]=t[i];return r[0]}}class wt{constructor(e={}){this.version=s(e,"version",wt.defaultValues("version")),this.logID=s(e,"logID",wt.defaultValues("logID")),this.timestamp=s(e,"timestamp",wt.defaultValues("timestamp")),this.extensions=s(e,"extensions",wt.defaultValues("extensions")),this.hashAlgorithm=s(e,"hashAlgorithm",wt.defaultValues("hashAlgorithm")),this.signatureAlgorithm=s(e,"signatureAlgorithm",wt.defaultValues("signatureAlgorithm")),this.signature=s(e,"signature",wt.defaultValues("signature")),"schema"in e&&this.fromSchema(e.schema),"stream"in e&&this.fromStream(e.stream)}static defaultValues(e){switch(e){case"version":return 0;case"logID":case"extensions":return new ArrayBuffer(0);case"timestamp":return new Date(0);case"hashAlgorithm":case"signatureAlgorithm":return"";case"signature":return new i;default:throw new Error("Invalid member name for SignedCertificateTimestamp class: "+e)}}fromSchema(e){if(e instanceof u==0)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");const t=new mt({stream:new lt({buffer:e.data})});this.fromStream(t)}fromStream(e){const t=e.getUint16();if(this.version=e.getBlock(1)[0],0===this.version){this.logID=new Uint8Array(e.getBlock(32)).buffer.slice(0),this.timestamp=new Date(q(new Uint8Array(e.getBlock(8)),8));const r=e.getUint16();switch(this.extensions=new Uint8Array(e.getBlock(r)).buffer.slice(0),e.getBlock(1)[0]){case 0:this.hashAlgorithm="none";break;case 1:this.hashAlgorithm="md5";break;case 2:this.hashAlgorithm="sha1";break;case 3:this.hashAlgorithm="sha224";break;case 4:this.hashAlgorithm="sha256";break;case 5:this.hashAlgorithm="sha384";break;case 6:this.hashAlgorithm="sha512";break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}switch(e.getBlock(1)[0]){case 0:this.signatureAlgorithm="anonymous";break;case 1:this.signatureAlgorithm="rsa";break;case 2:this.signatureAlgorithm="dsa";break;case 3:this.signatureAlgorithm="ecdsa";break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}const s=e.getUint16(),i=new Uint8Array(e.getBlock(s)).buffer.slice(0),a=g(i);if(-1===a.offset)throw new Error("Object's stream was not correct for SignedCertificateTimestamp");if(this.signature=a.result,t!==47+r+s)throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}}toSchema(){const e=this.toStream();return new u({data:e.stream.buffer})}toStream(){const e=new mt;e.appendUint16(47+this.extensions.byteLength+this.signature.valueBeforeDecode.byteLength),e.appendChar(this.version),e.appendView(new Uint8Array(this.logID));const t=new ArrayBuffer(8),r=new Uint8Array(t),s=F(this.timestamp.valueOf(),8);let i,a;switch(r.set(new Uint8Array(s),8-s.byteLength),e.appendView(r),e.appendUint16(this.extensions.byteLength),this.extensions.byteLength&&e.appendView(new Uint8Array(this.extensions)),this.hashAlgorithm.toLowerCase()){case"none":i=0;break;case"md5":i=1;break;case"sha1":i=2;break;case"sha224":i=3;break;case"sha256":i=4;break;case"sha384":i=5;break;case"sha512":i=6;break;default:throw new Error("Incorrect data for hashAlgorithm: "+this.hashAlgorithm)}switch(e.appendChar(i),this.signatureAlgorithm.toLowerCase()){case"anonymous":a=0;break;case"rsa":a=1;break;case"dsa":a=2;break;case"ecdsa":a=3;break;default:throw new Error("Incorrect data for signatureAlgorithm: "+this.signatureAlgorithm)}e.appendChar(a);const n=this.signature.toBER(!1);return e.appendUint16(n.byteLength),e.appendView(new Uint8Array(n)),e}toJSON(){return{version:this.version,logID:J(this.logID),timestamp:this.timestamp,extensions:J(this.extensions),hashAlgorithm:this.hashAlgorithm,signatureAlgorithm:this.signatureAlgorithm,signature:this.signature.toJSON()}}async verify(e,t,r=0){let s,i=m(w(this.logID)),a=null,n=new mt;for(const l of e)if(l.log_id===i){a=l.key;break}if(null===a)throw new Error("Public key not found for CT with logId: "+i);const o=g(f(d(a)));if(-1===o.offset)throw new Error("Incorrect key value for CT Log with logId: "+i);s=new ve({schema:o.result}),n.appendChar(0),n.appendChar(0);const c=new ArrayBuffer(8),h=new Uint8Array(c),u=F(this.timestamp.valueOf(),8);return h.set(new Uint8Array(u),8-u.byteLength),n.appendView(h),n.appendUint16(r),0===r&&n.appendUint24(t.byteLength),n.appendView(new Uint8Array(t)),n.appendUint16(this.extensions.byteLength),0!==this.extensions.byteLength&&n.appendView(new Uint8Array(this.extensions)),De().subtle.verifyWithPublicKey(n._stream._buffer.slice(0,n._length),{valueBlock:{valueHex:this.signature.toBER(!1)}},s,{algorithmId:""},"SHA-256")}}class ft{constructor(e={}){this.timestamps=s(e,"timestamps",ft.defaultValues("timestamps")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"timestamps":return[];default:throw new Error("Invalid member name for SignedCertificateTimestampList class: "+e)}}static compareWithDefault(e,t){switch(e){case"timestamps":return 0===t.length;default:throw new Error("Invalid member name for SignedCertificateTimestampList class: "+e)}}static schema(e={}){const t=s(e,"names",{});return"optional"in t==0&&(t.optional=!1),new k({name:t.blockName||"SignedCertificateTimestampList",optional:t.optional})}fromSchema(e){if(e instanceof k==0)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");const t=new mt({stream:new lt({buffer:e.valueBlock.valueHex})});if(t.getUint16()!==t.length)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");for(;t.length;)this.timestamps.push(new wt({stream:t}))}toSchema(){const e=new mt;let t=0;const r=[];for(const s of this.timestamps){const e=s.toStream();r.push(e),t+=e.stream.buffer.byteLength}e.appendUint16(t);for(const s of r)e.appendView(s.stream.view);return new k({valueHex:e.stream.buffer.slice(0)})}toJSON(){return{timestamps:Array.from(this.timestamps,e=>e.toJSON())}}}class dt{constructor(e={}){this.templateID=s(e,"templateID",dt.defaultValues("templateID")),"templateMajorVersion"in e&&(this.templateMajorVersion=s(e,"templateMajorVersion",dt.defaultValues("templateMajorVersion"))),"templateMinorVersion"in e&&(this.templateMinorVersion=s(e,"templateMinorVersion",dt.defaultValues("templateMinorVersion"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"templateID":return"";case"templateMajorVersion":case"templateMinorVersion":return 0;default:throw new Error("Invalid member name for CertificateTemplate class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new n({name:t.templateID||""}),new y({name:t.templateMajorVersion||"",optional:!0}),new y({name:t.templateMinorVersion||"",optional:!0})]})}fromSchema(e){o(e,["templateID","templateMajorVersion","templateMinorVersion"]);let t=c(e,e,dt.schema({names:{templateID:"templateID",templateMajorVersion:"templateMajorVersion",templateMinorVersion:"templateMinorVersion"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificateTemplate");this.templateID=t.result.templateID.valueBlock.toString(),"templateMajorVersion"in t.result&&(this.templateMajorVersion=t.result.templateMajorVersion.valueBlock.valueDec),"templateMinorVersion"in t.result&&(this.templateMinorVersion=t.result.templateMinorVersion.valueBlock.valueDec)}toSchema(){const e=[];return e.push(new n({value:this.templateID})),"templateMajorVersion"in this&&e.push(new y({value:this.templateMajorVersion})),"templateMinorVersion"in this&&e.push(new y({value:this.templateMinorVersion})),new a({value:e})}toJSON(){const e={extnID:this.templateID};return"templateMajorVersion"in this&&(e.templateMajorVersion=this.templateMajorVersion),"templateMinorVersion"in this&&(e.templateMinorVersion=this.templateMinorVersion),e}}class yt{constructor(e={}){this.certificateIndex=s(e,"certificateIndex",yt.defaultValues("certificateIndex")),this.keyIndex=s(e,"keyIndex",yt.defaultValues("keyIndex")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"certificateIndex":case"keyIndex":return 0;default:throw new Error("Invalid member name for CAVersion class: "+e)}}static schema(e={}){return new y}fromSchema(e){if(e.constructor.blockName()!==y.blockName())throw new Error("Object's schema was not verified against input data for CAVersion");let t=e.valueBlock.valueHex.slice(0);const r=new Uint8Array(t);switch(!0){case t.byteLength<4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(r,4-t.byteLength),t=e.slice(0)}break;case t.byteLength>4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(r.slice(0,4)),t=e.slice(0)}}const s=t.slice(0,2),i=new Uint8Array(s);let a=i[0];i[0]=i[1],i[1]=a;const n=new Uint16Array(s);this.keyIndex=n[0];const o=t.slice(2),c=new Uint8Array(o);a=c[0],c[0]=c[1],c[1]=a;const h=new Uint16Array(o);this.certificateIndex=h[0]}toSchema(){const e=new ArrayBuffer(2);new Uint16Array(e)[0]=this.certificateIndex;const t=new Uint8Array(e);let r=t[0];t[0]=t[1],t[1]=r;const s=new ArrayBuffer(2);new Uint16Array(s)[0]=this.keyIndex;const i=new Uint8Array(s);return r=i[0],i[0]=i[1],i[1]=r,new y({valueHex:l(s,e)})}toJSON(){return{certificateIndex:this.certificateIndex,keyIndex:this.keyIndex}}}class pt{constructor(e={}){this.id=s(e,"id",pt.defaultValues("id")),"type"in e&&(this.type=s(e,"type",pt.defaultValues("type"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"id":return"";case"type":return new A;default:throw new Error("Invalid member name for QCStatement class: "+e)}}static compareWithDefault(e,t){switch(e){case"id":return""===t;case"type":return t instanceof A;default:throw new Error("Invalid member name for QCStatement class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new n({name:t.id||""}),new i({name:t.type||"",optional:!0})]})}fromSchema(e){o(e,["id","type"]);const t=c(e,e,pt.schema({names:{id:"id",type:"type"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for QCStatement");this.id=t.result.id.valueBlock.toString(),"type"in t.result&&(this.type=t.result.type)}toSchema(){const e=[new n({value:this.id})];return"type"in this&&e.push(this.type),new a({value:e})}toJSON(){const e={id:this.id};return"type"in this&&(e.type=this.type.toJSON()),e}}class bt{constructor(e={}){this.values=s(e,"values",bt.defaultValues("values")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"values":return[];default:throw new Error("Invalid member name for QCStatements class: "+e)}}static compareWithDefault(e,t){switch(e){case"values":return 0===t.length;default:throw new Error("Invalid member name for QCStatements class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new S({name:t.values||"",value:pt.schema(t.value||{})})]})}fromSchema(e){o(e,["values"]);const t=c(e,e,bt.schema({names:{values:"values"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for QCStatements");this.values=Array.from(t.result.values,e=>new pt({schema:e}))}toSchema(){return new a({value:Array.from(this.values,e=>e.toSchema())})}toJSON(){return{extensions:Array.from(this.values,e=>e.toJSON())}}}class gt{constructor(e={}){this.extnID=s(e,"extnID",gt.defaultValues("extnID")),this.critical=s(e,"critical",gt.defaultValues("critical")),this.extnValue="extnValue"in e?new k({valueHex:e.extnValue}):gt.defaultValues("extnValue"),"parsedValue"in e&&(this.parsedValue=s(e,"parsedValue",gt.defaultValues("parsedValue"))),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"extnID":return"";case"critical":return!1;case"extnValue":return new k;case"parsedValue":return{};default:throw new Error("Invalid member name for Extension class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[new n({name:t.extnID||""}),new L({name:t.critical||"",optional:!0}),new k({name:t.extnValue||""})]})}fromSchema(e){o(e,["extnID","critical","extnValue"]);let t=c(e,e,gt.schema({names:{extnID:"extnID",critical:"critical",extnValue:"extnValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Extension");if(this.extnID=t.result.extnID.valueBlock.toString(),"critical"in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue,t=g(this.extnValue.valueBlock.valueHex),-1!==t.offset)switch(this.extnID){case"2.5.29.9":try{this.parsedValue=new Le({schema:t.result})}catch(r){this.parsedValue=new Le,this.parsedValue.parsingError="Incorrectly formated SubjectDirectoryAttributes"}break;case"2.5.29.14":case"2.5.29.15":this.parsedValue=t.result;break;case"2.5.29.16":try{this.parsedValue=new qe({schema:t.result})}catch(r){this.parsedValue=new qe,this.parsedValue.parsingError="Incorrectly formated PrivateKeyUsagePeriod"}break;case"2.5.29.17":case"2.5.29.18":try{this.parsedValue=new Qe({schema:t.result})}catch(r){this.parsedValue=new Qe,this.parsedValue.parsingError="Incorrectly formated AltName"}break;case"2.5.29.19":try{this.parsedValue=new Ge({schema:t.result})}catch(r){this.parsedValue=new Ge,this.parsedValue.parsingError="Incorrectly formated BasicConstraints"}break;case"2.5.29.20":case"2.5.29.27":case"2.5.29.21":case"2.5.29.24":this.parsedValue=t.result;break;case"2.5.29.28":try{this.parsedValue=new ze({schema:t.result})}catch(r){this.parsedValue=new ze,this.parsedValue.parsingError="Incorrectly formated IssuingDistributionPoint"}break;case"2.5.29.29":try{this.parsedValue=new $e({schema:t.result})}catch(r){this.parsedValue=new $e,this.parsedValue.parsingError="Incorrectly formated GeneralNames"}break;case"2.5.29.30":try{this.parsedValue=new Xe({schema:t.result})}catch(r){this.parsedValue=new Xe,this.parsedValue.parsingError="Incorrectly formated NameConstraints"}break;case"2.5.29.31":case"2.5.29.46":try{this.parsedValue=new et({schema:t.result})}catch(r){this.parsedValue=new et,this.parsedValue.parsingError="Incorrectly formated CRLDistributionPoints"}break;case"2.5.29.32":case"1.3.6.1.4.1.311.21.10":try{this.parsedValue=new st({schema:t.result})}catch(r){this.parsedValue=new st,this.parsedValue.parsingError="Incorrectly formated CertificatePolicies"}break;case"2.5.29.33":try{this.parsedValue=new at({schema:t.result})}catch(r){this.parsedValue=new at,this.parsedValue.parsingError="Incorrectly formated CertificatePolicies"}break;case"2.5.29.35":try{this.parsedValue=new nt({schema:t.result})}catch(r){this.parsedValue=new nt,this.parsedValue.parsingError="Incorrectly formated AuthorityKeyIdentifier"}break;case"2.5.29.36":try{this.parsedValue=new ot({schema:t.result})}catch(r){this.parsedValue=new ot,this.parsedValue.parsingError="Incorrectly formated PolicyConstraints"}break;case"2.5.29.37":try{this.parsedValue=new ct({schema:t.result})}catch(r){this.parsedValue=new ct,this.parsedValue.parsingError="Incorrectly formated ExtKeyUsage"}break;case"2.5.29.54":this.parsedValue=t.result;break;case"1.3.6.1.5.5.7.1.1":case"1.3.6.1.5.5.7.1.11":try{this.parsedValue=new ut({schema:t.result})}catch(r){this.parsedValue=new ut,this.parsedValue.parsingError="Incorrectly formated InfoAccess"}break;case"1.3.6.1.4.1.11129.2.4.2":try{this.parsedValue=new ft({schema:t.result})}catch(r){this.parsedValue=new ft,this.parsedValue.parsingError="Incorrectly formated SignedCertificateTimestampList"}break;case"1.3.6.1.4.1.311.20.2":case"1.3.6.1.4.1.311.21.2":this.parsedValue=t.result;break;case"1.3.6.1.4.1.311.21.7":try{this.parsedValue=new dt({schema:t.result})}catch(r){this.parsedValue=new dt,this.parsedValue.parsingError="Incorrectly formated CertificateTemplate"}break;case"1.3.6.1.4.1.311.21.1":try{this.parsedValue=new yt({schema:t.result})}catch(r){this.parsedValue=new yt,this.parsedValue.parsingError="Incorrectly formated CAVersion"}break;case"1.3.6.1.5.5.7.1.3":try{this.parsedValue=new bt({schema:t.result})}catch(r){this.parsedValue=new bt,this.parsedValue.parsingError="Incorrectly formated QCStatements"}}}toSchema(){const e=[];return e.push(new n({value:this.extnID})),this.critical!==gt.defaultValues("critical")&&e.push(new L({value:this.critical})),e.push(this.extnValue),new a({value:e})}toJSON(){const e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==gt.defaultValues("critical")&&(e.critical=this.critical),"parsedValue"in this&&"toJSON"in this.parsedValue&&(e.parsedValue=this.parsedValue.toJSON()),e}}class At{constructor(e={}){this.extensions=s(e,"extensions",At.defaultValues("extensions")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"extensions":return[];default:throw new Error("Invalid member name for Extensions class: "+e)}}static schema(e={},t=!1){const r=s(e,"names",{});return new a({optional:t,name:r.blockName||"",value:[new S({name:r.extensions||"",value:gt.schema(r.extension||{})})]})}fromSchema(e){o(e,["extensions"]);const t=c(e,e,At.schema({names:{extensions:"extensions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Extensions");this.extensions=Array.from(t.result.extensions,e=>new gt({schema:e}))}toSchema(){return new a({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:Array.from(this.extensions,e=>e.toJSON())}}}function vt(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"tbsCertificate",value:[new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new y({name:t.tbsCertificateVersion||"tbsCertificate.version"})]}),new y({name:t.tbsCertificateSerialNumber||"tbsCertificate.serialNumber"}),be.schema(t.signature||{names:{blockName:"tbsCertificate.signature"}}),Me.schema(t.issuer||{names:{blockName:"tbsCertificate.issuer"}}),new a({name:t.tbsCertificateValidity||"tbsCertificate.validity",value:[Te.schema(t.notBefore||{names:{utcTimeName:"tbsCertificate.notBefore",generalTimeName:"tbsCertificate.notBefore"}}),Te.schema(t.notAfter||{names:{utcTimeName:"tbsCertificate.notAfter",generalTimeName:"tbsCertificate.notAfter"}})]}),Me.schema(t.subject||{names:{blockName:"tbsCertificate.subject"}}),ve.schema(t.subjectPublicKeyInfo||{names:{blockName:"tbsCertificate.subjectPublicKeyInfo"}}),new E({name:t.tbsCertificateIssuerUniqueID||"tbsCertificate.issuerUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new E({name:t.tbsCertificateSubjectUniqueID||"tbsCertificate.subjectUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new C({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[At.schema(t.extensions||{names:{blockName:"tbsCertificate.extensions"}})]})]})}class St{constructor(e={}){this.tbs=s(e,"tbs",St.defaultValues("tbs")),this.version=s(e,"version",St.defaultValues("version")),this.serialNumber=s(e,"serialNumber",St.defaultValues("serialNumber")),this.signature=s(e,"signature",St.defaultValues("signature")),this.issuer=s(e,"issuer",St.defaultValues("issuer")),this.notBefore=s(e,"notBefore",St.defaultValues("notBefore")),this.notAfter=s(e,"notAfter",St.defaultValues("notAfter")),this.subject=s(e,"subject",St.defaultValues("subject")),this.subjectPublicKeyInfo=s(e,"subjectPublicKeyInfo",St.defaultValues("subjectPublicKeyInfo")),"issuerUniqueID"in e&&(this.issuerUniqueID=s(e,"issuerUniqueID",St.defaultValues("issuerUniqueID"))),"subjectUniqueID"in e&&(this.subjectUniqueID=s(e,"subjectUniqueID",St.defaultValues("subjectUniqueID"))),"extensions"in e&&(this.extensions=s(e,"extensions",St.defaultValues("extensions"))),this.signatureAlgorithm=s(e,"signatureAlgorithm",St.defaultValues("signatureAlgorithm")),this.signatureValue=s(e,"signatureValue",St.defaultValues("signatureValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"version":return 0;case"serialNumber":return new y;case"signature":return new be;case"issuer":return new Me;case"notBefore":case"notAfter":return new Te;case"subject":return new Me;case"subjectPublicKeyInfo":return new ve;case"issuerUniqueID":case"subjectUniqueID":return new ArrayBuffer(0);case"extensions":return[];case"signatureAlgorithm":return new be;case"signatureValue":return new b;default:throw new Error("Invalid member name for Certificate class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({name:t.blockName||"",value:[vt(t.tbsCertificate),be.schema(t.signatureAlgorithm||{names:{blockName:"signatureAlgorithm"}}),new b({name:t.signatureValue||"signatureValue"})]})}fromSchema(e){o(e,["tbsCertificate","tbsCertificate.extensions","tbsCertificate.version","tbsCertificate.serialNumber","tbsCertificate.signature","tbsCertificate.issuer","tbsCertificate.notBefore","tbsCertificate.notAfter","tbsCertificate.subject","tbsCertificate.subjectPublicKeyInfo","tbsCertificate.issuerUniqueID","tbsCertificate.subjectUniqueID","signatureAlgorithm","signatureValue"]);const t=c(e,e,St.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:"tbsCertificate.extensions"}}}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Certificate");this.tbs=t.result.tbsCertificate.valueBeforeDecode,"tbsCertificate.version"in t.result&&(this.version=t.result["tbsCertificate.version"].valueBlock.valueDec),this.serialNumber=t.result["tbsCertificate.serialNumber"],this.signature=new be({schema:t.result["tbsCertificate.signature"]}),this.issuer=new Me({schema:t.result["tbsCertificate.issuer"]}),this.notBefore=new Te({schema:t.result["tbsCertificate.notBefore"]}),this.notAfter=new Te({schema:t.result["tbsCertificate.notAfter"]}),this.subject=new Me({schema:t.result["tbsCertificate.subject"]}),this.subjectPublicKeyInfo=new ve({schema:t.result["tbsCertificate.subjectPublicKeyInfo"]}),"tbsCertificate.issuerUniqueID"in t.result&&(this.issuerUniqueID=t.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex),"tbsCertificate.subjectUniqueID"in t.result&&(this.subjectUniqueID=t.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex),"tbsCertificate.extensions"in t.result&&(this.extensions=Array.from(t.result["tbsCertificate.extensions"],e=>new gt({schema:e}))),this.signatureAlgorithm=new be({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return"version"in this&&this.version!==St.defaultValues("version")&&e.push(new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new y({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new a({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),"issuerUniqueID"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),"subjectUniqueID"in this&&e.push(new E({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),"extensions"in this&&e.push(new C({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new a({value:Array.from(this.extensions,e=>e.toSchema())})]})),new a({value:e})}toSchema(e=!1){let t={};if(!1===e){if(0===this.tbs.length)return St.schema().value[0];t=g(this.tbs).result}else t=this.encodeTBS();return new a({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:J(this.tbs,0,this.tbs.byteLength),serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return"version"in this&&this.version!==St.defaultValues("version")&&(e.version=this.version),"issuerUniqueID"in this&&(e.issuerUniqueID=J(this.issuerUniqueID,0,this.issuerUniqueID.byteLength)),"subjectUniqueID"in this&&(e.subjectUniqueID=J(this.subjectUniqueID,0,this.subjectUniqueID.byteLength)),"extensions"in this&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}getPublicKey(e=null){return De().subtle.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}getKeyHash(e="SHA-1"){const t=Ke();return void 0===t?Promise.reject("Unable to create WebCrypto object"):t.digest({name:e},new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex))}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let r,s=Promise.resolve();const i=De();return s=s.then(()=>i.subtle.getSignatureParameters(e,t)),s=s.then(e=>{r=e.parameters,this.signature=e.signatureAlgorithm,this.signatureAlgorithm=e.signatureAlgorithm}),s=s.then(()=>{this.tbs=this.encodeTBS().toBER(!1)}),s=s.then(()=>i.subtle.signWithPrivateKey(this.tbs,e,r)),s=s.then(e=>{this.signatureValue=new b({valueHex:e})}),s}verify(e=null){let t={};return null!==e?t=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(t=this.subjectPublicKeyInfo),t instanceof ve==0?Promise.reject("Please provide issuer certificate as a parameter"):De().subtle.verifyWithPublicKey(this.tbs,this.signatureValue,t,this.signatureAlgorithm)}}function kt(e={}){const t=s(e,"names",{});return new a({name:t.CertificationRequestInfo||"CertificationRequestInfo",value:[new y({name:t.CertificationRequestInfoVersion||"CertificationRequestInfo.version"}),Me.schema(t.subject||{names:{blockName:"CertificationRequestInfo.subject"}}),ve.schema({names:{blockName:"CertificationRequestInfo.subjectPublicKeyInfo"}}),new C({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new S({optional:!0,name:t.CertificationRequestInfoAttributes||"CertificationRequestInfo.attributes",value:Se.schema(t.attributes||{})})]})]})}class Ct{constructor(e={}){this.tbs=s(e,"tbs",Ct.defaultValues("tbs")),this.version=s(e,"version",Ct.defaultValues("version")),this.subject=s(e,"subject",Ct.defaultValues("subject")),this.subjectPublicKeyInfo=s(e,"subjectPublicKeyInfo",Ct.defaultValues("subjectPublicKeyInfo")),"attributes"in e&&(this.attributes=s(e,"attributes",Ct.defaultValues("attributes"))),this.signatureAlgorithm=s(e,"signatureAlgorithm",Ct.defaultValues("signatureAlgorithm")),this.signatureValue=s(e,"signatureValue",Ct.defaultValues("signatureValue")),"schema"in e&&this.fromSchema(e.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"version":return 0;case"subject":return new Me;case"subjectPublicKeyInfo":return new ve;case"attributes":return[];case"signatureAlgorithm":return new be;case"signatureValue":return new b;default:throw new Error("Invalid member name for CertificationRequest class: "+e)}}static schema(e={}){const t=s(e,"names",{});return new a({value:[kt(t.certificationRequestInfo||{}),new a({name:t.signatureAlgorithm||"signatureAlgorithm",value:[new n,new i({optional:!0})]}),new b({name:t.signatureValue||"signatureValue"})]})}fromSchema(e){o(e,["CertificationRequestInfo","CertificationRequestInfo.version","CertificationRequestInfo.subject","CertificationRequestInfo.subjectPublicKeyInfo","CertificationRequestInfo.attributes","signatureAlgorithm","signatureValue"]);const t=c(e,e,Ct.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificationRequest");this.tbs=t.result.CertificationRequestInfo.valueBeforeDecode,this.version=t.result["CertificationRequestInfo.version"].valueBlock.valueDec,this.subject=new Me({schema:t.result["CertificationRequestInfo.subject"]}),this.subjectPublicKeyInfo=new ve({schema:t.result["CertificationRequestInfo.subjectPublicKeyInfo"]}),"CertificationRequestInfo.attributes"in t.result&&(this.attributes=Array.from(t.result["CertificationRequestInfo.attributes"],e=>new Se({schema:e}))),this.signatureAlgorithm=new be({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[new y({value:this.version}),this.subject.toSchema(),this.subjectPublicKeyInfo.toSchema()];return"attributes"in this&&e.push(new C({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new a({value:e})}toSchema(e=!1){let t;if(!1===e){if(0===this.tbs.byteLength)return Ct.schema();t=g(this.tbs).result}else t=this.encodeTBS();return new a({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:J(this.tbs,0,this.tbs.byteLength),version:this.version,subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return"attributes"in this&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let r,s=Promise.resolve();const i=De();return s=s.then(()=>i.subtle.getSignatureParameters(e,t)),s=s.then(e=>{r=e.parameters,this.signatureAlgorithm=e.signatureAlgorithm}),s=s.then(()=>{this.tbs=this.encodeTBS().toBER(!1)}),s=s.then(()=>i.subtle.signWithPrivateKey(this.tbs,e,r)),s=s.then(e=>{this.signatureValue=new b({valueHex:e})}),s}verify(){return De().subtle.verifyWithPublicKey(this.tbs,this.signatureValue,this.subjectPublicKeyInfo,this.signatureAlgorithm)}getPublicKey(e=null){return De().getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}}
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */var Pt;!function(e){e.CommonName="CN",e.Country="C",e.Region="L",e.State="ST",e.Organization="O",e.OrganizationUnit="OU"}(Pt||(Pt={}));const Et={[Pt.CommonName]:"2.5.4.3",[Pt.Country]:"2.5.4.6",[Pt.Region]:"2.5.4.7",[Pt.State]:"2.5.4.8",[Pt.Organization]:"2.5.4.10",[Pt.OrganizationUnit]:"2.5.4.11"};class It{static async csr(e,t,r){const s=new Ct;Oe("Crypto",e,new He({name:"Crypto",crypto:e,subtle:e.subtle}));const{publicKey:i,privateKey:a}=await e.subtle.generateKey(t,!1,It.keyUsages);return s.version=0,Object.keys(r).forEach(e=>{const t=r[e];t&&Et[e]&&s.subject.typesAndValues.push(new Ve({type:Et[e],value:new U({value:t})}))}),s.attributes=[],await s.subjectPublicKeyInfo.importKey(i),await s.sign(a,"SHA-256"),s.signatureAlgorithm.algorithmParams||(s.signatureAlgorithm.algorithmParams=new A),{der:s.toSchema().toBER(!1),privateKey:a,publicKey:i}}static async x509(e,t,r,s){const i=new St;Oe("Crypto",e,new He({name:"Crypto",crypto:e,subtle:e.subtle}));const{publicKey:a,privateKey:n}=await e.subtle.generateKey(t,!1,It.keyUsages);i.version=2,i.serialNumber=new y({value:1}),Object.keys(r).forEach(e=>{const t=r[e];t&&Et[e]&&i.subject.typesAndValues.push(new Ve({type:Et[e],value:new U({value:t})}))}),Object.keys(s).forEach(e=>{const t=s[e];t&&Et[e]&&i.issuer.typesAndValues.push(new Ve({type:Et[e],value:new U({value:t})}))});const o=new Date;i.notBefore.value=new Date(o.getFullYear(),o.getMonth(),o.getDate()),i.notAfter.value=new Date(o.getFullYear()+1,o.getMonth(),o.getDate()),i.extensions=[];const c=new Ge({cA:!0,pathLenConstraint:3});i.extensions.push(new gt({extnID:"2.5.29.19",critical:!0,extnValue:c.toSchema().toBER(!1),parsedValue:c}));const h=new ArrayBuffer(1),u=new Uint8Array(h);u[0]|=2,u[0]|=4,u[0]|=128;const l=new b({valueHex:h});i.extensions.push(new gt({extnID:"2.5.29.15",critical:!1,extnValue:l.toBER(!1),parsedValue:l}));const m=new ct({keyPurposes:["2.5.29.37.0","1.3.6.1.5.5.7.3.1","1.3.6.1.5.5.7.3.2","1.3.6.1.5.5.7.3.3","1.3.6.1.5.5.7.3.4","1.3.6.1.5.5.7.3.8","1.3.6.1.5.5.7.3.9","1.3.6.1.4.1.311.10.3.1","1.3.6.1.4.1.311.10.3.4"]});return i.extensions.push(new gt({extnID:"2.5.29.37",critical:!1,extnValue:m.toSchema().toBER(!1),parsedValue:m})),await i.subjectPublicKeyInfo.importKey(a),await i.sign(n,"SHA-256"),{der:i.toSchema(!0).toBER(!1),privateKey:n,publicKey:a}}}It.keyUsages=["sign","verify"];
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */
class Nt{constructor(...e){1===e.length?(this.asn=e[0],this.rawData=_.serialize(this.asn)):(this.asn=_.parse(e[0],e[1]),this.rawData=pe.BufferSourceConverter.toArrayBuffer(e[0]))}}
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */class Bt extends Nt{constructor(e){super(e,W);const t=this.getAsnExtnValue();switch(this.asn.extnID){case X:this.value=G.parse(t,Y);break;case $:this.value=G.parse(t,Z);break;case Q:this.value=G.parse(t,z);break;default:this.value=t}}getAsnExtnValue(){return this.asn.extnValue.buffer}}
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */class xt extends Nt{constructor(e){super(e,ee),this.extensions=[],this.parseExtensions()}parseExtensions(){const{tbsCertificate:e}=this.asn;e.extensions&&(this.extensions=e.extensions.map(e=>new Bt(_.serialize(e))))}getExtensionByOid(e){if(this.extensions.length)for(let t=0;t<this.extensions.length;t+=1){const r=this.extensions[t];if(r&&r.asn.extnID===e)return r}}hasKeyUsage(e,t=!0){if(!e||!e.length)return!1;const r=this.getExtensionByOid(X);if(!r)return!1;const s=r.value.toJSON();if(t&&!s.length)return!0;if(!s.length)return!1;const i=[];for(let a=0;a<e.length;a+=1)if(s.includes(e[a])&&i.push(e[a]),i.length===e.length)return!0;return!1}isQualified(e=[]){const t=this.getExtensionByOid($);if(!t)return!1;const r=this.getExtensionByOid(Q);if(!r)return!1;const s=t.value.map(e=>e.policyIdentifier),i=r.value.map(e=>e.statementId),a=i.includes("0.4.0.1862.1.1");let n=s.includes("0.4.0.1456.1.1")||s.includes("0.4.0.194112.1.3")||s.includes("0.4.0.194112.1.2")||i.includes("0.4.0.1862.1.4");const o=s.includes("0.4.0.194112.1.1")||i.includes("0.4.0.1862.1.6.2");return e.length&&e.forEach(e=>{i.includes(e)&&(n=!0)}),!!(a&&n||o)}}
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ut,Ht,jt,Ot,Dt,Kt=function(e,t){if(!t.has(e))throw new TypeError("attempted to get private field on non-instance");return t.get(e)},Rt=function(e,t,r){if(!t.has(e))throw new TypeError("attempted to set private field on non-instance");return t.set(e,r),r};!function(e){e.RSASSA_PKCS1_V1_5="RSASSA-PKCS1-V1_5",e.ECDSA="ECDSA"}(Ot||(Ot={})),function(e){e.SHA_256="SHA-256",e.SHA_384="SHA-384",e.SHA_512="SHA-512"}(Dt||(Dt={}));class Vt{constructor(e){this.FORTIFY_URL="127.0.0.1:31337",this.CONNECTION_CHECK_TIME=1e4,this.options={onClose:()=>{},onProvidersAdded:()=>{},onProvidersRemoved:()=>{},filters:{}},Ut.set(this,void 0),Ht.set(this,function(e){var t={userAgent:"",platform:"",maxTouchPoints:0};e||"undefined"==typeof navigator?"string"==typeof e?t.userAgent=e:e&&e.userAgent&&(t={userAgent:e.userAgent,platform:e.platform,maxTouchPoints:e.maxTouchPoints||0}):t={userAgent:navigator.userAgent,platform:navigator.platform,maxTouchPoints:navigator.maxTouchPoints||0};var r=t.userAgent,s=r.split("[FBAN");void 0!==s[1]&&(r=s[0]),void 0!==(s=r.split("Twitter"))[1]&&(r=s[0]);var i=function(e){return function(t){return t.test(e)}}(r),a={apple:{phone:i(te)&&!i(he),ipod:i(re),tablet:!i(te)&&(i(se)||ye(t))&&!i(he),universal:i(ie),device:(i(te)||i(re)||i(se)||i(ie)||ye(t))&&!i(he)},amazon:{phone:i(oe),tablet:!i(oe)&&i(ce),device:i(oe)||i(ce)},android:{phone:!i(he)&&i(oe)||!i(he)&&i(ae),tablet:!i(he)&&!i(oe)&&!i(ae)&&(i(ce)||i(ne)),device:!i(he)&&(i(oe)||i(ce)||i(ae)||i(ne))||i(/\bokhttp\b/i)},windows:{phone:i(he),tablet:i(ue),device:i(he)||i(ue)},other:{blackberry:i(le),blackberry10:i(me),opera:i(we),firefox:i(de),chrome:i(fe),device:i(le)||i(me)||i(we)||i(de)||i(fe)},any:!1,phone:!1,tablet:!1};return a.any=a.apple.device||a.android.device||a.windows.device||a.other.device,a.phone=a.apple.phone||a.android.phone||a.windows.phone,a.tablet=a.apple.tablet||a.android.tablet||a.windows.tablet,a}(window.navigator)),jt.set(this,void 0),Object.assign(this.options,e)}isConnectionSupported(){return!Kt(this,Ht).phone}async isConnectionDetected(){try{return(await fetch(`https://${this.FORTIFY_URL}/.well-known/webcrypto-socket`)).ok}catch(e){return!1}}async isConnectionDetectedAuto(){return new Promise(e=>{const t=async()=>{await this.isConnectionDetected()?e():Rt(this,jt,window.setTimeout(t,this.CONNECTION_CHECK_TIME))};t()})}async start(){if(!this.isConnectionSupported())throw new Error("connection_not_supported");if(!(await this.isConnectionDetected()))throw new Error("connection_not_detected");await this.connect()}finish(){this.server&&(this.server.client.close(),this.server=null),Kt(this,jt)&&(clearTimeout(Kt(this,jt)),Rt(this,jt,null))}async challenge(){if(!(await this.server.isLoggedIn()))return this.server.challenge()}async login(){try{await this.server.login()}catch(e){throw new Error("connection_key_not_approved")}}async connect(){if(await(async()=>{(/edge\/([\d.]+)/i.test(window.navigator.userAgent)||/firefox/i.test(window.navigator.userAgent)||window.document.documentMode)&&(window.asmCrypto||(window.asmCrypto=await __sc_import_peculiar("./p-83affd65.js")),window.elliptic||(window.elliptic=(await __sc_import_peculiar("./p-18df18da.js").then((function(e){return e.e}))).default),await __sc_import_peculiar("./p-97b23ccb.js")),window.protobuf||await __sc_import_peculiar("./p-68d26723.js").then((function(e){return e.p})),window.WebcryptoSocket||await __sc_import_peculiar("./p-8c3f080e.js")})(),!Kt(this,Ut))try{Rt(this,Ut,await WebcryptoSocket.BrowserStorage.create())}catch(e){Rt(this,Ut,new WebcryptoSocket.MemoryStorage)}return new Promise((e,t)=>{this.server&&e(),this.server=new WebcryptoSocket.SocketProvider({storage:Kt(this,Ut)}).connect(this.FORTIFY_URL).on("error",e=>{t(e)}).on("listening",async()=>{e()}).on("token",async e=>{if(e.added.length){const t=e.added.filter(e=>this.providerFilter(e));this.options.onProvidersAdded(t)}e.removed.length&&this.options.onProvidersRemoved(e.removed)}).on("disconnect",()=>{console.log("disconnect")}).on("close",()=>{this.options.onClose()})})}providerFilter(e){const{filters:t}=this.options;if(t.onlySmartcards&&!e.isRemovable)return!1;if(t.providerNameMatch){if("string"==typeof t.providerNameMatch&&!new RegExp(t.providerNameMatch,"i").test(e.name))return!1;if(t.providerNameMatch instanceof RegExp&&!t.providerNameMatch.test(e.name))return!1}return!0}async getProviders(){return(await this.server.info()).providers.filter(e=>this.providerFilter(e))}async getProviderById(e,t){const r=await this.server.getCrypto(e);return t&&(await r.isLoggedIn()||await r.login()),r}async getCertificatesByProviders(e){const t=[];for(const r of e){const e=await this.getCertificatesByProviderId(r.id);t.push(...e)}return t}certificatePreFilter(e){const{filters:t}=this.options;if("x509"!==e.split("-")[0])return!1;if(t.certificateIdMatch){let r;if("string"==typeof t.certificateIdMatch?r=new RegExp(t.certificateIdMatch,"i"):t.certificateIdMatch instanceof RegExp&&(r=t.certificateIdMatch),r&&!r.test(e))return!1}return!0}async certificateFilter(e){const{filters:t}=this.options;if(!t.expired&&e.notAfter.getTime()<Date.now())return!1;if(t.subjectDNMatch){let r;if("string"==typeof t.subjectDNMatch?r=new RegExp(t.subjectDNMatch,"i"):t.subjectDNMatch instanceof RegExp&&(r=t.subjectDNMatch),r&&!r.test(e.subjectName))return!1}if(t.issuerDNMatch){let r;if("string"==typeof t.issuerDNMatch?r=new RegExp(t.issuerDNMatch,"i"):t.issuerDNMatch instanceof RegExp&&(r=t.issuerDNMatch),r&&!r.test(e.issuerName))return!1}if(t.keyUsage&&t.keyUsage.length||t.onlyQualified){const r=new xt(e.raw);if(t.onlyQualified&&!r.isQualified(t.qualifiedCertificateStatements))return!1;if(t.keyUsage&&t.keyUsage.length&&!r.hasKeyUsage(t.keyUsage))return!1}return!0}async getCertificateByIndex(e,t,r){let s,i;try{s=await t.certStorage.getItem(e),i=await t.certStorage.exportCert("raw",s)}catch(a){return void console.warn("Can't read certificate: "+e)}if(s.raw=i,await this.certificateFilter(s))return s.index=e,s.subject=Vt.getDNValue(s.subjectName),s.issuer=Vt.getDNValue(s.issuerName),s.privateKeyId=r,s}async getCertificatesByProviderId(e){const{filters:t}=this.options;let r;try{r=await this.getProviderById(e,t.onlyWithPrivateKey)}catch(n){return[]}const s=[],i=await r.keyStorage.keys(),a=await r.certStorage.keys();for(const o of a){if(!this.certificatePreFilter(o))continue;const e=Vt.getCertificatePrivateKeyByIndex(o,i);t.onlyWithPrivateKey&&!e||s.push(this.getCertificateByIndex(o,r,e))}return(await Promise.all(s)).filter(e=>!!e)}async getCertificateBodyById(e,t){const{filters:r}=this.options,s=await this.getProviderById(e,r.onlyWithPrivateKey),i=await s.certStorage.getItem(t),a=await s.certStorage.exportCert("raw",i);return pe.Convert.ToBase64(a)}static getCertificatePrivateKeyByIndex(e,t){const r=t.filter(t=>{const r=t.split("-");return"private"===r[0]&&r[2]===e.split("-")[2]})[0];if(r)return r}static getDNValue(e){const t={};return e.split(/, /g).forEach(e=>{const[r,s]=e.split("=");t[r]=s}),t}async createX509(e,t){const r=await this.getProviderById(e,!0);let s;switch(r.exportKey=r.subtle.exportKey.bind(r.subtle),r.sign=r.subtle.sign.bind(r.subtle),r.digest=r.subtle.digest.bind(r.subtle),t.publicKey.signatureAlgorithm){case Ot.RSASSA_PKCS1_V1_5:s={hash:t.publicKey.hashAlgorithm,name:t.publicKey.signatureAlgorithm,publicExponent:new Uint8Array([1,0,1]),modulusLength:2048};break;case Ot.ECDSA:s={hash:t.publicKey.hashAlgorithm,name:t.publicKey.signatureAlgorithm,namedCurve:"P-256"};break;default:console.error("Unsupported signature algorithm name:",t.publicKey.signatureAlgorithm)}const i=await It.x509(r,s,t.subject,t.subject),a=await r.certStorage.importCert("raw",i.der,s,It.keyUsages);return await r.keyStorage.setItem(i.privateKey),await r.keyStorage.setItem(i.publicKey),await r.certStorage.setItem(a),i}async createCSR(e,t){const r=await this.getProviderById(e,!0);let s;switch(r.exportKey=r.subtle.exportKey.bind(r.subtle),r.sign=r.subtle.sign.bind(r.subtle),r.digest=r.subtle.digest.bind(r.subtle),t.publicKey.signatureAlgorithm){case Ot.RSASSA_PKCS1_V1_5:s={hash:t.publicKey.hashAlgorithm,name:t.publicKey.signatureAlgorithm,publicExponent:new Uint8Array([1,0,1]),modulusLength:2048};break;case Ot.ECDSA:s={hash:t.publicKey.hashAlgorithm,name:t.publicKey.signatureAlgorithm,namedCurve:"P-256"};break;default:console.error("Unsupported signature algorithm name:",t.publicKey.signatureAlgorithm)}const i=await It.csr(r,s,t.subject),a=await r.certStorage.importCert("raw",i.der,s,It.keyUsages);return await r.keyStorage.setItem(i.privateKey),await r.keyStorage.setItem(i.publicKey),await r.certStorage.setItem(a),i}}Ut=new WeakMap,Ht=new WeakMap,jt=new WeakMap;export{Ot as E,Vt as F,Dt as a,Pt as b}