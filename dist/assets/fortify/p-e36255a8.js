var t=function(t,e,r,i){function s(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var n=s(r),o=s(i);class a{static isArrayBuffer(t){return"[object ArrayBuffer]"===Object.prototype.toString.call(t)}static toArrayBuffer(t){const e=this.toUint8Array(t);return e.byteOffset||e.length?e.buffer.slice(e.byteOffset,e.byteOffset+e.length):e.buffer}static toUint8Array(t){if("undefined"!=typeof Buffer&&Buffer.isBuffer(t))return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);if(this.isArrayBuffer(t))return new Uint8Array(t);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}}function c(t){return"undefined"!=typeof Buffer&&Buffer.isBuffer(t)?new Uint8Array(t):a.isArrayBufferView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t)}class u{static isHex(t){return"string"==typeof t&&/^[a-z0-9]+$/i.test(t)}static isBase64(t){return"string"==typeof t&&/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}static isBase64Url(t){return"string"==typeof t&&/^[a-zA-Z0-9-_]+$/i.test(t)}static ToString(t,e="utf8"){const r=c(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){const e=c(t);if("undefined"!=typeof btoa){const t=this.ToString(e,"binary");return btoa(t)}return Buffer.from(e).toString("base64")}static FromBase64(t){const e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!u.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){const e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!u.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t){const e=unescape(encodeURIComponent(t)),r=new Uint8Array(e.length);for(let i=0;i<e.length;i++)r[i]=e.charCodeAt(i);return r.buffer}static ToUtf8String(t){const e=c(t),r=String.fromCharCode.apply(null,e);return decodeURIComponent(escape(r))}static FromBinary(t){const e=t.length,r=new Uint8Array(e);for(let i=0;i<e;i++)r[i]=t.charCodeAt(i);return r.buffer}static ToBinary(t){const e=c(t);let r="";const i=e.length;for(let s=0;s<i;s++)r+=String.fromCharCode(e[s]);return r}static ToHex(t){const e=c(t),r=[],i=e.length;for(let s=0;s<i;s++){const t=e[s].toString(16);r.push(1===t.length?"0"+t:t)}return r.join("")}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!u.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e="0"+e);const r=new Uint8Array(e.length/2);for(let i=0;i<e.length;i+=2){const t=e.slice(i,i+2);r[i/2]=parseInt(t,16)}return r.buffer}static Base64Padding(t){const e=4-t.length%4;if(e<4)for(let r=0;r<e;r++)t+="=";return t}static formatString(t){return(null==t?void 0:t.replace(/[\n\r\t ]/g,""))||""}}function h(t){const e=arguments[0];for(let r=1;r<arguments.length;r++){const t=arguments[r];for(const r in t)e[r]=t[r]}return e}function f(...t){const e=t.map(t=>t.byteLength).reduce((t,e)=>t+e),r=new Uint8Array(e);let i=0;return t.map(t=>new Uint8Array(t)).forEach(t=>{for(const e of t)r[i++]=e}),r.buffer}function l(t,e){if(!t||!e)return!1;if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),i=new Uint8Array(e);for(let s=0;s<t.byteLength;s++)if(r[s]!==i[s])return!1;return!0}
/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */function d(t,e,r,i){var s,n=arguments.length,o=n<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,r,i);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(o=(n<3?s(o):n>3?s(e,r,o):s(e,r))||o);return n>3&&o&&Object.defineProperty(e,r,o),o}class y{static async set(t){return new Uint8Array(t)}static async get(t){return new Uint8Array(t).buffer}}function w(t){return r=>{const i=r;i.localName=t.name||i.name||i.toString().match(/^function\s*([^\s(]+)/)[1],i.items=i.items||{},i.target=r,i.items=h({},i.items);const s=new e.Type(i.localName);for(const t in i.items){const r=i.items[t];let n=void 0;r.repeated?n="repeated":r.required&&(n="required"),s.add(new e.Field(r.name,r.id,r.type,n))}i.protobuf=s}}function p(t){return(e,r)=>{const i=e.constructor,s=r;i.items=i.items||{},i.target!==i&&(i.items=h({},i.items),i.target=i),i.items[s]={id:t.id,type:t.type||"bytes",defaultValue:t.defaultValue,converter:t.converter||null,parser:t.parser||null},t.name=t.name||s,i.items[s].name=t.name,i.items[s].required=t.required||!1,i.items[s].repeated=t.repeated||!1,function(t,e,r){const i="_"+e,s={set:function(t){this[i]!==t&&(this.raw=null,this[i]=t)},get:function(){if(void 0===this[i]){let t=r.defaultValue;r.parser&&!r.repeated&&(t=new r.parser),this[i]=t}return this[i]},enumerable:!0};Object.defineProperty(t,i,{writable:!0,enumerable:!1}),Object.defineProperty(t,e,s)}(e,s,i.items[s])}}class v{static async importProto(t){const e=new this;return await e.importProto(t),e}isEmpty(){return void 0===this.raw}hasChanged(){if(null===this.raw)return!0;const t=this.constructor,e=this;for(const r in t.items){const i=t.items[r];if(i.repeated){if(i.parser)return e[r].some(t=>t.hasChanged())}else if(i.parser&&e[r]&&e[r].hasChanged())return!0}return!1}async importProto(t){const e=this.constructor,r=this;let i,s;s=t instanceof v?await t.exportProto():t;try{i=e.protobuf.decode(new Uint8Array(s))}catch(n){throw new Error(`Error: Cannot decode message for ${e.localName}.\n$ProtobufError: ${n.message}`)}for(const o in e.items){const t=e.items[o];let s=i[t.name];ArrayBuffer.isView(s)&&(s=new Uint8Array(s)),Array.isArray(s)||(t.repeated?r[o]=s=[]:s=[s]),t.repeated&&!r[o]&&(r[o]=[]);for(const e of s)t.repeated?r[o].push(await this.importItem(t,e)):r[o]=await this.importItem(t,e)}this.raw=s}async exportProto(){if(!this.hasChanged())return this.raw;const t=this.constructor,e=this,r={};for(const i in t.items){const s=t.items[i];let n=e[i];Array.isArray(n)||(n=void 0===n?[]:[n]);for(const t of n){const e=await this.exportItem(s,t);s.repeated?(r[s.name]||(r[s.name]=[]),r[s.name].push(e)):r[s.name]=e}}return this.raw=new Uint8Array(t.protobuf.encode(r).finish()).buffer,this.raw}async exportItem(t,e){const r=this.constructor;let i;if(t.parser){const s=e,n=await s.exportProto();if(t.required&&!n)throw new Error(`Error: Paramter '${t.name}' is required in '${r.localName}' protobuf message.`);n&&(i=new Uint8Array(n))}else{if(t.required&&void 0===e)throw new Error(`Error: Paramter '${t.name}' is required in '${r.localName}' protobuf message.`);t.converter?void 0!==e&&(i=await t.converter.set(e)):(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),i=e)}return i}async importItem(t,e){const r=this.constructor;let i;if(t.parser){const s=t.parser;if(e&&e.byteLength)i=await s.importProto(new Uint8Array(e).buffer);else if(t.required)throw new Error(`Error: Parameter '${t.name}' is required in '${r.localName}' protobuf message.`)}else if(t.converter){if(e&&e.byteLength)i=await t.converter.get(e);else if(t.required)throw new Error(`Error: Parameter '${t.name}' is required in '${r.localName}' protobuf message.`)}else i=e;return i}}function m(){}function g(){g.init.call(this)}function b(t){return void 0===t._maxListeners?g.defaultMaxListeners:t._maxListeners}function A(t,e,r){if(e)t.call(r);else for(var i=t.length,s=I(t,i),n=0;n<i;++n)s[n].call(r)}function B(t,e,r,i){if(e)t.call(r,i);else for(var s=t.length,n=I(t,s),o=0;o<s;++o)n[o].call(r,i)}function S(t,e,r,i,s){if(e)t.call(r,i,s);else for(var n=t.length,o=I(t,n),a=0;a<n;++a)o[a].call(r,i,s)}function k(t,e,r,i,s,n){if(e)t.call(r,i,s,n);else for(var o=t.length,a=I(t,o),c=0;c<o;++c)a[c].call(r,i,s,n)}function E(t,e,r,i){if(e)t.apply(r,i);else for(var s=t.length,n=I(t,s),o=0;o<s;++o)n[o].apply(r,i)}function x(t,e,r,i){var s,n,o,a;if("function"!=typeof r)throw new TypeError('"listener" argument must be a function');if((n=t._events)?(n.newListener&&(t.emit("newListener",e,r.listener?r.listener:r),n=t._events),o=n[e]):(n=t._events=new m,t._eventsCount=0),o){if("function"==typeof o?o=n[e]=i?[r,o]:[o,r]:i?o.unshift(r):o.push(r),!o.warned&&(s=b(t))&&s>0&&o.length>s){o.warned=!0;var c=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+e+" listeners added. Use emitter.setMaxListeners() to increase limit");c.name="MaxListenersExceededWarning",c.emitter=t,c.type=e,c.count=o.length,a=c,"function"==typeof console.warn?console.warn(a):console.log(a)}}else o=n[e]=r,++t._eventsCount;return t}function N(t,e,r){var i=!1;function s(){t.removeListener(e,s),i||(i=!0,r.apply(t,arguments))}return s.listener=r,s}function U(t){var e=this._events;if(e){var r=e[t];if("function"==typeof r)return 1;if(r)return r.length}return 0}function I(t,e){for(var r=new Array(e);e--;)r[e]=t[e];return r}m.prototype=Object.create(null),g.EventEmitter=g,g.usingDomains=!1,g.prototype.domain=void 0,g.prototype._events=void 0,g.prototype._maxListeners=void 0,g.defaultMaxListeners=10,g.init=function(){this.domain=null,this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=new m,this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},g.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||isNaN(t))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=t,this},g.prototype.getMaxListeners=function(){return b(this)},g.prototype.emit=function(t){var e,r,i,s,n,o,a,c="error"===t;if(o=this._events)c=c&&null==o.error;else if(!c)return!1;if(a=this.domain,c){if(e=arguments[1],!a){if(e instanceof Error)throw e;var u=new Error('Uncaught, unspecified "error" event. ('+e+")");throw u.context=e,u}return e||(e=new Error('Uncaught, unspecified "error" event')),e.domainEmitter=this,e.domain=a,e.domainThrown=!1,a.emit("error",e),!1}if(!(r=o[t]))return!1;var h="function"==typeof r;switch(i=arguments.length){case 1:A(r,h,this);break;case 2:B(r,h,this,arguments[1]);break;case 3:S(r,h,this,arguments[1],arguments[2]);break;case 4:k(r,h,this,arguments[1],arguments[2],arguments[3]);break;default:for(s=new Array(i-1),n=1;n<i;n++)s[n-1]=arguments[n];E(r,h,this,s)}return!0},g.prototype.on=g.prototype.addListener=function(t,e){return x(this,t,e,!1)},g.prototype.prependListener=function(t,e){return x(this,t,e,!0)},g.prototype.once=function(t,e){if("function"!=typeof e)throw new TypeError('"listener" argument must be a function');return this.on(t,N(this,t,e)),this},g.prototype.prependOnceListener=function(t,e){if("function"!=typeof e)throw new TypeError('"listener" argument must be a function');return this.prependListener(t,N(this,t,e)),this},g.prototype.removeListener=function(t,e){var r,i,s,n,o;if("function"!=typeof e)throw new TypeError('"listener" argument must be a function');if(!(i=this._events))return this;if(!(r=i[t]))return this;if(r===e||r.listener&&r.listener===e)0==--this._eventsCount?this._events=new m:(delete i[t],i.removeListener&&this.emit("removeListener",t,r.listener||e));else if("function"!=typeof r){for(s=-1,n=r.length;n-- >0;)if(r[n]===e||r[n].listener&&r[n].listener===e){o=r[n].listener,s=n;break}if(s<0)return this;if(1===r.length){if(r[0]=void 0,0==--this._eventsCount)return this._events=new m,this;delete i[t]}else!function(t,e){for(var r=e,i=r+1,s=t.length;i<s;r+=1,i+=1)t[r]=t[i];t.pop()}(r,s);i.removeListener&&this.emit("removeListener",t,o||e)}return this},g.prototype.removeAllListeners=function(t){var e,r;if(!(r=this._events))return this;if(!r.removeListener)return 0===arguments.length?(this._events=new m,this._eventsCount=0):r[t]&&(0==--this._eventsCount?this._events=new m:delete r[t]),this;if(0===arguments.length){for(var i,s=Object.keys(r),n=0;n<s.length;++n)"removeListener"!==(i=s[n])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=new m,this._eventsCount=0,this}if("function"==typeof(e=r[t]))this.removeListener(t,e);else if(e)do{this.removeListener(t,e[e.length-1])}while(e[0]);return this},g.prototype.listeners=function(t){var e,r=this._events;return r&&(e=r[t])?"function"==typeof e?[e.listener||e]:function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(e):[]},g.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):U.call(t,e)},g.prototype.listenerCount=U,g.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};const C=u.FromBinary("InfoText"),q=u.FromBinary("InfoRatchet"),O=u.FromBinary("InfoMessageKeys");let R=null;function T(){if(!R)throw new Error("WebCrypto engine is empty. Use setEngine to resolve it.");return R}"undefined"!=typeof self&&(R={crypto:self.crypto,name:"WebCrypto"});let K=(()=>{class t{static async generateKeyPair(t,e){const r=t,i="ECDSA"===t?["sign","verify"]:["deriveKey","deriveBits"],s=await T().crypto.subtle.generateKey({name:r,namedCurve:this.NAMED_CURVE},e,i),n=await P.create(s.publicKey);return{privateKey:s.privateKey,publicKey:n}}static deriveBytes(t,e){return T().crypto.subtle.deriveBits({name:"ECDH",public:e.key},t,256)}static verify(t,e,r){return T().crypto.subtle.verify({name:"ECDSA",hash:this.DIGEST_ALGORITHM},t.key,r,e)}static async sign(t,e){return T().crypto.subtle.sign({name:"ECDSA",hash:this.DIGEST_ALGORITHM},t,e)}static async ecKeyPairToJson(t){return{privateKey:t.privateKey,publicKey:t.publicKey.key,thumbprint:await t.publicKey.thumbprint()}}static async ecKeyPairFromJson(t){return{privateKey:t.privateKey,publicKey:await P.create(t.publicKey)}}}return t.NAMED_CURVE="P-256",t.DIGEST_ALGORITHM="SHA-512",t})();const D={name:"AES-CBC",length:256};class j{static randomBytes(t){const e=new Uint8Array(t);return T().crypto.getRandomValues(e),e.buffer}static digest(t,e){return T().crypto.subtle.digest(t,e)}static encrypt(t,e,r){return T().crypto.subtle.encrypt({name:"AES-CBC",iv:new Uint8Array(r)},t,e)}static decrypt(t,e,r){return T().crypto.subtle.decrypt({name:"AES-CBC",iv:new Uint8Array(r)},t,e)}static importHMAC(t){return T().crypto.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign","verify"])}static importAES(t){return T().crypto.subtle.importKey("raw",t,D,!1,["encrypt","decrypt"])}static async sign(t,e){return await T().crypto.subtle.sign({name:"HMAC",hash:"SHA-256"},t,e)}static async HKDF(t,e=1,r,i=new ArrayBuffer(0)){r||(r=await this.importHMAC(new Uint8Array(32).buffer));const s=await this.sign(r,t),n=await this.importHMAC(s),o=[new ArrayBuffer(0)];for(let a=0;a<e;a++)o[a+1]=await this.sign(n,f(o[a],i,new Uint8Array([a+1]).buffer));return o.slice(1)}}class P{static async create(t){const e=new this,r=t.algorithm.name.toUpperCase();if("ECDH"!==r&&"ECDSA"!==r)throw new Error("Error: Unsupported asymmetric key algorithm.");if("public"!==t.type)throw new Error("Error: Expected key type to be public but it was not.");e.key=t;const i=await T().crypto.subtle.exportKey("jwk",t);if(!i.x||!i.y)throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const s=u.FromBase64Url(i.x),n=u.FromBase64Url(i.y),o=u.ToBinary(s)+u.ToBinary(n);return e.serialized=u.FromBinary(o),e.id=await e.thumbprint(),e}static async importKey(t,e){const r=u.ToBase64Url(t.slice(0,32)),i=u.ToBase64Url(t.slice(32)),s={crv:K.NAMED_CURVE,kty:"EC",x:r,y:i},n="ECDSA"===e?["verify"]:[],o=await T().crypto.subtle.importKey("jwk",s,{name:e,namedCurve:K.NAMED_CURVE},!0,n);return await P.create(o)}serialize(){return this.serialized}async thumbprint(){const t=await this.serialize(),e=await j.digest("SHA-256",t);return u.ToHex(e)}async isEqual(t){return!!(t&&t instanceof P)&&l(this.serialized,t.serialized)}}class ${constructor(t,e,r){this.id=t,this.signingKey=e,this.exchangeKey=r,this.preKeys=[],this.signedPreKeys=[]}static async fromJSON(t){const e=await K.ecKeyPairFromJson(t.signingKey),r=await K.ecKeyPairFromJson(t.exchangeKey),i=new this(t.id,e,r);return i.createdAt=new Date(t.createdAt),await i.fromJSON(t),i}static async create(t,e=0,r=0,i=!1){const s=await K.generateKeyPair("ECDSA",i),n=await K.generateKeyPair("ECDH",i),o=new $(t,s,n);o.createdAt=new Date;for(let a=0;a<r;a++)o.preKeys.push(await K.generateKeyPair("ECDH",i));for(let a=0;a<e;a++)o.signedPreKeys.push(await K.generateKeyPair("ECDH",i));return o}async toJSON(){const t=[],e=[];for(const r of this.preKeys)t.push(await K.ecKeyPairToJson(r));for(const r of this.signedPreKeys)e.push(await K.ecKeyPairToJson(r));return{createdAt:this.createdAt.toISOString(),exchangeKey:await K.ecKeyPairToJson(this.exchangeKey),id:this.id,preKeys:t,signedPreKeys:e,signingKey:await K.ecKeyPairToJson(this.signingKey)}}async fromJSON(t){this.id=t.id,this.signingKey=await K.ecKeyPairFromJson(t.signingKey),this.exchangeKey=await K.ecKeyPairFromJson(t.exchangeKey),this.preKeys=[];for(const e of t.preKeys)this.preKeys.push(await K.ecKeyPairFromJson(e));this.signedPreKeys=[];for(const e of t.signedPreKeys)this.signedPreKeys.push(await K.ecKeyPairFromJson(e))}}class V{static fill(t){const e=new V;return e.fill(t),e}static async fromJSON(t){const e=new this;return await e.fromJSON(t),e}fill(t){this.signingKey=t.signingKey,this.exchangeKey=t.exchangeKey,this.signature=t.signature,this.createdAt=t.createdAt}verify(){return K.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async toJSON(){return{createdAt:this.createdAt.toISOString(),exchangeKey:await this.exchangeKey.key,id:this.id,signature:this.signature,signingKey:await this.signingKey.key,thumbprint:await this.signingKey.thumbprint()}}async fromJSON(t){if(this.id=t.id,this.signature=t.signature,this.signingKey=await P.create(t.signingKey),this.exchangeKey=await P.create(t.exchangeKey),this.createdAt=new Date(t.createdAt),!(await this.verify()))throw new Error("Error: Wrong signature for RemoteIdentity")}}let J=(()=>{let t=class extends v{};return d([p({id:0,type:"uint32",defaultValue:1})],t.prototype,"version",void 0),t=d([w({name:"Base"})],t),t})();class M{static async set(t){return new Uint8Array(t.serialize())}static async get(t){return P.importKey(t.buffer,"ECDSA")}}class H{static async set(t){return new Uint8Array(t.serialize())}static async get(t){return P.importKey(t.buffer,"ECDH")}}class _{static async set(t){return new Uint8Array(u.FromString(t.toISOString()))}static async get(t){return new Date(u.ToString(t))}}let W=(()=>{var t;let e=t=class extends J{static async fill(e){const r=new t;return await r.fill(e),r}async sign(t){this.signature=await K.sign(t,this.exchangeKey.serialize())}async verify(){return await K.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async fill(t){this.signingKey=t.signingKey.publicKey,this.exchangeKey=t.exchangeKey.publicKey,this.createdAt=t.createdAt,await this.sign(t.signingKey.privateKey)}};return d([p({id:1,converter:M})],e.prototype,"signingKey",void 0),d([p({id:2,converter:H})],e.prototype,"exchangeKey",void 0),d([p({id:3})],e.prototype,"signature",void 0),d([p({id:4,converter:_})],e.prototype,"createdAt",void 0),e=t=d([w({name:"Identity"})],e),e})(),L=(()=>{let t=class extends J{};return d([p({id:1,converter:H,required:!0})],t.prototype,"senderRatchetKey",void 0),d([p({id:2,type:"uint32",required:!0})],t.prototype,"counter",void 0),d([p({id:3,type:"uint32",required:!0})],t.prototype,"previousCounter",void 0),d([p({id:4,converter:y,required:!0})],t.prototype,"cipherText",void 0),t=d([w({name:"Message"})],t),t})(),z=(()=>{let t=class extends J{async sign(t){this.signature=await this.signHMAC(t)}async verify(t){return l(await this.signHMAC(t),this.signature)}async getSignedRaw(){return f(this.receiverKey.serialize(),this.senderKey.serialize(),await this.message.exportProto())}async signHMAC(t){const e=await this.getSignedRaw();return await j.sign(t,e)}};return d([p({id:1,converter:M,required:!0})],t.prototype,"senderKey",void 0),d([p({id:2,parser:L,required:!0})],t.prototype,"message",void 0),d([p({id:3,required:!0})],t.prototype,"signature",void 0),t=d([w({name:"MessageSigned"})],t),t})(),G=(()=>{let t=class extends J{};return d([p({id:1,type:"uint32",required:!0})],t.prototype,"registrationId",void 0),d([p({id:2,type:"uint32"})],t.prototype,"preKeyId",void 0),d([p({id:3,type:"uint32",required:!0})],t.prototype,"preKeySignedId",void 0),d([p({id:4,converter:H,required:!0})],t.prototype,"baseKey",void 0),d([p({id:5,parser:W,required:!0})],t.prototype,"identity",void 0),d([p({id:6,parser:z,required:!0})],t.prototype,"signedMessage",void 0),t=d([w({name:"PreKeyMessage"})],t),t})(),F=(()=>{let t=class extends J{};return d([p({id:1,type:"uint32",required:!0})],t.prototype,"id",void 0),d([p({id:2,converter:H,required:!0})],t.prototype,"key",void 0),t=d([w({name:"PreKey"})],t),t})(),Z=(()=>{let t=class extends F{async sign(t){this.signature=await K.sign(t,this.key.serialize())}verify(t){return K.verify(t,this.key.serialize(),this.signature)}};return d([p({id:3,converter:y,required:!0})],t.prototype,"signature",void 0),t=d([w({name:"PreKeySigned"})],t),t})(),X=(()=>{let t=class extends J{};return d([p({id:1,type:"uint32",required:!0})],t.prototype,"registrationId",void 0),d([p({id:2,parser:W,required:!0})],t.prototype,"identity",void 0),d([p({id:3,parser:F})],t.prototype,"preKey",void 0),d([p({id:4,parser:Z,required:!0})],t.prototype,"preKeySigned",void 0),t=d([w({name:"PreKeyBundle"})],t),t})();const Q=new Uint8Array([1]).buffer,Y=new Uint8Array([2]).buffer;class tt{constructor(t){this.counter=0,this.rootKey=t}static async fromJSON(t){const e=new this(t.rootKey);return e.fromJSON(t),e}async toJSON(){return{counter:this.counter,rootKey:this.rootKey}}async fromJSON(t){this.counter=t.counter,this.rootKey=t.rootKey}async calculateKey(t){const e=await j.sign(t,Q),r=await j.sign(t,Y);return{cipher:e,rootKey:await j.importHMAC(r)}}async click(){const t=this.rootKey,e=await this.calculateKey(t);return this.rootKey=e.rootKey,this.counter++,e.cipher}}class et extends tt{async encrypt(t){const e=await this.click(),r=await j.HKDF(e,3,void 0,O),i=await j.importAES(r[0]),s=await j.importHMAC(r[1]),n=r[2].slice(0,16);return{cipherText:await j.encrypt(i,t,n),hmacKey:s}}}class rt extends tt{constructor(){super(...arguments),this.keys=[]}async toJSON(){const t=await super.toJSON();return t.keys=this.keys,t}async fromJSON(t){await super.fromJSON(t),this.keys=t.keys}async decrypt(t,e){const r=await this.getKey(e),i=await j.HKDF(r,3,void 0,O),s=await j.importAES(i[0]),n=await j.importHMAC(i[1]),o=i[2].slice(0,16);return{cipherText:await j.decrypt(s,t,o),hmacKey:n}}async getKey(t){for(;this.counter<=t;){const t=await this.click();this.keys.push(t)}return this.keys[t]}}class it extends g{constructor(t={}){super(),this.options=t,this.counter=0,this.currentStep=new st,this.steps=new nt(20),this.promises={}}static async create(t,e,r={}){let i;const s=new it(r);if(e instanceof X){if(!(await e.identity.verify()))throw new Error("Error: Remote client's identity key is invalid.");if(!(await e.preKeySigned.verify(e.identity.signingKey)))throw new Error("Error: Remote client's signed prekey is invalid.");s.currentRatchetKey=await s.generateRatchetKey(),s.currentStep.remoteRatchetKey=e.preKeySigned.key,s.remoteIdentity=V.fill(e.identity),s.remoteIdentity.id=e.registrationId,s.remotePreKeyId=e.preKey.id,s.remotePreKeySignedId=e.preKeySigned.id,i=await async function(t,e,r,i,s){const n=await K.deriveBytes(t.exchangeKey.privateKey,i),o=await K.deriveBytes(e.privateKey,r),a=await K.deriveBytes(e.privateKey,i);let c=new ArrayBuffer(0);s&&(c=await K.deriveBytes(e.privateKey,s));const u=new Uint8Array(32);for(let f=0;f<u.length;f++)u[f]=255;const h=f(u.buffer,n,o,a,c),l=await j.HKDF(h,1,void 0,C);return await j.importHMAC(l[0])}(t,s.currentRatchetKey,e.identity.exchangeKey,e.preKeySigned.key,e.preKey.key)}else{if(!(await e.identity.verify()))throw new Error("Error: Remote client's identity key is invalid.");const r=t.signedPreKeys[e.preKeySignedId];if(!r)throw new Error(`Error: PreKey with id ${e.preKeySignedId} not found`);let n;void 0!==e.preKeyId&&(n=t.preKeys[e.preKeyId]),s.remoteIdentity=V.fill(e.identity),s.currentRatchetKey=r,i=await async function(t,e,r,i,s){const n=await K.deriveBytes(e.privateKey,r),o=await K.deriveBytes(t.exchangeKey.privateKey,i),a=await K.deriveBytes(e.privateKey,i);let c=new ArrayBuffer(0);s&&(c=await K.deriveBytes(s,i));const u=new Uint8Array(32);for(let f=0;f<u.length;f++)u[f]=255;const h=f(u.buffer,n,o,a,c),l=await j.HKDF(h,1,void 0,C);return await j.importHMAC(l[0])}(t,s.currentRatchetKey,e.identity.exchangeKey,e.signedMessage.message.senderRatchetKey,n&&n.privateKey)}return s.identity=t,s.id=t.id,s.rootKey=i,s}static async fromJSON(t,e,r){const i=new it;return i.identity=t,i.remoteIdentity=e,await i.fromJSON(r),i}on(t,e){return super.on(t,e)}once(t,e){return super.once(t,e)}async decrypt(t){return this.queuePromise("encrypt",async()=>{const e=t.message.senderRatchetKey,r=t.message;if(t.message.previousCounter<this.counter-20)throw new Error("Error: Too old message");let i=this.steps.getStep(e);if(!i){const t=new st;t.remoteRatchetKey=e,this.steps.push(t),this.currentStep=t,i=t}i.receivingChain||(i.receivingChain=await this.createChain(this.currentRatchetKey.privateKey,e,rt));const s=await i.receivingChain.decrypt(r.cipherText,r.counter);if(this.update(),t.senderKey=this.remoteIdentity.signingKey,t.receiverKey=this.identity.signingKey.publicKey,!(await t.verify(s.hmacKey)))throw new Error("Error: The Message did not successfully verify!");return s.cipherText})}async encrypt(t){return this.queuePromise("encrypt",async()=>{if(this.currentStep.receivingChain&&!this.currentStep.sendingChain&&(this.counter++,this.currentRatchetKey=await this.generateRatchetKey()),!this.currentStep.sendingChain){if(!this.currentStep.remoteRatchetKey)throw new Error("currentStep has empty remoteRatchetKey");this.currentStep.sendingChain=await this.createChain(this.currentRatchetKey.privateKey,this.currentStep.remoteRatchetKey,et)}const e=await this.currentStep.sendingChain.encrypt(t);let r;this.update(),0!==this.steps.length||this.currentStep.receivingChain||1!==this.currentStep.sendingChain.counter||(r=new G,r.registrationId=this.identity.id,r.preKeyId=this.remotePreKeyId,r.preKeySignedId=this.remotePreKeySignedId,r.baseKey=this.currentRatchetKey.publicKey,await r.identity.fill(this.identity));const i=new z;return i.receiverKey=this.remoteIdentity.signingKey,i.senderKey=this.identity.signingKey.publicKey,i.message.cipherText=e.cipherText,i.message.counter=this.currentStep.sendingChain.counter-1,i.message.previousCounter=this.counter,i.message.senderRatchetKey=this.currentRatchetKey.publicKey,await i.sign(e.hmacKey),r?(r.signedMessage=i,r):i})}async hasRatchetKey(t){let e;e=t instanceof P?t:await P.create(t);for(const r of this.steps.items)if(await r.remoteRatchetKey.isEqual(e))return!0;return!1}async toJSON(){return{counter:this.counter,ratchetKey:await K.ecKeyPairToJson(this.currentRatchetKey),remoteIdentity:await this.remoteIdentity.signingKey.thumbprint(),rootKey:this.rootKey,steps:await this.steps.toJSON()}}async fromJSON(t){this.currentRatchetKey=await K.ecKeyPairFromJson(t.ratchetKey),this.counter=t.counter,this.rootKey=t.rootKey;for(const e of t.steps)this.currentStep=await st.fromJSON(e),this.steps.push(this.currentStep)}update(){this.emit("update")}generateRatchetKey(){return K.generateKeyPair("ECDH",!!this.options.exportableKeys)}async createChain(t,e,r){const i=await K.deriveBytes(t,e),s=await j.HKDF(i,2,this.rootKey,q),n=await j.importHMAC(s[0]),o=new r(await j.importHMAC(s[1]));return this.rootKey=n,o}queuePromise(t,e){const r=this.promises[t]||Promise.resolve(),i=this.promises[t]=r.then(e,e);return i.then(()=>{this.promises[t]===i&&delete this.promises[t]}),i}}class st{static async fromJSON(t){const e=new this;return await e.fromJSON(t),e}async toJSON(){const t={};return this.remoteRatchetKey&&(t.remoteRatchetKey=this.remoteRatchetKey.key),this.sendingChain&&(t.sendingChain=await this.sendingChain.toJSON()),this.receivingChain&&(t.receivingChain=await this.receivingChain.toJSON()),t}async fromJSON(t){t.remoteRatchetKey&&(this.remoteRatchetKey=await P.create(t.remoteRatchetKey)),t.sendingChain&&(this.sendingChain=await et.fromJSON(t.sendingChain)),t.receivingChain&&(this.receivingChain=await rt.fromJSON(t.receivingChain))}}class nt extends class{constructor(t=20){this.items=[],this.maxSize=t}get length(){return this.items.length}get latest(){return this.items[this.length-1]}push(t){this.length===this.maxSize&&(this.items=this.items.slice(1)),this.items.push(t)}async toJSON(){const t=[];for(const e of this.items)t.push(await e.toJSON());return t}async fromJSON(t){this.items=t}}{getStep(t){let e;return this.items.some(r=>(r.remoteRatchetKey.id===t.id&&(e=r),!!e)),e}}
/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */function ot(t,e,r,i){var s,n=arguments.length,o=n<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,r,i);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(o=(n<3?s(o):n>3?s(e,r,o):s(e,r))||o);return n>3&&o&&Object.defineProperty(e,r,o),o}class at{static async set(t){return new Uint8Array(u.FromUtf8String(t.toISOString()))}static async get(t){return new Date(u.ToUtf8String(t))}}class ct{static async set(t){return new Uint8Array(u.FromHex(t))}static async get(t){return u.ToHex(t)}}class ut{static async set(t){return new Uint8Array(u.FromUtf8String(t.toString(10)))}static async get(t){return parseInt(u.ToUtf8String(t),10)}}var ht,ft,lt,dt,yt,wt,pt,vt,mt;let gt=ht=class extends v{constructor(){super(...arguments),this.version=0}};gt.INDEX=1,ot([p({id:ht.INDEX++,type:"uint32",required:!0,defaultValue:1})],gt.prototype,"version",void 0),gt=ht=ot([w({name:"BaseMessage"})],gt);let bt=ft=class extends gt{constructor(){super(),this.actionId="",this.action=this.constructor.ACTION}};bt.INDEX=gt.INDEX,bt.ACTION="action",ot([p({id:ft.INDEX++,type:"string",required:!0})],bt.prototype,"action",void 0),ot([p({id:ft.INDEX++,type:"string",required:!1})],bt.prototype,"actionId",void 0),bt=ft=ot([w({name:"Action"})],bt);let At=lt=class extends gt{constructor(){super(...arguments),this.name=""}isEmpty(){return!this.name}toAlgorithm(){return{name:this.name}}fromAlgorithm(t){this.name=t.name}};At.INDEX=gt.INDEX,ot([p({id:lt.INDEX++,type:"string",required:!0})],At.prototype,"name",void 0),At=lt=ot([w({name:"BaseAlgorithm"})],At);let Bt=dt=class extends At{toAlgorithm(){const t={},e=this.constructor;for(const r in e.items){if("version"===r)continue;const e=this[r];"labelStr"!==r?void 0!==e&&(e instanceof At?e.isEmpty()||(t[r]=e.toAlgorithm()):t[r]=e):t.label=e}return t}fromAlgorithm(t){t instanceof dt&&(t=t.toAlgorithm());const e=this.constructor;for(const r in t)if(e.items&&r in e.items){const i=e.items[r];if(i.parser)switch(i.parser){case At:this[r].fromAlgorithm(t[r]);break;default:throw new Error(`Unsupported parser '${i.parser.name}'`)}else"label"===r&&"string"==typeof t.label?this.labelStr=t.label:this[r]=t[r]}}};Bt.INDEX=At.INDEX,ot([p({id:dt.INDEX++,type:"bytes",parser:At})],Bt.prototype,"hash",void 0),ot([p({id:dt.INDEX++,type:"bytes"})],Bt.prototype,"publicExponent",void 0),ot([p({id:dt.INDEX++,type:"uint32"})],Bt.prototype,"modulusLength",void 0),ot([p({id:dt.INDEX++,type:"uint32"})],Bt.prototype,"saltLength",void 0),ot([p({id:dt.INDEX++,type:"bytes"})],Bt.prototype,"label",void 0),ot([p({id:dt.INDEX++,type:"string"})],Bt.prototype,"namedCurve",void 0),ot([p({id:dt.INDEX++,converter:y})],Bt.prototype,"public",void 0),ot([p({id:dt.INDEX++,type:"uint32"})],Bt.prototype,"length",void 0),ot([p({id:dt.INDEX++})],Bt.prototype,"iv",void 0),ot([p({id:dt.INDEX++,type:"bool"})],Bt.prototype,"token",void 0),ot([p({id:dt.INDEX++,type:"bool"})],Bt.prototype,"sensitive",void 0),ot([p({id:dt.INDEX++,type:"string"})],Bt.prototype,"labelStr",void 0),Bt=dt=ot([w({name:"Algorithm"})],Bt);let St=yt=class extends gt{constructor(){super(...arguments),this.providerID="",this.id="",this.type=""}};St.INDEX=gt.INDEX,ot([p({id:yt.INDEX++,type:"string",required:!0})],St.prototype,"providerID",void 0),ot([p({id:yt.INDEX++,type:"bytes",required:!0,converter:ct})],St.prototype,"id",void 0),ot([p({id:yt.INDEX++,type:"string",required:!0})],St.prototype,"type",void 0),St=yt=ot([w({name:"CryptoItem"})],St);let kt=wt=class extends St{constructor(){super(...arguments),this.type="secret",this.algorithm={name:""},this.extractable=!1,this.usages=[]}};kt.INDEX=St.INDEX,ot([p({id:wt.INDEX++,type:"bytes",required:!0,converter:class{static async set(t){const e=new Bt;e.fromAlgorithm(t);const r=await e.exportProto();return new Uint8Array(r)}static async get(t){const e=new Bt;return await e.importProto(t),e.toAlgorithm()}}})],kt.prototype,"algorithm",void 0),ot([p({id:wt.INDEX++,type:"bool"})],kt.prototype,"extractable",void 0),ot([p({id:wt.INDEX++,type:"string",repeated:!0})],kt.prototype,"usages",void 0),kt=wt=ot([w({name:"CryptoKey"})],kt);let Et=pt=class extends gt{constructor(){super(...arguments),this.privateKey=new kt,this.publicKey=new kt}};Et.INDEX=gt.INDEX,ot([p({id:pt.INDEX++,name:"privateKey",type:"bytes",required:!0,parser:kt})],Et.prototype,"privateKey",void 0),ot([p({id:pt.INDEX++,name:"publicKey",type:"bytes",parser:kt})],Et.prototype,"publicKey",void 0),Et=pt=ot([w({name:"CryptoKeyPair"})],Et);let xt=vt=class extends gt{constructor(t,e=0,r="error"){super(),this.code=0,this.type="error",this.message="",this.name="Error",this.stack="",t&&(this.message=t,this.code=e,this.type=r)}};xt.INDEX=gt.INDEX,ot([p({id:vt.INDEX++,type:"uint32",defaultValue:0})],xt.prototype,"code",void 0),ot([p({id:vt.INDEX++,type:"string",defaultValue:"error"})],xt.prototype,"type",void 0),ot([p({id:vt.INDEX++,type:"string",defaultValue:""})],xt.prototype,"message",void 0),ot([p({id:vt.INDEX++,type:"string",defaultValue:"Error"})],xt.prototype,"name",void 0),ot([p({id:vt.INDEX++,type:"string",defaultValue:""})],xt.prototype,"stack",void 0),xt=vt=ot([w({name:"Error"})],xt);let Nt=mt=class extends bt{constructor(t){super(),this.status=!1,t&&(this.actionId=t.actionId,this.action=t.action)}};Nt.INDEX=bt.INDEX,ot([p({id:mt.INDEX++,type:"bool",defaultValue:!1})],Nt.prototype,"status",void 0),ot([p({id:mt.INDEX++,type:"bytes",parser:xt})],Nt.prototype,"error",void 0),ot([p({id:mt.INDEX++,type:"bytes",converter:y})],Nt.prototype,"data",void 0),Nt=mt=ot([w({name:"Result"})],Nt);let Ut=class extends bt{};Ut.INDEX=bt.INDEX,Ut.ACTION="auth",Ut=ot([w({name:"AuthRequest"})],Ut);let It=class extends bt{};It.INDEX=bt.INDEX,It.ACTION="server/login",It=ot([w({})],It);let Ct=class extends bt{};var qt;Ct.INDEX=bt.INDEX,Ct.ACTION="server/isLoggedIn",Ct=ot([w({})],Ct);let Ot=class extends bt{};Ot.INDEX=bt.INDEX,Ot.ACTION="cardReader",Ot=ot([w({})],Ot);let Rt=class extends bt{};Rt.INDEX=bt.INDEX,Rt.ACTION="cardReader/readers",Rt=ot([w({})],Rt);let Tt=qt=class extends Ot{constructor(t,e){super(),this.reader="",this.atr="",t&&e&&(this.reader=t,this.atr=e)}};Tt.INDEX=Ot.INDEX,ot([p({id:qt.INDEX++,required:!0,type:"string",defaultValue:""})],Tt.prototype,"reader",void 0),ot([p({id:qt.INDEX++,required:!0,converter:ct})],Tt.prototype,"atr",void 0),Tt=qt=ot([w({})],Tt);let Kt=class extends Tt{};Kt.INDEX=Tt.INDEX,Kt.ACTION=Tt.ACTION+"/insert",Kt=ot([w({})],Kt);let Dt=class extends Tt{};var jt;Dt.INDEX=Tt.INDEX,Dt.ACTION=Tt.ACTION+"/remove",Dt=ot([w({})],Dt);let Pt=jt=class extends bt{constructor(){super(...arguments),this.providerID=""}};Pt.INDEX=bt.INDEX,Pt.ACTION="crypto",ot([p({id:jt.INDEX++,required:!0,type:"string"})],Pt.prototype,"providerID",void 0),Pt=jt=ot([w({})],Pt);let $t=class extends Pt{};$t.INDEX=Pt.INDEX,$t.ACTION="crypto/login",$t=ot([w({})],$t);let Vt=class extends Pt{};Vt.INDEX=Pt.INDEX,Vt.ACTION="crypto/logout",Vt=ot([w({})],Vt);let Jt=class extends Pt{};Jt.INDEX=Pt.INDEX,Jt.ACTION="crypto/isLoggedIn",Jt=ot([w({})],Jt);let Mt=class extends Pt{};var Ht,_t,Wt,Lt,zt,Gt,Ft,Zt,Xt,Qt,Yt,te,ee,re,ie;Mt.INDEX=Pt.INDEX,Mt.ACTION="crypto/reset",Mt=ot([w({})],Mt);let se=Ht=class extends St{constructor(){super(...arguments),this.id="",this.publicKey=new kt,this.type="x509",this.label="",this.token=!1,this.sensitive=!1}};se.INDEX=St.INDEX,ot([p({id:Ht.INDEX++,required:!0,converter:ct})],se.prototype,"id",void 0),ot([p({id:Ht.INDEX++,required:!0,parser:kt})],se.prototype,"publicKey",void 0),ot([p({id:Ht.INDEX++,required:!0,type:"string"})],se.prototype,"type",void 0),ot([p({id:Ht.INDEX++,type:"string",defaultValue:""})],se.prototype,"label",void 0),ot([p({id:Ht.INDEX++,type:"bool",defaultValue:!1})],se.prototype,"token",void 0),ot([p({id:Ht.INDEX++,type:"bool",defaultValue:!1})],se.prototype,"sensitive",void 0),se=Ht=ot([w({})],se);let ne=_t=class extends se{constructor(){super(...arguments),this.type="x509",this.serialNumber="",this.issuerName="",this.subjectName="",this.notBefore=new Date,this.notAfter=new Date}};ne.INDEX=se.INDEX,ot([p({id:_t.INDEX++,required:!0,converter:ct})],ne.prototype,"serialNumber",void 0),ot([p({id:_t.INDEX++,required:!0,type:"string"})],ne.prototype,"issuerName",void 0),ot([p({id:_t.INDEX++,required:!0,type:"string"})],ne.prototype,"subjectName",void 0),ot([p({id:_t.INDEX++,required:!0,converter:at})],ne.prototype,"notBefore",void 0),ot([p({id:_t.INDEX++,required:!0,converter:at})],ne.prototype,"notAfter",void 0),ne=_t=ot([w({})],ne);let oe=Wt=class extends se{constructor(){super(...arguments),this.type="request",this.subjectName=""}};oe.INDEX=se.INDEX,ot([p({id:Wt.INDEX++,required:!0,type:"string"})],oe.prototype,"subjectName",void 0),oe=Wt=ot([w({})],oe);let ae=Lt=class extends gt{constructor(){super(...arguments),this.type="",this.value=new ArrayBuffer(0)}};ae.INDEX=gt.INDEX,ot([p({id:Lt.INDEX++,required:!0,type:"string"})],ae.prototype,"type",void 0),ot([p({id:Lt.INDEX++,required:!0,converter:y})],ae.prototype,"value",void 0),ae=Lt=ot([w({})],ae);let ce=zt=class extends gt{constructor(){super(...arguments),this.items=[]}};ce.INDEX=gt.INDEX,ot([p({id:zt.INDEX++,required:!0,repeated:!0,parser:ae})],ce.prototype,"items",void 0),ce=zt=ot([w({})],ce);let ue=Gt=class extends Pt{constructor(){super(...arguments),this.item=new se}};ue.INDEX=Pt.INDEX,ue.ACTION="crypto/certificateStorage/setItem",ot([p({id:Gt.INDEX++,required:!0,parser:se})],ue.prototype,"item",void 0),ue=Gt=ot([w({})],ue);let he=Ft=class extends Pt{constructor(){super(...arguments),this.key="",this.algorithm=new Bt,this.keyUsages=[]}};he.INDEX=Pt.INDEX,he.ACTION="crypto/certificateStorage/getItem",ot([p({id:Ft.INDEX++,required:!0,type:"string"})],he.prototype,"key",void 0),ot([p({id:Ft.INDEX++,parser:Bt})],he.prototype,"algorithm",void 0),ot([p({id:Ft.INDEX++,repeated:!0,type:"string"})],he.prototype,"keyUsages",void 0),he=Ft=ot([w({})],he);let fe=class extends Pt{};fe.INDEX=Pt.INDEX,fe.ACTION="crypto/certificateStorage/keys",fe=ot([w({})],fe);let le=Zt=class extends Pt{constructor(){super(...arguments),this.key=""}};le.INDEX=Pt.INDEX,le.ACTION="crypto/certificateStorage/getValue",ot([p({id:Zt.INDEX++,required:!0,type:"string"})],le.prototype,"key",void 0),le=Zt=ot([w({})],le);let de=Xt=class extends Pt{constructor(){super(...arguments),this.key=""}};de.INDEX=Pt.INDEX,de.ACTION="crypto/certificateStorage/removeItem",ot([p({id:Xt.INDEX++,required:!0,type:"string"})],de.prototype,"key",void 0),de=Xt=ot([w({})],de);let ye=class extends Pt{};ye.INDEX=Pt.INDEX,ye.ACTION="crypto/certificateStorage/clear",ye=ot([w({})],ye);let we=Qt=class extends Pt{constructor(){super(...arguments),this.format="raw",this.data=new ArrayBuffer(0),this.algorithm=new Bt,this.keyUsages=[]}};we.INDEX=Pt.INDEX,we.ACTION="crypto/certificateStorage/import",ot([p({id:Qt.INDEX++,required:!0,type:"string"})],we.prototype,"format",void 0),ot([p({id:Qt.INDEX++,required:!0,converter:y})],we.prototype,"data",void 0),ot([p({id:Qt.INDEX++,required:!0,parser:Bt})],we.prototype,"algorithm",void 0),ot([p({id:Qt.INDEX++,repeated:!0,type:"string"})],we.prototype,"keyUsages",void 0),we=Qt=ot([w({})],we);let pe=Yt=class extends Pt{constructor(){super(...arguments),this.format="raw",this.item=new se}};pe.INDEX=Pt.INDEX,pe.ACTION="crypto/certificateStorage/export",ot([p({id:Yt.INDEX++,required:!0,type:"string"})],pe.prototype,"format",void 0),ot([p({id:Yt.INDEX++,required:!0,parser:se})],pe.prototype,"item",void 0),pe=Yt=ot([w({})],pe);let ve=te=class extends Pt{constructor(){super(...arguments),this.item=new se}};ve.INDEX=Pt.INDEX,ve.ACTION="crypto/certificateStorage/indexOf",ot([p({id:te.INDEX++,required:!0,parser:se})],ve.prototype,"item",void 0),ve=te=ot([w({})],ve);let me=class extends Pt{constructor(){super(...arguments),this.item=new se}};me.INDEX=Pt.INDEX,me.ACTION="crypto/certificateStorage/getChain",ot([p({id:ue.INDEX++,required:!0,parser:se})],me.prototype,"item",void 0),me=ot([w({})],me);let ge=ee=class extends Pt{constructor(){super(...arguments),this.url=""}};ge.INDEX=Pt.INDEX,ge.ACTION="crypto/certificateStorage/getCRL",ot([p({id:ee.INDEX++,required:!0,type:"string"})],ge.prototype,"url",void 0),ge=ee=ot([w({})],ge);let be=re=class extends gt{constructor(){super(...arguments),this.method="get"}};be.INDEX=gt.INDEX,ot([p({id:re.INDEX++,required:!1,type:"string",defaultValue:"get"})],be.prototype,"method",void 0),be=re=ot([w({})],be);let Ae=ie=class extends Pt{constructor(){super(...arguments),this.url="",this.request=new ArrayBuffer(0),this.options=new be}};var Be,Se,ke,Ee;Ae.INDEX=Pt.INDEX,Ae.ACTION="crypto/certificateStorage/getOCSP",ot([p({id:ie.INDEX++,required:!0,type:"string"})],Ae.prototype,"url",void 0),ot([p({id:ie.INDEX++,required:!0,converter:y})],Ae.prototype,"request",void 0),ot([p({id:ie.INDEX++,required:!1,parser:be})],Ae.prototype,"options",void 0),Ae=ie=ot([w({})],Ae);let xe=Be=class extends Pt{constructor(){super(...arguments),this.item=new kt}};xe.INDEX=Pt.INDEX,xe.ACTION="crypto/keyStorage/setItem",ot([p({id:Be.INDEX++,required:!0,parser:kt})],xe.prototype,"item",void 0),xe=Be=ot([w({})],xe);let Ne=Se=class extends Pt{constructor(){super(...arguments),this.key="",this.algorithm=new Bt,this.extractable=!1,this.keyUsages=[]}};Ne.INDEX=Pt.INDEX,Ne.ACTION="crypto/keyStorage/getItem",ot([p({id:Se.INDEX++,required:!0,type:"string"})],Ne.prototype,"key",void 0),ot([p({id:Se.INDEX++,parser:Bt})],Ne.prototype,"algorithm",void 0),ot([p({id:Se.INDEX++,type:"bool"})],Ne.prototype,"extractable",void 0),ot([p({id:Se.INDEX++,repeated:!0,type:"string"})],Ne.prototype,"keyUsages",void 0),Ne=Se=ot([w({})],Ne);let Ue=class extends Pt{};Ue.INDEX=Pt.INDEX,Ue.ACTION="crypto/keyStorage/keys",Ue=ot([w({})],Ue);let Ie=ke=class extends Pt{constructor(){super(...arguments),this.key=""}};Ie.INDEX=Pt.INDEX,Ie.ACTION="crypto/keyStorage/removeItem",ot([p({id:ke.INDEX++,required:!0,type:"string"})],Ie.prototype,"key",void 0),Ie=ke=ot([w({})],Ie);let Ce=class extends Pt{};Ce.INDEX=Pt.INDEX,Ce.ACTION="crypto/keyStorage/clear",Ce=ot([w({})],Ce);let qe=Ee=class extends Pt{constructor(){super(...arguments),this.item=new kt}};var Oe,Re,Te,Ke,De,je;qe.INDEX=Pt.INDEX,qe.ACTION="crypto/keyStorage/indexOf",ot([p({id:Ee.INDEX++,required:!0,parser:kt})],qe.prototype,"item",void 0),qe=Ee=ot([w({})],qe);let Pe=Oe=class extends gt{constructor(t){super(),this.major=0,this.minor=0,t&&h(this,t)}};Pe.INDEX=gt.INDEX,ot([p({id:Oe.INDEX++,required:!0,type:"uint32"})],Pe.prototype,"major",void 0),ot([p({id:Oe.INDEX++,required:!0,type:"uint32"})],Pe.prototype,"minor",void 0),Pe=Oe=ot([w({})],Pe);let $e=Re=class extends gt{constructor(t){super(),this.label="",this.manufacturerID="",this.model="",this.serialNumber="",this.flags=0,this.hardwareVersion=new Pe,this.firmwareVersion=new Pe,this.maxSessionCount=0,this.sessionCount=0,this.maxRwSessionCount=0,this.rwSessionCount=0,this.maxPinLen=0,this.minPinLen=0,this.totalPublicMemory=0,this.freePublicMemory=0,this.totalPrivateMemory=0,this.freePrivateMemory=0,t&&(h(this,t),this.firmwareVersion=new Pe(t.firmwareVersion),this.hardwareVersion=new Pe(t.hardwareVersion))}};$e.INDEX=gt.INDEX,ot([p({id:Re.INDEX++,required:!0,type:"string"})],$e.prototype,"label",void 0),ot([p({id:Re.INDEX++,required:!0,type:"string"})],$e.prototype,"manufacturerID",void 0),ot([p({id:Re.INDEX++,required:!0,type:"string"})],$e.prototype,"model",void 0),ot([p({id:Re.INDEX++,required:!0,type:"string"})],$e.prototype,"serialNumber",void 0),ot([p({id:Re.INDEX++,required:!0,type:"uint32"})],$e.prototype,"flags",void 0),ot([p({id:Re.INDEX++,required:!0,parser:Pe})],$e.prototype,"hardwareVersion",void 0),ot([p({id:Re.INDEX++,required:!0,parser:Pe})],$e.prototype,"firmwareVersion",void 0),ot([p({id:Re.INDEX++,required:!0,type:"uint32"})],$e.prototype,"maxSessionCount",void 0),ot([p({id:Re.INDEX++,required:!0,type:"uint32"})],$e.prototype,"sessionCount",void 0),ot([p({id:Re.INDEX++,required:!0,type:"uint32"})],$e.prototype,"maxRwSessionCount",void 0),ot([p({id:Re.INDEX++,required:!0,type:"uint32"})],$e.prototype,"rwSessionCount",void 0),ot([p({id:Re.INDEX++,required:!0,type:"uint32"})],$e.prototype,"maxPinLen",void 0),ot([p({id:Re.INDEX++,required:!0,type:"uint32"})],$e.prototype,"minPinLen",void 0),ot([p({id:Re.INDEX++,required:!0,converter:ut})],$e.prototype,"totalPublicMemory",void 0),ot([p({id:Re.INDEX++,required:!0,converter:ut})],$e.prototype,"freePublicMemory",void 0),ot([p({id:Re.INDEX++,required:!0,converter:ut})],$e.prototype,"totalPrivateMemory",void 0),ot([p({id:Re.INDEX++,required:!0,converter:ut})],$e.prototype,"freePrivateMemory",void 0),$e=Re=ot([w({})],$e);let Ve=Te=class extends gt{constructor(t){super(),this.id="",this.name="",this.readOnly=!1,this.algorithms=[],this.isRemovable=!1,this.atr="",this.isHardware=!1,this.card="",t&&(h(this,t),t.token&&(this.token=new $e(t.token)))}};Ve.INDEX=gt.INDEX,ot([p({id:Te.INDEX++,required:!0,type:"string"})],Ve.prototype,"id",void 0),ot([p({id:Te.INDEX++,required:!0,type:"string"})],Ve.prototype,"name",void 0),ot([p({id:Te.INDEX++,type:"bool",defaultValue:!1})],Ve.prototype,"readOnly",void 0),ot([p({id:Te.INDEX++,repeated:!0,type:"string"})],Ve.prototype,"algorithms",void 0),ot([p({id:Te.INDEX++,type:"bool",defaultValue:!1})],Ve.prototype,"isRemovable",void 0),ot([p({id:Te.INDEX++,type:"string"})],Ve.prototype,"atr",void 0),ot([p({id:Te.INDEX++,type:"bool",defaultValue:!1})],Ve.prototype,"isHardware",void 0),ot([p({id:Te.INDEX++,type:"string"})],Ve.prototype,"card",void 0),ot([p({id:Te.INDEX++,parser:$e})],Ve.prototype,"token",void 0),Ve=Te=ot([w({})],Ve);let Je=Ke=class extends gt{constructor(){super(...arguments),this.name="",this.providers=[]}};Je.INDEX=gt.INDEX,ot([p({id:Ke.INDEX++,type:"string",required:!0})],Je.prototype,"name",void 0),ot([p({id:Ke.INDEX++,repeated:!0,parser:Ve})],Je.prototype,"providers",void 0),Je=Ke=ot([w({})],Je);let Me=class extends bt{};Me.INDEX=bt.INDEX,Me.ACTION="provider/action/info",Me=ot([w({})],Me);let He=De=class extends bt{constructor(){super(...arguments),this.cryptoID=""}};He.INDEX=bt.INDEX,He.ACTION="provider/action/getCrypto",ot([p({id:De.INDEX++,required:!0,type:"string"})],He.prototype,"cryptoID",void 0),He=De=ot([w({})],He);let _e=class extends bt{};_e.INDEX=bt.INDEX,_e.ACTION="provider/event/authorized",_e=ot([w({})],_e);let We=je=class extends bt{constructor(t){super(),this.added=[],this.removed=[],t&&h(this,t)}};var Le,ze,Ge,Fe,Ze,Xe,Qe,Ye,tr,er;We.INDEX=bt.INDEX,We.ACTION="provider/event/token",ot([p({id:je.INDEX++,repeated:!0,parser:Ve})],We.prototype,"added",void 0),ot([p({id:je.INDEX++,repeated:!0,parser:Ve})],We.prototype,"removed",void 0),ot([p({id:je.INDEX++,type:"bytes",parser:xt})],We.prototype,"error",void 0),We=je=ot([w({name:"ProviderTokenEvent"})],We);let rr=Le=class extends Pt{constructor(){super(...arguments),this.algorithm=new Bt,this.data=new ArrayBuffer(0)}};rr.INDEX=Pt.INDEX,rr.ACTION="crypto/subtle/digest",ot([p({id:Le.INDEX++,required:!0,parser:Bt})],rr.prototype,"algorithm",void 0),ot([p({id:Le.INDEX++,required:!0,converter:y})],rr.prototype,"data",void 0),rr=Le=ot([w({})],rr);let ir=ze=class extends Pt{constructor(){super(...arguments),this.algorithm=new Bt,this.extractable=!1,this.usage=[]}};ir.INDEX=Pt.INDEX,ir.ACTION="crypto/subtle/generateKey",ot([p({id:ze.INDEX++,type:"bytes",required:!0,parser:Bt})],ir.prototype,"algorithm",void 0),ot([p({id:ze.INDEX++,type:"bool",required:!0})],ir.prototype,"extractable",void 0),ot([p({id:ze.INDEX++,type:"string",repeated:!0})],ir.prototype,"usage",void 0),ir=ze=ot([w({})],ir);let sr=Ge=class extends Pt{constructor(){super(...arguments),this.algorithm=new Bt,this.key=new kt,this.data=new ArrayBuffer(0)}};sr.INDEX=Pt.INDEX,sr.ACTION="crypto/subtle/sign",ot([p({id:Ge.INDEX++,required:!0,parser:Bt})],sr.prototype,"algorithm",void 0),ot([p({id:Ge.INDEX++,required:!0,parser:kt})],sr.prototype,"key",void 0),ot([p({id:Ge.INDEX++,required:!0,converter:y})],sr.prototype,"data",void 0),sr=Ge=ot([w({})],sr);let nr=Fe=class extends sr{constructor(){super(...arguments),this.signature=new ArrayBuffer(0)}};nr.INDEX=sr.INDEX,nr.ACTION="crypto/subtle/verify",ot([p({id:Fe.INDEX++,required:!0,converter:y})],nr.prototype,"signature",void 0),nr=Fe=ot([w({})],nr);let or=class extends sr{};or.INDEX=sr.INDEX,or.ACTION="crypto/subtle/encrypt",or=ot([w({})],or);let ar=class extends sr{};ar.INDEX=sr.INDEX,ar.ACTION="crypto/subtle/decrypt",ar=ot([w({})],ar);let cr=Ze=class extends Pt{constructor(){super(...arguments),this.algorithm=new Bt,this.key=new kt,this.length=0}};cr.INDEX=Pt.INDEX,cr.ACTION="crypto/subtle/deriveBits",ot([p({id:Ze.INDEX++,required:!0,parser:Bt})],cr.prototype,"algorithm",void 0),ot([p({id:Ze.INDEX++,required:!0,parser:kt})],cr.prototype,"key",void 0),ot([p({id:Ze.INDEX++,required:!0,type:"uint32"})],cr.prototype,"length",void 0),cr=Ze=ot([w({})],cr);let ur=Xe=class extends Pt{constructor(){super(...arguments),this.algorithm=new Bt,this.key=new kt,this.derivedKeyType=new Bt,this.extractable=!1,this.usage=[]}};ur.INDEX=Pt.INDEX,ur.ACTION="crypto/subtle/deriveKey",ot([p({id:Xe.INDEX++,required:!0,parser:Bt})],ur.prototype,"algorithm",void 0),ot([p({id:Xe.INDEX++,required:!0,parser:kt})],ur.prototype,"key",void 0),ot([p({id:Xe.INDEX++,required:!0,parser:Bt})],ur.prototype,"derivedKeyType",void 0),ot([p({id:Xe.INDEX++,type:"bool"})],ur.prototype,"extractable",void 0),ot([p({id:Xe.INDEX++,type:"string",repeated:!0})],ur.prototype,"usage",void 0),ur=Xe=ot([w({})],ur);let hr=Qe=class extends Pt{constructor(){super(...arguments),this.format="",this.wrappedKey=new ArrayBuffer(0),this.unwrappingKey=new kt,this.unwrapAlgorithm=new Bt,this.unwrappedKeyAlgorithm=new Bt,this.extractable=!1,this.keyUsage=[]}};hr.INDEX=Pt.INDEX,hr.ACTION="crypto/subtle/unwrapKey",ot([p({id:Qe.INDEX++,required:!0,type:"string"})],hr.prototype,"format",void 0),ot([p({id:Qe.INDEX++,required:!0,converter:y})],hr.prototype,"wrappedKey",void 0),ot([p({id:Qe.INDEX++,required:!0,parser:kt})],hr.prototype,"unwrappingKey",void 0),ot([p({id:Qe.INDEX++,required:!0,parser:Bt})],hr.prototype,"unwrapAlgorithm",void 0),ot([p({id:Qe.INDEX++,required:!0,parser:Bt})],hr.prototype,"unwrappedKeyAlgorithm",void 0),ot([p({id:Qe.INDEX++,type:"bool"})],hr.prototype,"extractable",void 0),ot([p({id:Qe.INDEX++,type:"string",repeated:!0})],hr.prototype,"keyUsage",void 0),hr=Qe=ot([w({})],hr);let fr=Ye=class extends Pt{constructor(){super(...arguments),this.format="",this.key=new kt,this.wrappingKey=new kt,this.wrapAlgorithm=new Bt}};fr.INDEX=Pt.INDEX,fr.ACTION="crypto/subtle/wrapKey",ot([p({id:Ye.INDEX++,required:!0,type:"string"})],fr.prototype,"format",void 0),ot([p({id:Ye.INDEX++,required:!0,parser:kt})],fr.prototype,"key",void 0),ot([p({id:Ye.INDEX++,required:!0,parser:kt})],fr.prototype,"wrappingKey",void 0),ot([p({id:Ye.INDEX++,required:!0,parser:Bt})],fr.prototype,"wrapAlgorithm",void 0),fr=Ye=ot([w({})],fr);let lr=tr=class extends Pt{constructor(){super(...arguments),this.format="",this.key=new kt}};lr.INDEX=Pt.INDEX,lr.ACTION="crypto/subtle/exportKey",ot([p({id:tr.INDEX++,type:"string",required:!0})],lr.prototype,"format",void 0),ot([p({id:tr.INDEX++,required:!0,parser:kt})],lr.prototype,"key",void 0),lr=tr=ot([w({})],lr);let dr=er=class extends Pt{constructor(){super(...arguments),this.format="",this.keyData=new ArrayBuffer(0),this.algorithm=new Bt,this.extractable=!1,this.keyUsages=[]}};dr.INDEX=Pt.INDEX,dr.ACTION="crypto/subtle/importKey",ot([p({id:er.INDEX++,type:"string",required:!0})],dr.prototype,"format",void 0),ot([p({id:er.INDEX++,required:!0,converter:y})],dr.prototype,"keyData",void 0),ot([p({id:er.INDEX++,required:!0,parser:Bt})],dr.prototype,"algorithm",void 0),ot([p({id:er.INDEX++,required:!0,type:"bool"})],dr.prototype,"extractable",void 0),ot([p({id:er.INDEX++,type:"string",repeated:!0})],dr.prototype,"keyUsages",void 0),dr=er=ot([w({})],dr);class yr extends g{constructor(t){super(),this.client=t,this.onEvent=this.onEvent.bind(this),this.client.on("listening",()=>{this.client.on("event",this.onEvent)}).on("close",()=>{this.client.removeListener("event",this.onEvent)})}async readers(){const t=await this.client.send(new Rt);return JSON.parse(u.ToString(t))}on(t,e){return super.on(t,e)}emit(t,...e){return super.emit(t,...e)}onEvent(t){(async()=>{switch(t.action){case Kt.ACTION:this.onInsert(await Kt.importProto(t));break;case Dt.ACTION:this.onRemove(await Dt.importProto(t))}})().catch(t=>this.emit("error",t))}onInsert(t){this.emit("insert",t)}onRemove(t){this.emit("remove",t)}}class wr extends Error{constructor(t){super(t.message),this.name="CryptoServerError",this.code=t.code,this.type=t.type}}class pr extends class{constructor(t,e){this.target=t,this.event=e}}{}class vr extends pr{constructor(t,e,r,i){super(t,"close"),this.remoteAddress=e,this.reasonCode=r,this.description=i}}class mr extends pr{constructor(t,e){super(t,"error"),this.error=e}}class gr extends pr{constructor(t,e){super(t,"listening"),this.address=e}}function br(){return/firefox\/([\w\.-]+)$/i.test(self.navigator.userAgent)}function Ar(){return/(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i.test(self.navigator.userAgent)}function Br(){return/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i.test(self.navigator.userAgent)}const Sr={name:"ECDH",namedCurve:"P-256"},kr={name:"ECDSA",namedCurve:"P-256"},Er={name:"AES-CBC",iv:new ArrayBuffer(16)};async function xr(t,e){const r=await async function(t){const e=t.algorithm.name.toUpperCase();if("ECDH"!==e&&"ECDSA"!==e)throw new Error("Error: Unsupported asymmetric key algorithm.");if("public"!==t.type)throw new Error("Error: Expected key type to be public but it was not.");const r=await T().crypto.subtle.exportKey("jwk",t);if(!r.x||!r.y)throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const i=u.FromBase64Url(r.x),s=u.FromBase64Url(r.y),n=u.ToBinary(i)+u.ToBinary(s),o=t,a=u.FromBinary(n);return{id:u.ToHex(await T().crypto.subtle.digest("SHA-256",a)),key:o,serialized:a}}(e);t.id=r.id,t.key=r.key,t.serialized=r.serialized}var Nr;!function(t){t[t.connecting=0]="connecting",t[t.open=1]="open",t[t.closing=2]="closing",t[t.closed=3]="closed"}(Nr||(Nr={}));class Ur extends g{constructor(t){super(),this.stack={},this.messageCounter=0,this.storage=t}get state(){return this.socket?this.socket.readyState:Nr.closed}connect(t,e){return this.getServerInfo(t).then(r=>{const[i,s,n]=r.version.split(".").map(t=>parseInt(t,10));if(i<1||1===i&&s<2)throw new Error(`Current version of WebCryptoSocket doesn't work with WebCryptoServer v${r.version}. Please update your client to the latest version.`);this.serviceInfo=r;const a="wss://"+t;this.socket=e?new o.default(a,void 0,e):new o.default(a),this.socket.binaryType="arraybuffer",this.socket.onerror=t=>{this.emit("error",new mr(this,t.error))},this.socket.onopen=()=>{(async()=>{let e=await this.storage.loadIdentity();e||(e=await $.create(1,0,0,Br()||Ar()||br()),await this.storage.saveIdentity(e));const i=await X.importProto(u.FromBase64(r.preKey));this.cipher=await it.create(e,i),await this.storage.saveRemoteIdentity("0",this.cipher.remoteIdentity),this.emit("listening",new gr(this,t))})().catch(t=>this.emit("error",new mr(this,t)))},this.socket.onclose=e=>{for(const t in this.stack)this.stack[t].reject(new Error("Cannot finish operation. Session was closed"));this.emit("close",new vr(this,t,e.code,e.reason))},this.socket.onmessage=t=>{t.data instanceof ArrayBuffer&&z.importProto(t.data).then(t=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.decrypt(t)}).then(t=>{this.onMessage(t)}).catch(t=>{this.emit("error",new mr(this,t))})}}).catch(t=>{this.emit("error",new mr(this,t))}),this}close(){this.socket&&this.socket.close()}on(t,e){return super.on(t,e)}once(t,e){return super.once(t,e)}async challenge(){if(!this.cipher)throw new Error("Client cipher is not initialized");return async function(t,e){const r=await t.thumbprint(),i=await e.thumbprint(),s=u.FromHex(r+i),n=await T().crypto.subtle.digest("SHA-256",s);return parseInt(u.ToHex(n),16).toString().substr(2,6)}(this.cipher.remoteIdentity.signingKey,this.cipher.identity.signingKey.publicKey)}async isLoggedIn(){const t=new Ct,e=await this.send(t);return!!e&&!!new Uint8Array(e)[0]}async login(){const t=new It;await this.send(t)}send(t){return new Promise((e,r)=>{this.checkSocketState(),t||(t=new bt),t.action=t.action,t.actionId=(this.messageCounter++).toString(),t.exportProto().then(t=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.encrypt(t).then(t=>t.exportProto())}).then(i=>{if(!this.socket)throw new Error("Client socket is not initialized");this.stack[t.actionId]={resolve:e,reject:r},this.socket.send(i)}).catch(r)})}async getServerInfo(t){const e=`https://${t}/.well-known/webcrypto-socket`,r=await n.default(e);if(200!==r.status)throw new Error("Cannot get wellknown link");return await r.json()}checkSocketState(){if(this.state!==Nr.open)throw new Error("Socket connection is not open")}async onMessage(t){const e=await bt.importProto(t),r=this.stack[e.actionId];if(r){delete this.stack[e.actionId];const t=await Nt.importProto(await e.exportProto());if(t.error&&t.error.message){const e=new wr(t.error);r.reject(e)}else r.resolve(t.data)}else this.emit("event",e)}}function Ir(t,e){return t(e={exports:{}},e.exports),e.exports}function Cr(t,e){let r=0;if(1===t.length)return t[0];for(let i=t.length-1;i>=0;i--)r+=t[t.length-1-i]*Math.pow(2,e*i);return r}function qr(t,e,r=-1){const i=r;let s=t,n=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(t<o){let t;if(i<0)t=new ArrayBuffer(a),n=a;else{if(i<a)return new ArrayBuffer(0);t=new ArrayBuffer(i),n=i}const r=new Uint8Array(t);for(let i=a-1;i>=0;i--){const t=Math.pow(2,i*e);r[n-i-1]=Math.floor(s/t),s-=r[n-i-1]*t}return t}o*=Math.pow(2,e)}return new ArrayBuffer(0)}const Or="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",Rr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",Tr=Math.log(2);var Kr,Dr,jr,Pr=Object.freeze({__proto__:null,getUTCDate:function(t){return new Date(t.getTime()+6e4*t.getTimezoneOffset())},getParametersValue:function(t,e,r){return t instanceof Object==0?r:e in t?t[e]:r},bufferToHexCodes:function(t,e=0,r=t.byteLength-e,i=!1){let s="";for(const n of new Uint8Array(t,e,r)){const t=n.toString(16).toUpperCase();1===t.length&&(s+="0"),s+=t,i&&(s+=" ")}return s.trim()},checkBufferParams:function(t,e,r,i){return e instanceof ArrayBuffer==0?(t.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===e.byteLength?(t.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(t.error="Wrong parameter: inputOffset less than zero",!1):i<0?(t.error="Wrong parameter: inputLength less than zero",!1):!(e.byteLength-r-i<0&&(t.error="End of input reached before message was fully decoded (inconsistent offset and length values)",1))},utilFromBase:Cr,utilToBase:qr,utilConcatBuf:function(...t){let e=0,r=0;for(const n of t)e+=n.byteLength;const i=new ArrayBuffer(e),s=new Uint8Array(i);for(const n of t)s.set(new Uint8Array(n),r),r+=n.byteLength;return i},utilConcatView:function(...t){let e=0,r=0;for(const n of t)e+=n.length;const i=new ArrayBuffer(e),s=new Uint8Array(i);for(const n of t)s.set(n,r),r+=n.length;return s},utilDecodeTC:function(){const t=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const e=0===t[0]&&0==(128&t[1]);(255===t[0]&&128&t[1]||e)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(e);for(let o=0;o<this.valueHex.byteLength;o++)r[o]=0;r[0]=128&t[0];const i=Cr(r,8),s=new ArrayBuffer(this.valueHex.byteLength),n=new Uint8Array(s);for(let o=0;o<this.valueHex.byteLength;o++)n[o]=t[o];return n[0]&=127,Cr(n,8)-i},utilEncodeTC:function(t){const e=t<0?-1*t:t;let r=128;for(let i=1;i<8;i++){if(e<=r){if(t<0){const t=qr(r-e,8,i);return new Uint8Array(t)[0]|=128,t}let s=qr(e,8,i),n=new Uint8Array(s);if(128&n[0]){const t=s.slice(0),e=new Uint8Array(t);s=new ArrayBuffer(s.byteLength+1),n=new Uint8Array(s);for(let r=0;r<t.byteLength;r++)n[r+1]=e[r];n[0]=0}return s}r*=Math.pow(2,8)}return new ArrayBuffer(0)},isEqualBuffer:function(t,e){if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),i=new Uint8Array(e);for(let s=0;s<r.length;s++)if(r[s]!==i[s])return!1;return!0},padNumber:function(t,e){const r=t.toString(10);if(e<r.length)return"";const i=e-r.length,s=new Array(i);for(let n=0;n<i;n++)s[n]="0";return s.join("").concat(r)},toBase64:function(t,e=!1,r=!1,i=!1){let s=0,n=0,o=0,a="";const c=e?Rr:Or;if(i){let e=0;for(let r=0;r<t.length;r++)if(0!==t.charCodeAt(r)){e=r;break}t=t.slice(e)}for(;s<t.length;){const e=t.charCodeAt(s++);s>=t.length&&(n=1);const i=t.charCodeAt(s++);s>=t.length&&(o=1);const u=t.charCodeAt(s++),h=e>>2,f=(3&e)<<4|i>>4;let l=(15&i)<<2|u>>6,d=63&u;1===n?l=d=64:1===o&&(d=64),a+=r?64===l?`${c.charAt(h)}${c.charAt(f)}`:64===d?`${c.charAt(h)}${c.charAt(f)}${c.charAt(l)}`:`${c.charAt(h)}${c.charAt(f)}${c.charAt(l)}${c.charAt(d)}`:`${c.charAt(h)}${c.charAt(f)}${c.charAt(l)}${c.charAt(d)}`}return a},fromBase64:function(t,e=!1,r=!1){const i=e?Rr:Or;function s(t){for(let e=0;e<64;e++)if(i.charAt(e)===t)return e;return 64}function n(t){return 64===t?0:t}let o=0,a="";for(;o<t.length;){const e=s(t.charAt(o++)),r=o>=t.length?0:s(t.charAt(o++)),i=o>=t.length?0:s(t.charAt(o++)),c=o>=t.length?0:s(t.charAt(o++)),u=n(e)<<2|n(r)>>4,h=(15&n(r))<<4|n(i)>>2,f=(3&n(i))<<6|n(c);a+=String.fromCharCode(u),64!==i&&(a+=String.fromCharCode(h)),64!==c&&(a+=String.fromCharCode(f))}if(r){let t=-1;for(let e=a.length-1;e>=0;e--)if(0!==a.charCodeAt(e)){t=e;break}a=-1!==t?a.slice(0,t+1):""}return a},arrayBufferToString:function(t){let e="";const r=new Uint8Array(t);for(const i of r)e+=String.fromCharCode(i);return e},stringToArrayBuffer:function(t){const e=t.length,r=new ArrayBuffer(e),i=new Uint8Array(r);for(let s=0;s<e;s++)i[s]=t.charCodeAt(s);return r},nearestPowerOf2:function(t){const e=Math.log(t)/Tr,r=Math.floor(e),i=Math.round(e);return r===i?r:i},clearProps:function(t,e){for(const r of e)delete t[r]}}),$r=Ir((function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.fromBER=at,e.compareSchema=ct,e.verifySchema=function(t,e){if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const r=at(t);return-1===r.offset?{verified:!1,result:r.result}:ct(r.result,r.result,e)},e.fromJSON=function(){},e.RawData=e.Repeated=e.Any=e.Choice=e.TIME=e.Duration=e.DateTime=e.TimeOfDay=e.DATE=e.GeneralizedTime=e.UTCTime=e.CharacterString=e.GeneralString=e.VisibleString=e.GraphicString=e.IA5String=e.VideotexString=e.TeletexString=e.PrintableString=e.NumericString=e.UniversalString=e.BmpString=e.RelativeObjectIdentifier=e.Utf8String=e.ObjectIdentifier=e.Enumerated=e.Integer=e.BitString=e.OctetString=e.Null=e.Set=e.Sequence=e.Boolean=e.EndOfContent=e.Constructed=e.Primitive=e.BaseBlock=e.ValueBlock=e.HexBlock=void 0;const r=[new Uint8Array([1])];class i{constructor(t={}){this.blockLength=(0,Pr.getParametersValue)(t,"blockLength",0),this.error=(0,Pr.getParametersValue)(t,"error",""),this.warnings=(0,Pr.getParametersValue)(t,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in t?t.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:(0,Pr.bufferToHexCodes)(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const s=t=>class extends t{constructor(t={}){super(t),this.isHexOnly=(0,Pr.getParametersValue)(t,"isHexOnly",!1),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(t,e,r){return!1===(0,Pr.checkBufferParams)(this,t,e,r)?-1:0===new Uint8Array(t,e,r).length?(this.warnings.push("Zero buffer length"),e):(this.valueHex=t.slice(e,e+r),this.blockLength=r,e+r)}toBER(t=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===t?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isHexOnly=this.isHexOnly,t.valueHex=(0,Pr.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}};e.HexBlock=s;class n extends(s(i)){constructor(t={}){super(),"idBlock"in t?(this.isHexOnly=(0,Pr.getParametersValue)(t.idBlock,"isHexOnly",!1),this.valueHex=(0,Pr.getParametersValue)(t.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=(0,Pr.getParametersValue)(t.idBlock,"tagClass",-1),this.tagNumber=(0,Pr.getParametersValue)(t.idBlock,"tagNumber",-1),this.isConstructed=(0,Pr.getParametersValue)(t.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(t=!1){let e,r,i=0;switch(this.tagClass){case 1:i|=0;break;case 2:i|=64;break;case 3:i|=128;break;case 4:i|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(i|=32),this.tagNumber<31&&!this.isHexOnly){if(e=new ArrayBuffer(1),r=new Uint8Array(e),!t){let t=this.tagNumber;t&=31,i|=t,r[0]=i}return e}if(!1===this.isHexOnly){const s=(0,Pr.utilToBase)(this.tagNumber,7),n=new Uint8Array(s),o=s.byteLength;if(e=new ArrayBuffer(o+1),r=new Uint8Array(e),r[0]=31|i,!t){for(let t=0;t<o-1;t++)r[t+1]=128|n[t];r[o]=n[o-1]}return e}if(e=new ArrayBuffer(this.valueHex.byteLength+1),r=new Uint8Array(e),r[0]=31|i,!1===t){const t=new Uint8Array(this.valueHex);for(let e=0;e<t.length-1;e++)r[e+1]=128|t[e];r[this.valueHex.byteLength]=t[t.length-1]}return e}fromBER(t,e,r){if(!1===(0,Pr.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);if(0===i.length)return this.error="Zero buffer length",-1;switch(192&i[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&i[0]),this.isHexOnly=!1;const s=31&i[0];if(31!==s)this.tagNumber=s,this.blockLength=1;else{let t=1;this.valueHex=new ArrayBuffer(255);let e=255,r=new Uint8Array(this.valueHex);for(;128&i[t];){if(r[t-1]=127&i[t],t++,t>=i.length)return this.error="End of input reached before message was fully decoded",-1;if(t===e){e+=255;const t=new ArrayBuffer(e),i=new Uint8Array(t);for(let e=0;e<r.length;e++)i[e]=r[e];this.valueHex=new ArrayBuffer(e),r=new Uint8Array(this.valueHex)}}this.blockLength=t+1,r[t-1]=127&i[t];const s=new ArrayBuffer(t),n=new Uint8Array(s);for(let i=0;i<t;i++)n[i]=r[i];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex),r.set(n),this.blockLength<=9?this.tagNumber=(0,Pr.utilFromBase)(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.tagClass=this.tagClass,t.tagNumber=this.tagNumber,t.isConstructed=this.isConstructed,t}}class o extends i{constructor(t={}){super(),"lenBlock"in t?(this.isIndefiniteForm=(0,Pr.getParametersValue)(t.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=(0,Pr.getParametersValue)(t.lenBlock,"longFormUsed",!1),this.length=(0,Pr.getParametersValue)(t.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(t,e,r){if(!1===(0,Pr.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);if(0===i.length)return this.error="Zero buffer length",-1;if(255===i[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===i[0],!0===this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(128&i[0]),!1===this.longFormUsed)return this.length=i[0],this.blockLength=1,e+this.blockLength;const s=127&i[0];if(s>8)return this.error="Too big integer",-1;if(s+1>i.length)return this.error="End of input reached before message was fully decoded",-1;const n=new Uint8Array(s);for(let o=0;o<s;o++)n[o]=i[o+1];return 0===n[s-1]&&this.warnings.push("Needlessly long encoded length"),this.length=(0,Pr.utilFromBase)(n,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unneccesary usage of long length form"),this.blockLength=s+1,e+this.blockLength}toBER(t=!1){let e,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=128),e;if(!0===this.longFormUsed){const i=(0,Pr.utilToBase)(this.length,8);if(i.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(e=new ArrayBuffer(i.byteLength+1),!0===t)return e;const s=new Uint8Array(i);r=new Uint8Array(e),r[0]=128|i.byteLength;for(let t=0;t<i.byteLength;t++)r[t+1]=s[t];return e}return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=this.length),e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isIndefiniteForm=this.isIndefiniteForm,t.longFormUsed=this.longFormUsed,t.length=this.length,t}}class a extends i{constructor(t={}){super(t)}static blockName(){return"valueBlock"}fromBER(t,e,r){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}toBER(t=!1){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}}e.ValueBlock=a;class c extends i{constructor(t={},e=a){super(t),"name"in t&&(this.name=t.name),"optional"in t&&(this.optional=t.optional),"primitiveSchema"in t&&(this.primitiveSchema=t.primitiveSchema),this.idBlock=new n(t),this.lenBlock=new o(t),this.valueBlock=new e(t)}static blockName(){return"BaseBlock"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}toBER(t=!1){let e;const r=this.idBlock.toBER(t),i=this.valueBlock.toBER(!0);this.lenBlock.length=i.byteLength;const s=this.lenBlock.toBER(t);let n;if(e=(0,Pr.utilConcatBuf)(r,s),n=!1===t?this.valueBlock.toBER(t):new ArrayBuffer(this.lenBlock.length),e=(0,Pr.utilConcatBuf)(e,n),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===t){const t=new Uint8Array(r);t[0]=0,t[1]=0}e=(0,Pr.utilConcatBuf)(e,r)}return e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.idBlock=this.idBlock.toJSON(),t.lenBlock=this.lenBlock.toJSON(),t.valueBlock=this.valueBlock.toJSON(),"name"in this&&(t.name=this.name),"optional"in this&&(t.optional=this.optional),"primitiveSchema"in this&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}}e.BaseBlock=c;class u extends a{constructor(t={}){super(t),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=(0,Pr.getParametersValue)(t,"isHexOnly",!0)}fromBER(t,e,r){if(!1===(0,Pr.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);if(0===i.length)return this.warnings.push("Zero buffer length"),e;this.valueHex=new ArrayBuffer(i.length);const s=new Uint8Array(this.valueHex);for(let n=0;n<i.length;n++)s[n]=i[n];return this.blockLength=r,e+r}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueHex=(0,Pr.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t.isHexOnly=this.isHexOnly,t}}class h extends c{constructor(t={}){super(t,u),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}e.Primitive=h;class f extends a{constructor(t={}){super(t),this.value=(0,Pr.getParametersValue)(t,"value",[]),this.isIndefiniteForm=(0,Pr.getParametersValue)(t,"isIndefiniteForm",!1)}fromBER(t,e,r){const i=e,s=r;if(!1===(0,Pr.checkBufferParams)(this,t,e,r))return-1;if(0===new Uint8Array(t,e,r).length)return this.warnings.push("Zero buffer length"),e;let n=e;for(;(!0===this.isIndefiniteForm?1:r)>0;){const e=ot(t,n,r);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(n=e.offset,this.blockLength+=e.result.blockLength,r-=e.result.blockLength,this.value.push(e.result),!0===this.isIndefiniteForm&&e.result.constructor.blockName()===y.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===y.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=t.slice(i,i+s),n}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const i=this.value[r].toBER(t);e=(0,Pr.utilConcatBuf)(e,i)}return e}static blockName(){return"ConstructedValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.isIndefiniteForm=this.isIndefiniteForm,t.value=[];for(let r=0;r<this.value.length;r++)t.value.push(this.value[r].toJSON());return t}}class l extends c{constructor(t={}){super(t,f),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(t,e,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}}e.Constructed=l;class d extends a{constructor(t={}){super(t)}fromBER(t,e,r){return e}toBER(t=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class y extends c{constructor(t={}){super(t,d),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}e.EndOfContent=y;class w extends a{constructor(t={}){super(t),this.value=(0,Pr.getParametersValue)(t,"value",!1),this.isHexOnly=(0,Pr.getParametersValue)(t,"isHexOnly",!1),"valueHex"in t?this.valueHex=t.valueHex.slice(0):(this.valueHex=new ArrayBuffer(1),!0===this.value&&(new Uint8Array(this.valueHex)[0]=255))}fromBER(t,e,r){if(!1===(0,Pr.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(i.length);const s=new Uint8Array(this.valueHex);for(let n=0;n<i.length;n++)s[n]=i[n];return this.value=0!==Pr.utilDecodeTC.call(this),this.blockLength=r,e+r}toBER(t=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t.isHexOnly=this.isHexOnly,t.valueHex=(0,Pr.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class p extends c{constructor(t={}){super(t,w),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"Boolean"}}e.Boolean=p;class v extends l{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"Sequence"}}e.Sequence=v;class m extends l{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"Set"}}e.Set=m;class g extends c{constructor(t={}){super(t,i),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"Null"}fromBER(t,e,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,e+r>t.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):e+r}toBER(t=!1){const e=new ArrayBuffer(2);if(!0===t)return e;const r=new Uint8Array(e);return r[0]=5,r[1]=0,e}}e.Null=g;class b extends(s(f)){constructor(t={}){super(t),this.isConstructed=(0,Pr.getParametersValue)(t,"isConstructed",!1)}fromBER(t,e,r){let i=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,i=f.prototype.fromBER.call(this,t,e,r),-1===i)return i;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===y.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(e!==A.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,i=super.fromBER(t,e,r),this.blockLength=r;return i}toBER(t=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,t);let e=new ArrayBuffer(this.valueHex.byteLength);return!0===t||0===this.valueHex.byteLength||(e=this.valueHex.slice(0)),e}static blockName(){return"OctetStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=(0,Pr.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class A extends c{constructor(t={}){super(t,b),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(t,e,r){return this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r?(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),e):super.fromBER(t,e,r)}static blockName(){return"OctetString"}isEqual(t){return t instanceof A!=0&&JSON.stringify(this)===JSON.stringify(t)}}e.OctetString=A;class B extends(s(f)){constructor(t={}){super(t),this.unusedBits=(0,Pr.getParametersValue)(t,"unusedBits",0),this.isConstructed=(0,Pr.getParametersValue)(t,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(t,e,r){if(0===r)return e;let i=-1;if(!0===this.isConstructed){if(i=f.prototype.fromBER.call(this,t,e,r),-1===i)return i;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===y.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(e!==S.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[t].valueBlock.unusedBits>0)return this.error='Usign of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[t].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return i}if(!1===(0,Pr.checkBufferParams)(this,t,e,r))return-1;const s=new Uint8Array(t,e,r);if(this.unusedBits=s[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;this.valueHex=new ArrayBuffer(s.length-1);const n=new Uint8Array(this.valueHex);for(let o=0;o<r-1;o++)n[o]=s[o+1];return this.blockLength=s.length,e+r}toBER(t=!1){if(!0===this.isConstructed)return f.prototype.toBER.call(this,t);if(!0===t)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const e=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),i=new Uint8Array(r);i[0]=this.unusedBits;for(let s=0;s<this.valueHex.byteLength;s++)i[s+1]=e[s];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.unusedBits=this.unusedBits,t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=(0,Pr.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength),t}}class S extends c{constructor(t={}){super(t,B),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BitString"}fromBER(t,e,r){return 0===r?e:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(t,e,r))}isEqual(t){return t instanceof S!=0&&JSON.stringify(this)===JSON.stringify(t)}}e.BitString=S;class k extends(s(a)){constructor(t={}){super(t),"value"in t&&(this.valueDec=t.value)}set valueHex(t){this._valueHex=t.slice(0),t.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,t.byteLength>0&&(this._valueDec=Pr.utilDecodeTC.call(this)))}get valueHex(){return this._valueHex}set valueDec(t){this._valueDec=t,this.isHexOnly=!1,this._valueHex=(0,Pr.utilEncodeTC)(t)}get valueDec(){return this._valueDec}fromDER(t,e,r,i=0){const s=this.fromBER(t,e,r);if(-1===s)return s;const n=new Uint8Array(this._valueHex);if(0===n[0]&&0!=(128&n[1])){const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}else if(0!==i&&this._valueHex.byteLength<i){i-this._valueHex.byteLength>1&&(i=this._valueHex.byteLength+1);const t=new ArrayBuffer(i);new Uint8Array(t).set(n,i-this._valueHex.byteLength),this._valueHex=t.slice(0)}return s}toDER(t=!1){const e=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&e[0]):{const t=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(t);r[0]=0,r.set(e,1),this._valueHex=t.slice(0)}break;case 0===e[0]&&0==(128&e[1]):{const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}}return this.toBER(t)}fromBER(t,e,r){const i=super.fromBER(t,e,r);return-1===i?i:(this.blockLength=r,e+r)}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}toString(){function t(t,e){const r=new Uint8Array([0]);let i=new Uint8Array(t),s=new Uint8Array(e),n=i.slice(0);const o=n.length-1;let a=s.slice(0);const c=a.length-1;let u=0,h=0;for(let f=c<o?o:c;f>=0;f--,h++){switch(!0){case h<a.length:u=n[o-h]+a[c-h]+r[0];break;default:u=n[o-h]+r[0]}switch(r[0]=u/10,!0){case h>=n.length:n=(0,Pr.utilConcatView)(new Uint8Array([u%10]),n);break;default:n[o-h]=u%10}}return r[0]>0&&(n=(0,Pr.utilConcatView)(r,n)),n.slice(0)}function e(t){if(t>=r.length)for(let e=r.length;e<=t;e++){const t=new Uint8Array([0]);let i=r[e-1].slice(0);for(let e=i.length-1;e>=0;e--){const r=new Uint8Array([(i[e]<<1)+t[0]]);t[0]=r[0]/10,i[e]=r[0]%10}t[0]>0&&(i=(0,Pr.utilConcatView)(t,i)),r.push(i)}return r[t]}function i(t,e){let r=0,i=new Uint8Array(t),s=new Uint8Array(e),n=i.slice(0);const o=n.length-1;let a=s.slice(0);const c=a.length-1;let u,h=0;for(let f=c;f>=0;f--,h++)switch(u=n[o-h]-a[c-h]-r,!0){case u<0:r=1,n[o-h]=u+10;break;default:r=0,n[o-h]=u}if(r>0)for(let f=o-c+1;f>=0;f--,h++){if(u=n[o-h]-r,!(u<0)){r=0,n[o-h]=u;break}r=1,n[o-h]=u+10}return n.slice()}const s=8*this._valueHex.byteLength-1;let n,o=new Uint8Array(8*this._valueHex.byteLength/3),a=0;const c=new Uint8Array(this._valueHex);let u="",h=!1;for(let r=this._valueHex.byteLength-1;r>=0;r--){n=c[r];for(let r=0;r<8;r++){if(1==(1&n))switch(a){case s:o=i(e(a),o),u="-";break;default:o=t(o,e(a))}a++,n>>=1}}for(let r=0;r<o.length;r++)o[r]&&(h=!0),h&&(u+="0123456789".charAt(o[r]));return!1===h&&(u+="0123456789".charAt(0)),u}}class E extends c{constructor(t={}){super(t,k),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"Integer"}isEqual(t){return t instanceof E?this.valueBlock.isHexOnly&&t.valueBlock.isHexOnly?(0,Pr.isEqualBuffer)(this.valueBlock.valueHex,t.valueBlock.valueHex):this.valueBlock.isHexOnly===t.valueBlock.isHexOnly&&this.valueBlock.valueDec===t.valueBlock.valueDec:t instanceof ArrayBuffer&&(0,Pr.isEqualBuffer)(this.valueBlock.valueHex,t)}convertToDER(){const t=new E({valueHex:this.valueBlock.valueHex});return t.valueBlock.toDER(),t}convertFromDER(){const t=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,e=new E({valueHex:this.valueBlock.valueHex});return e.valueBlock.fromDER(e.valueBlock.valueHex,0,e.valueBlock.valueHex.byteLength,t),e}}e.Integer=E;class x extends E{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"Enumerated"}}e.Enumerated=x;class N extends(s(i)){constructor(t={}){super(t),this.valueDec=(0,Pr.getParametersValue)(t,"valueDec",-1),this.isFirstSid=(0,Pr.getParametersValue)(t,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===(0,Pr.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let s=new Uint8Array(this.valueHex);for(let a=0;a<r&&(s[a]=127&i[a],this.blockLength++,0!=(128&i[a]));a++);const n=new ArrayBuffer(this.blockLength),o=new Uint8Array(n);for(let a=0;a<this.blockLength;a++)o[a]=s[a];return this.valueHex=n.slice(0),s=new Uint8Array(this.valueHex),0!=(128&i[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===s[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,Pr.utilFromBase)(s,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const i=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|i[t];return r[this.blockLength-1]=i[this.blockLength-1],e}const i=(0,Pr.utilToBase)(this.valueDec,7);if(0===i.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(i.byteLength),!1===t){const t=new Uint8Array(i);r=new Uint8Array(e);for(let e=0;e<i.byteLength-1;e++)r[e]=128|t[e];r[i.byteLength-1]=t[i.byteLength-1]}return e}toString(){let t="";if(!0===this.isHexOnly)t=(0,Pr.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let e=this.valueDec;this.valueDec<=39?t="0.":this.valueDec<=79?(t="1.",e-=40):(t="2.",e-=80),t+=e.toString()}else t=this.valueDec.toString();return t}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t.isFirstSid=this.isFirstSid,t}}class U extends a{constructor(t={}){super(t),this.fromString((0,Pr.getParametersValue)(t,"value",""))}fromBER(t,e,r){let i=e;for(;r>0;){const e=new N;if(i=e.fromBER(t,i,r),-1===i)return this.blockLength=0,this.error=e.error,i;0===this.value.length&&(e.isFirstSid=!0),this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return i}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const i=this.value[r].toBER(t);if(0===i.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=(0,Pr.utilConcatBuf)(e,i)}return e}fromString(t){this.value=[];let e=0,r=0,i="",s=!1;do{if(r=t.indexOf(".",e),i=-1===r?t.substr(e):t.substr(e,r-e),e=r+1,s){const t=this.value[0];let e=0;switch(t.valueDec){case 0:break;case 1:e=40;break;case 2:e=80;break;default:return this.value=[],!1}const r=parseInt(i,10);if(isNaN(r))return!0;t.valueDec=r+e,s=!1}else{const t=new N;if(t.valueDec=parseInt(i,10),isNaN(t.valueDec))return!0;0===this.value.length&&(t.isFirstSid=!0,s=!0),this.value.push(t)}}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let i=this.value[r].toString();0!==r&&(t+="."),e?(i=`{${i}}`,this.value[r].isFirstSid?t=`2.{${i} - 80}`:t+=i):t+=i}return t}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class I extends c{constructor(t={}){super(t,U),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"ObjectIdentifier"}}e.ObjectIdentifier=I;class C extends(s(i)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class q extends c{constructor(t={}){super(t,C),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"Utf8String"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(t){const e=unescape(encodeURIComponent(t)),r=e.length;this.valueBlock.valueHex=new ArrayBuffer(r);const i=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<r;s++)i[s]=e.charCodeAt(s);this.valueBlock.value=t}}e.Utf8String=q;class O extends(s(i)){constructor(t={}){super(t),this.valueDec=(0,Pr.getParametersValue)(t,"valueDec",-1)}static blockName(){return"relativeSidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===(0,Pr.checkBufferParams)(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let s=new Uint8Array(this.valueHex);for(let a=0;a<r&&(s[a]=127&i[a],this.blockLength++,0!=(128&i[a]));a++);const n=new ArrayBuffer(this.blockLength),o=new Uint8Array(n);for(let a=0;a<this.blockLength;a++)o[a]=s[a];return this.valueHex=n.slice(0),s=new Uint8Array(this.valueHex),0!=(128&i[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===s[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=(0,Pr.utilFromBase)(s,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const i=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|i[t];return r[this.blockLength-1]=i[this.blockLength-1],e}const i=(0,Pr.utilToBase)(this.valueDec,7);if(0===i.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(i.byteLength),!1===t){const t=new Uint8Array(i);r=new Uint8Array(e);for(let e=0;e<i.byteLength-1;e++)r[e]=128|t[e];r[i.byteLength-1]=t[i.byteLength-1]}return e}toString(){let t="";return t=!0===this.isHexOnly?(0,Pr.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength):this.valueDec.toString(),t}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}}class R extends a{constructor(t={}){super(t),this.fromString((0,Pr.getParametersValue)(t,"value",""))}fromBER(t,e,r){let i=e;for(;r>0;){const e=new O;if(i=e.fromBER(t,i,r),-1===i)return this.blockLength=0,this.error=e.error,i;this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return i}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const i=this.value[r].toBER(t);if(0===i.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=(0,Pr.utilConcatBuf)(e,i)}return e}fromString(t){this.value=[];let e=0,r=0,i="";do{r=t.indexOf(".",e),i=-1===r?t.substr(e):t.substr(e,r-e),e=r+1;const s=new O;if(s.valueDec=parseInt(i,10),isNaN(s.valueDec))return!0;this.value.push(s)}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let i=this.value[r].toString();0!==r&&(t+="."),e?(i=`{${i}}`,t+=i):t+=i}return t}static blockName(){return"RelativeObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class T extends c{constructor(t={}){super(t,R),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}static blockName(){return"RelativeObjectIdentifier"}}e.RelativeObjectIdentifier=T;class K extends(s(i)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class D extends c{constructor(t={}){super(t,K),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BmpString"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let i=0;i<r.length;i+=2){const t=r[i];r[i]=r[i+1],r[i+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(2*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<e;i++){const e=(0,Pr.utilToBase)(t.charCodeAt(i),8),s=new Uint8Array(e);if(s.length>2)continue;const n=2-s.length;for(let t=s.length-1;t>=0;t--)r[2*i+t+n]=s[t]}this.valueBlock.value=t}}e.BmpString=D;class j extends(s(i)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class P extends c{constructor(t={}){super(t,j),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let i=0;i<r.length;i+=4)r[i]=r[i+3],r[i+1]=r[i+2],r[i+2]=0,r[i+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(4*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<e;i++){const e=(0,Pr.utilToBase)(t.charCodeAt(i),8),s=new Uint8Array(e);if(s.length>4)continue;const n=4-s.length;for(let t=s.length-1;t>=0;t--)r[4*i+t+n]=s[t]}this.valueBlock.value=t}}e.UniversalString=P;class $ extends(s(i)){constructor(t={}){super(t),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class V extends c{constructor(t={}){super(t,$),"value"in t&&this.fromString(t.value)}static blockName(){return"SIMPLESTRING"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(e);const r=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<e;i++)r[i]=t.charCodeAt(i);this.valueBlock.value=t}}class J extends V{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}e.NumericString=J;class M extends V{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}e.PrintableString=M;class H extends V{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}e.TeletexString=H;class _ extends V{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}e.VideotexString=_;class W extends V{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}e.IA5String=W;class L extends V{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}e.GraphicString=L;class z extends V{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}e.VisibleString=z;class G extends V{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}e.GeneralString=G;class F extends V{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}e.CharacterString=F;class Z extends z{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let i=0;i<t.length;i++)r[i]=t.charCodeAt(i);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(t){const e=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(t);if(null===e)return void(this.error="Wrong input string for convertion");const r=parseInt(e[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(e[2],10),this.day=parseInt(e[3],10),this.hour=parseInt(e[4],10),this.minute=parseInt(e[5],10),this.second=parseInt(e[6],10)}toString(){const t=new Array(7);return t[0]=(0,Pr.padNumber)(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=(0,Pr.padNumber)(this.month,2),t[2]=(0,Pr.padNumber)(this.day,2),t[3]=(0,Pr.padNumber)(this.hour,2),t[4]=(0,Pr.padNumber)(this.minute,2),t[5]=(0,Pr.padNumber)(this.second,2),t[6]="Z",t.join("")}static blockName(){return"UTCTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t}}e.UTCTime=Z;class X extends z{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let i=0;i<t.length;i++)r[i]=t.charCodeAt(i);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(t){let e,r=!1,i="",s="",n=0,o=0,a=0;if("Z"===t[t.length-1])i=t.substr(0,t.length-1),r=!0;else{const e=new Number(t[t.length-1]);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");i=t}if(r){if(-1!==i.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==i.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let t=1,e=i.indexOf("+"),r="";if(-1===e&&(e=i.indexOf("-"),t=-1),-1!==e){if(r=i.substr(e+1),i=i.substr(0,e),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let s=new Number(r.substr(0,2));if(isNaN(s.valueOf()))throw new Error("Wrong input string for convertion");if(o=t*s,4===r.length){if(s=new Number(r.substr(2,2)),isNaN(s.valueOf()))throw new Error("Wrong input string for convertion");a=t*s}}}let c=i.indexOf(".");if(-1===c&&(c=i.indexOf(",")),-1!==c){const t=new Number("0"+i.substr(c));if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");n=t.valueOf(),s=i.substr(0,c)}else s=i;switch(!0){case 8===s.length:if(e=/(\d{4})(\d{2})(\d{2})/gi,-1!==c)throw new Error("Wrong input string for convertion");break;case 10===s.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let t=60*n;this.minute=Math.floor(t),t=60*(t-this.minute),this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 12===s.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let t=60*n;this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 14===s.length:e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c&&(this.millisecond=Math.floor(1e3*n));break;default:throw new Error("Wrong input string for convertion")}const u=e.exec(s);if(null===u)throw new Error("Wrong input string for convertion");for(let h=1;h<u.length;h++)switch(h){case 1:this.year=parseInt(u[h],10);break;case 2:this.month=parseInt(u[h],10);break;case 3:this.day=parseInt(u[h],10);break;case 4:this.hour=parseInt(u[h],10)+o;break;case 5:this.minute=parseInt(u[h],10)+a;break;case 6:this.second=parseInt(u[h],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const t=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=t.getUTCFullYear(),this.month=t.getUTCMonth(),this.day=t.getUTCDay(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}}toString(){const t=[];return t.push((0,Pr.padNumber)(this.year,4)),t.push((0,Pr.padNumber)(this.month,2)),t.push((0,Pr.padNumber)(this.day,2)),t.push((0,Pr.padNumber)(this.hour,2)),t.push((0,Pr.padNumber)(this.minute,2)),t.push((0,Pr.padNumber)(this.second,2)),0!==this.millisecond&&(t.push("."),t.push((0,Pr.padNumber)(this.millisecond,3))),t.push("Z"),t.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t.millisecond=this.millisecond,t}}e.GeneralizedTime=X;class Q extends q{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}e.DATE=Q;class Y extends q{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}e.TimeOfDay=Y;class tt extends q{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}e.DateTime=tt;class et extends q{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}e.Duration=et;class rt extends q{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}e.TIME=rt;class it{constructor(t={}){this.value=(0,Pr.getParametersValue)(t,"value",[]),this.optional=(0,Pr.getParametersValue)(t,"optional",!1)}}e.Choice=it;class st{constructor(t={}){this.name=(0,Pr.getParametersValue)(t,"name",""),this.optional=(0,Pr.getParametersValue)(t,"optional",!1)}}e.Any=st;class nt{constructor(t={}){this.name=(0,Pr.getParametersValue)(t,"name",""),this.optional=(0,Pr.getParametersValue)(t,"optional",!1),this.value=(0,Pr.getParametersValue)(t,"value",new st),this.local=(0,Pr.getParametersValue)(t,"local",!1)}}function ot(t,e,r){const s=e;let n=new c({},Object);const o=new i;if(!1===(0,Pr.checkBufferParams)(o,t,e,r))return n.error=o.error,{offset:-1,result:n};if(0===new Uint8Array(t,e,r).length)return this.error="Zero buffer length",{offset:-1,result:n};let a=n.idBlock.fromBER(t,e,r);if(n.warnings.concat(n.idBlock.warnings),-1===a)return n.error=n.idBlock.error,{offset:-1,result:n};if(a=n.lenBlock.fromBER(t,e=a,r-=n.idBlock.blockLength),n.warnings.concat(n.lenBlock.warnings),-1===a)return n.error=n.lenBlock.error,{offset:-1,result:n};if(e=a,r-=n.lenBlock.blockLength,!1===n.idBlock.isConstructed&&!0===n.lenBlock.isIndefiniteForm)return n.error="Indefinite length form used for primitive encoding form",{offset:-1,result:n};let u=c;switch(n.idBlock.tagClass){case 1:if(n.idBlock.tagNumber>=37&&!1===n.idBlock.isHexOnly)return n.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:n};switch(n.idBlock.tagNumber){case 0:if(!0===n.idBlock.isConstructed&&n.lenBlock.length>0)return n.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:n};u=y;break;case 1:u=p;break;case 2:u=E;break;case 3:u=S;break;case 4:u=A;break;case 5:u=g;break;case 6:u=I;break;case 10:u=x;break;case 12:u=q;break;case 13:u=T;break;case 14:u=rt;break;case 15:return n.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:n};case 16:u=v;break;case 17:u=m;break;case 18:u=J;break;case 19:u=M;break;case 20:u=H;break;case 21:u=_;break;case 22:u=W;break;case 23:u=Z;break;case 24:u=X;break;case 25:u=L;break;case 26:u=z;break;case 27:u=G;break;case 28:u=P;break;case 29:u=F;break;case 30:u=D;break;case 31:u=Q;break;case 32:u=Y;break;case 33:u=tt;break;case 34:u=et;break;default:{let i;i=!0===n.idBlock.isConstructed?new l:new h,i.idBlock=n.idBlock,i.lenBlock=n.lenBlock,i.warnings=n.warnings,n=i,a=n.fromBER(t,e,r)}}break;case 2:case 3:case 4:default:u=!0===n.idBlock.isConstructed?l:h}return n=function(t,e){if(t instanceof e)return t;const r=new e;return r.idBlock=t.idBlock,r.lenBlock=t.lenBlock,r.warnings=t.warnings,r.valueBeforeDecode=t.valueBeforeDecode.slice(0),r}(n,u),a=n.fromBER(t,e,!0===n.lenBlock.isIndefiniteForm?r:n.lenBlock.length),n.valueBeforeDecode=t.slice(s,s+n.blockLength),{offset:a,result:n}}function at(t){if(0===t.byteLength){const t=new c({},Object);return t.error="Input buffer has zero length",{offset:-1,result:t}}return ot(t,0,t.byteLength)}function ct(t,e,r){if(r instanceof it){for(let i=0;i<r.value.length;i++)if(!0===ct(t,e,r.value[i]).verified)return{verified:!0,result:t};{const t={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(t.name=r.name),t}}if(r instanceof st)return r.hasOwnProperty("name")&&(t[r.name]=e),{verified:!0,result:t};if(t instanceof Object==0)return{verified:!1,result:{error:"Wrong root object"}};if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const i=r.idBlock.toBER(!1);if(0===i.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(i,0,i.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:t};if("isHexOnly"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:t};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const i=new Uint8Array(r.idBlock.valueHex),s=new Uint8Array(e.idBlock.valueHex);if(i.length!==s.length)return{verified:!1,result:t};for(let e=0;e<i.length;e++)if(i[e]!==s[1])return{verified:!1,result:t}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(t[r.name]=e)),!0===r.idBlock.isConstructed){let i=0,s={verified:!1},n=r.valueBlock.value.length;if(n>0&&r.valueBlock.value[0]instanceof nt&&(n=e.valueBlock.value.length),0===n)return{verified:!0,result:t};if(0===e.valueBlock.value.length&&0!==r.valueBlock.value.length){let e=!0;for(let t=0;t<r.valueBlock.value.length;t++)e=e&&(r.valueBlock.value[t].optional||!1);return!0===e?{verified:!0,result:t}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),t.error="Inconsistent object length",{verified:!1,result:t})}for(let o=0;o<n;o++)if(o-i>=e.valueBlock.value.length){if(!1===r.valueBlock.value[o].optional){const e={verified:!1,result:t};return t.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}}else if(r.valueBlock.value[0]instanceof nt){if(s=ct(t,e.valueBlock.value[o],r.valueBlock.value[0].value),!1===s.verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),s;i++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let i={};i="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?e:t,void 0===i[r.valueBlock.value[0].name]&&(i[r.valueBlock.value[0].name]=[]),i[r.valueBlock.value[0].name].push(e.valueBlock.value[o])}}else if(s=ct(t,e.valueBlock.value[o-i],r.valueBlock.value[o]),!1===s.verified){if(!0!==r.valueBlock.value[o].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),s;i++}if(!1===s.verified){const e={verified:!1,result:t};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return{verified:!0,result:t}}if("primitiveSchema"in r&&"valueHex"in e.valueBlock){const i=at(e.valueBlock.valueHex);if(-1===i.offset){const e={verified:!1,result:i.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return ct(t,i.result,r.primitiveSchema)}return{verified:!0,result:t}}e.Repeated=nt,e.RawData=class{constructor(t={}){this.data=(0,Pr.getParametersValue)(t,"data",new ArrayBuffer(0))}fromBER(t,e,r){return this.data=t.slice(e,r),e+r}toBER(t=!1){return this.data}}})),Vr=(Kr=$r)&&Kr.__esModule&&Object.prototype.hasOwnProperty.call(Kr,"default")?Kr.default:Kr,Jr=$r.fromBER,Mr=$r.Repeated,Hr=$r.Any,_r=$r.Choice,Wr=$r.GeneralizedTime,Lr=$r.UTCTime,zr=$r.CharacterString,Gr=$r.GeneralString,Fr=$r.VisibleString,Zr=$r.GraphicString,Xr=$r.IA5String,Qr=$r.VideotexString,Yr=$r.TeletexString,ti=$r.PrintableString,ei=$r.NumericString,ri=$r.UniversalString,ii=$r.BmpString,si=$r.Utf8String,ni=$r.ObjectIdentifier,oi=$r.Enumerated,ai=$r.Integer,ci=$r.BitString,ui=$r.OctetString,hi=$r.Null,fi=$r.Set,li=$r.Sequence,di=$r.Boolean,yi=$r.Constructed,wi=$r.Primitive,pi=$r.BaseBlock,vi=Object.freeze({__proto__:null,default:Vr,__moduleExports:$r,fromBER:Jr,compareSchema:$r.compareSchema,verifySchema:$r.verifySchema,fromJSON:$r.fromJSON,RawData:$r.RawData,Repeated:Mr,Any:Hr,Choice:_r,TIME:$r.TIME,Duration:$r.Duration,DateTime:$r.DateTime,TimeOfDay:$r.TimeOfDay,DATE:$r.DATE,GeneralizedTime:Wr,UTCTime:Lr,CharacterString:zr,GeneralString:Gr,VisibleString:Fr,GraphicString:Zr,IA5String:Xr,VideotexString:Qr,TeletexString:Yr,PrintableString:ti,NumericString:ei,UniversalString:ri,BmpString:ii,RelativeObjectIdentifier:$r.RelativeObjectIdentifier,Utf8String:si,ObjectIdentifier:ni,Enumerated:oi,Integer:ai,BitString:ci,OctetString:ui,Null:hi,Set:fi,Sequence:li,Boolean:di,EndOfContent:$r.EndOfContent,Constructed:yi,Primitive:wi,BaseBlock:pi,ValueBlock:$r.ValueBlock,HexBlock:$r.HexBlock});!function(t){t[t.Sequence=0]="Sequence",t[t.Set=1]="Set",t[t.Choice=2]="Choice"}(Dr||(Dr={})),function(t){t[t.Any=1]="Any",t[t.Boolean=2]="Boolean",t[t.OctetString=3]="OctetString",t[t.BitString=4]="BitString",t[t.Integer=5]="Integer",t[t.Enumerated=6]="Enumerated",t[t.ObjectIdentifier=7]="ObjectIdentifier",t[t.Utf8String=8]="Utf8String",t[t.BmpString=9]="BmpString",t[t.UniversalString=10]="UniversalString",t[t.NumericString=11]="NumericString",t[t.PrintableString=12]="PrintableString",t[t.TeletexString=13]="TeletexString",t[t.VideotexString=14]="VideotexString",t[t.IA5String=15]="IA5String",t[t.GraphicString=16]="GraphicString",t[t.VisibleString=17]="VisibleString",t[t.GeneralString=18]="GeneralString",t[t.CharacterString=19]="CharacterString",t[t.UTCTime=20]="UTCTime",t[t.GeneralizedTime=21]="GeneralizedTime",t[t.DATE=22]="DATE",t[t.TimeOfDay=23]="TimeOfDay",t[t.DateTime=24]="DateTime",t[t.Duration=25]="Duration",t[t.TIME=26]="TIME",t[t.Null=27]="Null"}(jr||(jr={}));const mi={fromASN:t=>t instanceof hi?null:t.valueBeforeDecode,toASN:t=>{if(null===t)return new hi;const e=Jr(t);if(e.result.error)throw new Error(e.result.error);return e.result}},gi={fromASN:t=>t.valueBlock.valueHex.byteLength>4?t.valueBlock.toString():t.valueBlock.valueDec,toASN:t=>new ai({value:t})},bi={fromASN:t=>t.valueBlock.valueDec,toASN:t=>new oi({value:t})},Ai={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new ci({valueHex:t})},Bi={fromASN:t=>t.valueBlock.toString(),toASN:t=>new ni({value:t})},Si={fromASN:t=>t.valueBlock.value,toASN:t=>new di({value:t})},ki={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new ui({valueHex:t})};function Ei(t){return{fromASN:t=>t.valueBlock.value,toASN:e=>new t({value:e})}}const xi=Ei(si),Ni=Ei(ii),Ui=Ei(ri),Ii=Ei(ei),Ci=Ei(ti),qi=Ei(Yr),Oi=Ei(Qr),Ri=Ei(Xr),Ti=Ei(Zr),Ki=Ei(Fr),Di=Ei(Gr),ji=Ei(zr),Pi={fromASN:t=>t.toDate(),toASN:t=>new Lr({valueDate:t})},$i={fromASN:t=>t.toDate(),toASN:t=>new Wr({valueDate:t})},Vi={fromASN:()=>null,toASN:()=>new hi};function Ji(t){switch(t){case jr.Any:return mi;case jr.BitString:return Ai;case jr.BmpString:return Ni;case jr.Boolean:return Si;case jr.CharacterString:return ji;case jr.Enumerated:return bi;case jr.GeneralString:return Di;case jr.GeneralizedTime:return $i;case jr.GraphicString:return Ti;case jr.IA5String:return Ri;case jr.Integer:return gi;case jr.Null:return Vi;case jr.NumericString:return Ii;case jr.ObjectIdentifier:return Bi;case jr.OctetString:return ki;case jr.PrintableString:return Ci;case jr.TeletexString:return qi;case jr.UTCTime:return Pi;case jr.UniversalString:return Ui;case jr.Utf8String:return xi;case jr.VideotexString:return Oi;case jr.VisibleString:return Ki;default:return null}}function Mi(t){return t&&t.prototype?!(!t.prototype.toASN||!t.prototype.fromASN)||Mi(t.prototype):!!(t&&t.toASN&&t.fromASN)}function Hi(t,e){if(!t||!e)return!1;if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),i=new Uint8Array(e);for(let s=0;s<t.byteLength;s++)if(r[s]!==i[s])return!1;return!0}const _i=new class{constructor(){this.items=new WeakMap}has(t){return this.items.has(t)}get(t){var e,r,i,s;const n=this.items.get(t);if(!n)throw new Error(`Cannot get schema for '${null!==(s=null===(i=null===(r=null===(e=t)||void 0===e?void 0:e.prototype)||void 0===r?void 0:r.constructor)||void 0===i?void 0:i.name)&&void 0!==s?s:t}' target`);return n}cache(t){const e=this.get(t);e.schema||(e.schema=this.create(t,!0))}createDefault(t){const e={type:Dr.Sequence,items:{}},r=this.findParentSchema(t);return r&&(Object.assign(e,r),e.items=Object.assign({},e.items,r.items)),e}create(t,e){const r=this.items.get(t)||this.createDefault(t),i=[];for(const s in r.items){const t=r.items[s],n=e?s:"";let o;if("number"==typeof t.type){const e=jr[t.type],r=vi[e];if(!r)throw new Error(`Cannot get ASN1 class by name '${e}'`);o=new r({name:n})}else Mi(t.type)?o=(new t.type).toSchema(n):t.optional?this.get(t.type).type===Dr.Choice?o=new Hr({name:n}):(o=this.create(t.type,!1),o.name=n):o=new Hr({name:n});const a=!!t.optional||void 0!==t.defaultValue;if(t.repeated&&(o.name="",o=new("set"===t.repeated?fi:li)({name:"",value:[new Mr({name:n,value:o})]})),null!=t.context)if(t.implicit)if("number"==typeof t.type||Mi(t.type))i.push(new(t.repeated?yi:wi)({name:n,optional:a,idBlock:{tagClass:3,tagNumber:t.context}}));else{this.cache(t.type);const e=!!t.repeated;let r=e?o:this.get(t.type).schema;r=r.valueBlock?r.valueBlock.value:r.value,i.push(new yi({name:e?"":n,optional:a,idBlock:{tagClass:3,tagNumber:t.context},value:r}))}else i.push(new yi({optional:a,idBlock:{tagClass:3,tagNumber:t.context},value:[o]}));else o.optional=a,i.push(o)}switch(r.type){case Dr.Sequence:return new li({value:i,name:""});case Dr.Set:return new fi({value:i,name:""});case Dr.Choice:return new _r({value:i,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(t,e){return this.items.set(t,e),this}findParentSchema(t){const e=t.__proto__;return e?this.items.get(e)||this.findParentSchema(e):null}},Wi=t=>e=>{let r;_i.has(e)?r=_i.get(e):(r=_i.createDefault(e),_i.set(e,r)),Object.assign(r,t)},Li=t=>(e,r)=>{let i;_i.has(e.constructor)?i=_i.get(e.constructor):(i=_i.createDefault(e.constructor),_i.set(e.constructor,i));const s=Object.assign({},t);if("number"==typeof s.type&&!s.converter){const i=Ji(t.type);if(!i)throw new Error(`Cannot get default converter for property '${r}' of ${e.constructor.name}`);s.converter=i}i.items[r]=s};class zi{static serialize(t){return t instanceof pi?t.toBER(!1):this.toASN(t).toBER(!1)}static toASN(t){if(t&&Mi(t.constructor))return t.toASN();const e=t.constructor,r=_i.get(e);_i.cache(e);let i,s=[];if(r.itemType)if("number"==typeof r.itemType){const i=Ji(r.itemType);if(!i)throw new Error(`Cannot get default converter for array item of ${e.name} ASN1 schema`);s=t.map(t=>i.toASN(t))}else s=t.map(t=>this.toAsnItem({type:r.itemType},"[]",e,t));else for(const n in r.items){const i=r.items[n],o=t[n];if(void 0===o||i.defaultValue===o||"object"==typeof i.defaultValue&&"object"==typeof o&&Hi(this.serialize(i.defaultValue),this.serialize(o)))continue;let a=zi.toAsnItem(i,n,e,o);if("number"==typeof i.context)if(i.implicit)if(i.repeated||"number"!=typeof i.type&&!Mi(i.type))s.push(new yi({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:a.valueBlock.value}));else{const t={};t.valueHex=a.valueBlock.toBER(),s.push(new wi(Object.assign({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context}},t)))}else s.push(new yi({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:[a]}));else i.repeated?s=s.concat(a):s.push(a)}switch(r.type){case Dr.Sequence:i=new li({value:s});break;case Dr.Set:i=new fi({value:s});break;case Dr.Choice:if(!s[0])throw new Error(`Schema '${e.name}' has wrong data. Choice cannot be empty.`);i=s[0]}return i}static toAsnItem(t,e,r,i){let s;if("number"==typeof t.type){const n=t.converter;if(!n)throw new Error(`Property '${e}' doesn't have converter for type ${jr[t.type]} in schema '${r.name}'`);if(t.repeated){const e=Array.from(i,t=>n.toASN(t));s=new("sequence"===t.repeated?li:fi)({value:e})}else s=n.toASN(i)}else if(t.repeated){const e=Array.from(i,t=>this.toASN(t));s=new("sequence"===t.repeated?li:fi)({value:e})}else s=this.toASN(i);return s}}class Gi extends Error{constructor(t,e){super(e?t+". See the inner exception for more details.":t),this.message=t,this.innerError=e}}class Fi extends Gi{}var Zi;function Xi(t,e){if(!function(t,e){switch(e){case Zi.Boolean:return"boolean"==typeof t;case Zi.Number:return"number"==typeof t;case Zi.String:return"string"==typeof t}return!0}(t,e))throw new TypeError("Value must be "+Zi[e])}!function(t){t[t.Any=0]="Any",t[t.Boolean=1]="Boolean",t[t.Number=2]="Number",t[t.String=3]="String"}(Zi||(Zi={}));const Qi=new class{constructor(){this.items=new Map}has(t){return this.items.has(t)||!!this.findParentSchema(t)}get(t){const e=this.items.get(t)||this.findParentSchema(t);if(!e)throw new Error("Cannot get schema for current target");return e}create(t){const e={names:{}},r=this.findParentSchema(t);if(r){Object.assign(e,r),e.names={};for(const t in r.names)e.names[t]=Object.assign({},r.names[t])}return e.target=t,e}set(t,e){return this.items.set(t,e),this}findParentSchema(t){const e=t.__proto__;return e?this.items.get(e)||this.findParentSchema(e):null}};class Yi{constructor(t){this.pattern=new RegExp(t)}validate(t){const e=new RegExp(this.pattern.source,this.pattern.flags);if("string"!=typeof t)throw new Fi("Incoming value must be string");if(!e.exec(t))throw new Fi(`Value doesn't match to pattern '${e.toString()}'`)}}class ts{constructor(t=Number.MIN_VALUE,e=Number.MAX_VALUE){this.min=t,this.max=e}validate(t){if(Xi(t,Zi.Number),!(this.min<=t&&t<=this.max))throw new Fi(`Value doesn't match to diapason [${this.min===Number.MIN_VALUE?"MIN":this.min},${this.max===Number.MAX_VALUE?"MAX":this.max}]`)}}class es{constructor(t=Number.MIN_VALUE,e=Number.MAX_VALUE){this.min=t,this.max=e}validate(t){if(Xi(t,Zi.Number),!(this.min<t&&t<this.max))throw new Fi(`Value doesn't match to diapason (${this.min===Number.MIN_VALUE?"MIN":this.min},${this.max===Number.MAX_VALUE?"MAX":this.max})`)}}class rs{constructor(t,e,r){this.length=t,this.minLength=e,this.maxLength=r}validate(t){if(void 0===this.length){if(void 0!==this.minLength&&t.length<this.minLength)throw new Fi(`Value length must be more than ${this.minLength}.`);if(void 0!==this.maxLength&&t.length>this.maxLength)throw new Fi(`Value length must be less than ${this.maxLength}.`)}else if(t.length!==this.length)throw new Fi(`Value length must be exactly ${this.length}.`)}}class is{constructor(t){this.enumeration=t}validate(t){if(Xi(t,Zi.String),!this.enumeration.includes(t))throw new Fi("Value must be one of "+this.enumeration.map(t=>`'${t}'`).join(", "))}}const ss=(t={})=>(e,r)=>{const i=`Cannot set type for ${r} property of ${e.constructor.name} schema`;let s;Qi.has(e.constructor)?(s=Qi.get(e.constructor),s.target!==e.constructor&&(s=Qi.create(e.constructor),Qi.set(e.constructor,s))):(s=Qi.create(e.constructor),Qi.set(e.constructor,s));const n=Object.assign({type:Zi.Any,validations:[]},t);if(n.validations=function(t){const e=[];return t.pattern&&e.push(new Yi(t.pattern)),t.type!==Zi.Number&&t.type!==Zi.Any||(void 0===t.minInclusive&&void 0===t.maxInclusive||e.push(new ts(t.minInclusive,t.maxInclusive)),void 0===t.minExclusive&&void 0===t.maxExclusive||e.push(new es(t.minExclusive,t.maxExclusive)),void 0!==t.enumeration&&e.push(new is(t.enumeration))),(t.type===Zi.String||t.repeated||t.type===Zi.Any)&&(void 0===t.length&&void 0===t.minLength&&void 0===t.maxLength||e.push(new rs(t.length,t.minLength,t.maxLength))),e}(n),"number"!=typeof n.type&&!Qi.has(n.type)&&!function t(e){return e&&e.prototype?!(!e.prototype.toJSON||!e.prototype.fromJSON)||t(e.prototype):!!(e&&e.toJSON&&e.fromJSON)}(n.type))throw new Error(i+". Assigning type doesn't have schema.");let o;o=Array.isArray(t.schema)?t.schema:[t.schema||"default"];for(const t of o)s.names[t]||(s.names[t]={}),s.names[t][r]=n};class ns extends Error{}class os{static toArrayBuffer(t){const e=t.replace(/-{5}(BEGIN|END) .*-{5}/g,"").replace("\r","").replace("\n","");return u.FromBase64(e)}static toUint8Array(t){const e=this.toArrayBuffer(t);return new Uint8Array(e)}static fromBufferSource(t,e){const r=u.ToBase64(t);let i,s=0;const n=[];for(;i=r.slice(s,s+=64),i.length&&(n.push(i),!(i.length<64)););const o=e.toUpperCase();return`-----BEGIN ${o}-----\n${n.join("\n")}\n-----END ${o}-----`}static isPEM(t){return/-----BEGIN .+-----[A-Za-z0-9+\/\+\=\s\n]+-----END .+-----/i.test(t)}static getTagName(t){if(!this.isPEM(t))throw new Error("Bad parameter. Incoming data is not right PEM");const e=/-----BEGIN (.+)-----/.exec(t);if(!e)throw new Error("Cannot get tag from PEM");return e[1]}static hasTagName(t,e){const r=this.getTagName(t);return e.toLowerCase()===r.toLowerCase()}static isCertificate(t){return this.hasTagName(t,"certificate")}static isCertificateRequest(t){return this.hasTagName(t,"certificate request")}static isCRL(t){return this.hasTagName(t,"x509 crl")}static isPublicKey(t){return this.hasTagName(t,"public key")}}let as=class{constructor(t){t&&(this.value=t)}};ot([Li({type:jr.ObjectIdentifier})],as.prototype,"value",void 0),as=ot([Wi({type:Dr.Choice})],as);class cs{constructor(t){Object.assign(this,t)}}ot([Li({type:jr.ObjectIdentifier})],cs.prototype,"algorithm",void 0),ot([Li({type:jr.Any,optional:!0})],cs.prototype,"parameters",void 0);class us{constructor(){this.version=0,this.privateKeyAlgorithm=new cs,this.privateKey=new ArrayBuffer(0)}}ot([Li({type:jr.Integer})],us.prototype,"version",void 0),ot([Li({type:cs})],us.prototype,"privateKeyAlgorithm",void 0),ot([Li({type:jr.OctetString})],us.prototype,"privateKey",void 0),ot([Li({type:jr.Any,optional:!0})],us.prototype,"attributes",void 0);class hs{constructor(){this.publicKeyAlgorithm=new cs,this.publicKey=new ArrayBuffer(0)}}ot([Li({type:cs})],hs.prototype,"publicKeyAlgorithm",void 0),ot([Li({type:jr.BitString})],hs.prototype,"publicKey",void 0);const fs={fromJSON:t=>u.FromBase64Url(t),toJSON:t=>u.ToBase64Url(new Uint8Array(t))},ls={fromASN:t=>new Uint8Array(t.valueBlock.valueHex)[0]?t.valueBlock.valueHex:t.valueBlock.valueHex.slice(1),toASN:t=>{const e=new Uint8Array(t)[0]>127?Buffer.concat([Buffer.from([0]),Buffer.from(t)]):Buffer.from(t);return new ai({valueHex:new Uint8Array(e).buffer})}};var ds=Object.freeze({__proto__:null,JsonBase64UrlArrayBufferConverter:fs,AsnIntegerArrayBufferConverter:ls});class ys{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}}ot([Li({type:jr.Integer,converter:gi})],ys.prototype,"version",void 0),ot([Li({type:jr.Integer,converter:ls}),ss({name:"n",converter:fs})],ys.prototype,"modulus",void 0),ot([Li({type:jr.Integer,converter:ls}),ss({name:"e",converter:fs})],ys.prototype,"publicExponent",void 0),ot([Li({type:jr.Integer,converter:ls}),ss({name:"d",converter:fs})],ys.prototype,"privateExponent",void 0),ot([Li({type:jr.Integer,converter:ls}),ss({name:"p",converter:fs})],ys.prototype,"prime1",void 0),ot([Li({type:jr.Integer,converter:ls}),ss({name:"q",converter:fs})],ys.prototype,"prime2",void 0),ot([Li({type:jr.Integer,converter:ls}),ss({name:"dp",converter:fs})],ys.prototype,"exponent1",void 0),ot([Li({type:jr.Integer,converter:ls}),ss({name:"dq",converter:fs})],ys.prototype,"exponent2",void 0),ot([Li({type:jr.Integer,converter:ls}),ss({name:"qi",converter:fs})],ys.prototype,"coefficient",void 0),ot([Li({type:jr.Any,optional:!0})],ys.prototype,"otherPrimeInfos",void 0);class ws{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}}ot([Li({type:jr.Integer,converter:ls}),ss({name:"n",converter:fs})],ws.prototype,"modulus",void 0),ot([Li({type:jr.Integer,converter:ls}),ss({name:"e",converter:fs})],ws.prototype,"publicExponent",void 0);let ps=class{constructor(t){this.value=new ArrayBuffer(0),t&&(this.value=t)}toJSON(){let t=new Uint8Array(this.value);if(4!==t[0])throw new ns("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");t=new Uint8Array(this.value.slice(1));const e=t.length/2;return{x:u.ToBase64Url(t.buffer.slice(0,0+e)),y:u.ToBase64Url(t.buffer.slice(0+e,0+e+e))}}fromJSON(t){if(!("x"in t))throw new Error("x: Missing required property");if(!("y"in t))throw new Error("y: Missing required property");const e=u.FromBase64Url(t.x),r=u.FromBase64Url(t.y),i=Buffer.concat([new Uint8Array([4]),new Uint8Array(e),new Uint8Array(r)]);return this.value=new Uint8Array(i).buffer,this}};ot([Li({type:jr.OctetString})],ps.prototype,"value",void 0),ps=ot([Wi({type:Dr.Choice})],ps);class vs{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(t){if(!("d"in t))throw new Error("d: Missing required property");if(this.privateKey=u.FromBase64Url(t.d),"x"in t){const e=new ps;e.fromJSON(t),this.publicKey=zi.toASN(e).valueBlock.valueHex}return this}toJSON(){const t={};return t.d=u.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(t,new ps(this.publicKey).toJSON()),t}}ot([Li({type:jr.Integer,converter:gi})],vs.prototype,"version",void 0),ot([Li({type:jr.OctetString})],vs.prototype,"privateKey",void 0),ot([Li({context:0,type:jr.Any,optional:!0})],vs.prototype,"parameters",void 0),ot([Li({context:1,type:jr.BitString,optional:!0})],vs.prototype,"publicKey",void 0);const ms={fromASN:t=>{const e=new Uint8Array(t.valueBlock.valueHex);return 0===e[0]?e.buffer.slice(1):e.buffer},toASN:t=>{const e=new Uint8Array(t);if(e[0]>127){const t=new Uint8Array(e.length+1);return t.set(e,1),new ai({valueHex:t.buffer})}return new ai({valueHex:t})}};var gs=Object.freeze({__proto__:null,AsnIntegerWithoutPaddingConverter:ms});class bs{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}static fromWebCryptoSignature(t){const e=a.toUint8Array(t),r=e.byteLength/2,i=new this;return i.r=i.removePadding(e.slice(0,r)),i.s=i.removePadding(e.slice(r,2*r)),i}toWebCryptoSignature(t){t=this.getPointSize();const e=this.addPadding(t,a.toUint8Array(this.r)),r=this.addPadding(t,a.toUint8Array(this.s)),i=new Uint8Array(e.byteLength+r.byteLength);return i.set(e,0),i.set(r,e.length),i.buffer}getPointSize(){switch(Math.max(this.r.byteLength,this.s.byteLength)){case 31:case 32:return 32;case 47:case 48:return 48;case 65:case 66:return 66}throw new Error("Unsupported EC point size")}addPadding(t,e){const r=new Uint8Array(t),i=a.toUint8Array(e);return r.set(i,t-i.length),r}removePadding(t){const e=a.toUint8Array(t);for(let r=0;r<e.length;r++)if(e[r])return e.slice(r);return new Uint8Array(0)}}ot([Li({type:jr.Integer,converter:ms})],bs.prototype,"r",void 0),ot([Li({type:jr.Integer,converter:ms})],bs.prototype,"s",void 0);let As=class{};function Bs(t){if(t instanceof Bt)return t;const e=new Bt;if("string"==typeof t)e.fromAlgorithm({name:t});else if((r=t)instanceof Object&&"name"in r&&"hash"in r){const r={...t};r.hash=Bs(t.hash),e.fromAlgorithm(r)}else e.fromAlgorithm({...t});var r;return e}function Ss(t,e){if(!t||"object"!=typeof t&&"string"!=typeof t)throw new TypeError(e+": Is wrong type. Must be Object or String");if("object"==typeof t&&!("name"in t))throw new TypeError(e+": Required property 'name' is missed")}function ks(t,e){if(!function(t){return t instanceof kt}(t))throw new TypeError(e+": Is not type CryptoKey")}function Es(t,e){if(!function(t){return t instanceof se}(t))throw new TypeError(e+": Is not type CryptoCertificate")}function xs(t,e){if(!a.isBufferSource(t))throw new TypeError(e+": Is wrong type. Must be ArrayBuffer or ArrayBuffer view")}function Ns(t,e){if(!Array.isArray(t))throw new TypeError(e+": Is not type Array")}function Us(t,e,r){if(typeof t!==e)throw new TypeError(`${r}: Is not type '${e}'`)}ot([Li({type:jr.OctetString}),ss({type:Zi.String,converter:fs})],As.prototype,"d",void 0),As=ot([Wi({type:Dr.Choice})],As),Object.freeze({__proto__:null,converters:gs,get ObjectIdentifier(){return as},AlgorithmIdentifier:cs,PrivateKeyInfo:us,PublicKeyInfo:hs,RsaPrivateKey:ys,RsaPublicKey:ws,EcPrivateKey:vs,get EcPublicKey(){return ps},EcDsaSignature:bs,get CurvePrivateKey(){return As},idX25519:"1.3.101.110",idX448:"1.3.101.111",idEd25519:"1.3.101.112",idEd448:"1.3.101.113"}),Object.freeze({__proto__:null,converters:ds});const Is=["raw","pem","x509","request"];class Cs{constructor(t){this.provider=t}static isX509Certificate(t){return t instanceof ne}static isCertificateRequest(t){return t instanceof oe}async indexOf(t){Es(t,"item");const e=new ve;e.providerID=this.provider.id,e.item=t;const r=await this.provider.client.send(e);return r?u.ToUtf8String(r):null}async hasItem(t){return!!(await this.indexOf(t))}async exportCert(t,e){Us(t,"string","format"),Es(e,"item");const r=new pe;r.providerID=this.provider.id,r.format="raw",r.item=e;const i=await this.provider.client.send(r);if("raw"===t)return i;{let t="";switch(e.type){case"x509":t="CERTIFICATE";break;case"request":t="CERTIFICATE REQUEST";break;default:throw new Error("Cannot create PEM for unknown type of certificate item")}return os.fromBufferSource(i,t)}}async importCert(t,e,r,i){if(Us(t,"string","format"),!~Is.indexOf(t))throw new TypeError("format: Is invalid value. Must be "+Is.join(", "));"pem"===t?Us(e,"string","data"):xs(e,"data"),Ss(r,"algorithm"),Ns(i,"keyUsages");const s=Bs(r);let n;if(a.isBufferSource(e))n=a.toArrayBuffer(e);else{if("string"!=typeof e)throw new TypeError("data: Is not type String, ArrayBuffer or ArrayBufferView");n=os.toArrayBuffer(e)}const o=new we;o.providerID=this.provider.id,o.format="raw",o.data=n,o.algorithm=s,o.keyUsages=i;const c=await this.provider.client.send(o),u=await se.importProto(c);if(("request"===t||"x509"===t)&&u.type!==t)throw new TypeError("Imported item is not "+t);return this.prepareCertItem(u)}async keys(){const t=new fe;t.providerID=this.provider.id;const e=await this.provider.client.send(t);return e?u.ToUtf8String(e).split(","):[]}async getValue(t){Us(t,"string","key");const e=new le;e.providerID=this.provider.id,e.key=t;return await this.provider.client.send(e)||null}async getItem(t,e,r){Us(t,"string","key"),e&&(Ss(e,"algorithm"),Ns(r,"keyUsages"));const i=new he;i.providerID=this.provider.id,i.key=t,e&&(i.algorithm=Bs(e),i.keyUsages=r);const s=await this.provider.client.send(i);if(s&&s.byteLength){const t=await se.importProto(s);return this.prepareCertItem(t)}throw new Error("Cannot get CryptoCertificate from storage by index")}async setItem(t){Es(t,"value");const e=new ue;e.providerID=this.provider.id,e.item=t;const r=await this.provider.client.send(e);return u.ToUtf8String(r)}async removeItem(t){Us(t,"string","key");const e=new de;e.providerID=this.provider.id,e.key=t,await this.provider.client.send(e)}async clear(){const t=new ye;t.providerID=this.provider.id,await this.provider.client.send(t)}async getChain(t){Es(t,"value");const e=new me;e.providerID=this.provider.id,e.item=t;const r=await this.provider.client.send(e);return(await ce.importProto(r)).items}async getCRL(t){Us(t,"string","url");const e=new ge;return e.providerID=this.provider.id,e.url=t,await this.provider.client.send(e)}async getOCSP(t,e,r){Us(t,"string","url"),xs(e,"request");const i=new Ae;if(i.providerID=this.provider.id,i.url=t,i.request=a.toArrayBuffer(e),r)for(const s in r)i.options[s]=r[s];return await this.provider.client.send(i)}async findPrivateKey(t){let e="string"==typeof t?t:await this.provider.certStorage.indexOf(t);e||(e="");const[,,r]=e.split("-"),i=(await this.provider.keyStorage.keys()).find(t=>{const[e,,i]=t.split("-");return"private"===e&&i===r});return i?await this.provider.keyStorage.getItem(i):null}async prepareCertItem(t){const e=await t.exportProto();let r;switch(t.type){case"x509":r=await ne.importProto(e);break;case"request":r=await oe.importProto(e);break;default:throw new Error(`Unsupported CertificateItem type '${t.type}'`)}return r.provider=this.provider,r}}class qs{constructor(t){this.service=t}async keys(){const t=new Ue;t.providerID=this.service.id;const e=await this.service.client.send(t);return e?u.ToUtf8String(e).split(","):[]}async indexOf(t){ks(t,"item");const e=new qe;e.providerID=this.service.id,e.item=t;const r=await this.service.client.send(e);return r?u.ToUtf8String(r):null}async hasItem(t){return!!(await this.indexOf(t))}async getItem(t,e,r,i){Us(t,"string","key"),e&&(Ss(e,"algorithm"),Us(r,"boolean","extractable"),Ns(i,"usages"));const s=new Ne;s.providerID=this.service.id,s.key=t,e&&(s.algorithm=Bs(e),s.extractable=r,s.keyUsages=i);const n=await this.service.client.send(s);let o;if(!n||!n.byteLength)throw new Error("Cannot get CryptoKey from key storage by index");return o=await kt.importProto(n),o}async setItem(t){ks(t,"value");const e=new xe;e.providerID=this.service.id,e.item=t;const r=await this.service.client.send(e);return u.ToUtf8String(r)}async removeItem(t){Us(t,"string","key");const e=new Ie;e.providerID=this.service.id,e.key=t,await this.service.client.send(e)}async clear(){const t=new Ce;t.providerID=this.service.id,await this.service.client.send(t)}}class Os{constructor(t){this.service=t}async encrypt(t,e,r){return this.encryptData(t,e,r,"encrypt")}async decrypt(t,e,r){return this.encryptData(t,e,r,"decrypt")}async deriveBits(t,e,r){Ss(t,"algorithm"),ks(e,"baseKey"),Us(r,"number","length");const i=Bs(t);ks(i.public,"algorithm.public"),i.public=await i.public.exportProto();const s=new cr;return s.providerID=this.service.id,s.algorithm=i,s.key=e,s.length=r,await this.service.client.send(s)}async deriveKey(t,e,r,i,s){Ss(t,"algorithm"),ks(e,"baseKey"),Ss(r,"algorithm"),Us(i,"boolean","extractable"),Ns(s,"keyUsages");const n=Bs(t);ks(n.public,"algorithm.public"),n.public=await n.public.exportProto();const o=Bs(r),a=new ur;a.providerID=this.service.id,a.algorithm=n,a.derivedKeyType.fromAlgorithm(o),a.key=e,a.extractable=i,a.usage=s;const c=await this.service.client.send(a);return await kt.importProto(c)}async digest(t,e){return T().crypto.subtle.digest(t,e)}async generateKey(t,e,r){Ss(t,"algorithm"),Us(e,"boolean","extractable"),Ns(r,"keyUsages");const i=Bs(t),s=new ir;s.providerID=this.service.id,s.algorithm=i,s.extractable=e,s.usage=r;const n=await this.service.client.send(s);try{return await Et.importProto(n)}catch(o){return await kt.importProto(n)}}async exportKey(t,e){Us(t,"string","format"),ks(e,"key");const r=new lr;r.providerID=this.service.id,r.format=t,r.key=e;const i=await this.service.client.send(r);return"jwk"===t?JSON.parse(u.ToBinary(i)):i}async importKey(t,e,r,i,s){Us(t,"string","format"),Ss(r,"algorithm"),Us(i,"boolean","extractable"),Ns(s,"keyUsages");const n=Bs(r);let o;"jwk"===t?o=u.FromUtf8String(JSON.stringify(e)):(xs(e,"keyData"),o=a.toArrayBuffer(e));const c=new dr;c.providerID=this.service.id,c.algorithm=n,c.keyData=o,c.format=t,c.extractable=i,c.keyUsages=s;const h=await this.service.client.send(c);return await kt.importProto(h)}async sign(t,e,r){Ss(t,"algorithm"),ks(e,"key"),xs(r,"data");const i=Bs(t),s=a.toArrayBuffer(r),n=new sr;return n.providerID=this.service.id,n.algorithm=i,n.key=e,n.data=s,await this.service.client.send(n)}async verify(t,e,r,i){Ss(t,"algorithm"),ks(e,"key"),xs(r,"signature"),xs(i,"data");const s=Bs(t),n=a.toArrayBuffer(r),o=a.toArrayBuffer(i),c=new nr;c.providerID=this.service.id,c.algorithm=s,c.key=e,c.data=o,c.signature=n;const u=await this.service.client.send(c);return!!new Uint8Array(u)[0]}async wrapKey(t,e,r,i){Us(t,"string","format"),ks(e,"key"),ks(r,"wrappingKey"),Ss(i,"wrapAlgorithm");const s=Bs(i),n=new fr;return n.providerID=this.service.id,n.wrapAlgorithm=s,n.key=e,n.wrappingKey=r,n.format=t,await this.service.client.send(n)}async unwrapKey(t,e,r,i,s,n,o){Us(t,"string","format"),xs(e,"wrappedKey"),ks(r,"unwrappingKey"),Ss(i,"unwrapAlgorithm"),Ss(s,"unwrappedKeyAlgorithm"),Us(n,"boolean","extractable"),Ns(o,"keyUsages");const c=Bs(i),u=Bs(s),h=a.toArrayBuffer(e),f=new hr;f.providerID=this.service.id,f.format=t,f.unwrapAlgorithm=c,f.unwrappedKeyAlgorithm=u,f.unwrappingKey=r,f.wrappedKey=h,f.extractable=n,f.keyUsage=o;const l=await this.service.client.send(f);return await kt.importProto(l)}async encryptData(t,e,r,i){Ss(t,"algorithm"),ks(e,"key"),xs(r,"data");const s=Bs(t),n=a.toArrayBuffer(r);let o;o="encrypt"===i?or:ar;const c=new o;return c.providerID=this.service.id,c.algorithm=s,c.key=e,c.data=n,await this.service.client.send(c)}}class Rs{constructor(t,e){this.client=t,this.id=e,this.subtle=new Os(this),this.keyStorage=new qs(this),this.certStorage=new Cs(this)}getRandomValues(t){return T().crypto.getRandomValues(t)}async login(){const t=new $t;return t.providerID=this.id,this.client.send(t)}async logout(){const t=new Vt;return t.providerID=this.id,this.client.send(t)}async reset(){const t=new Mt;return t.providerID=this.id,this.client.send(t)}async isLoggedIn(){const t=new Jt;t.providerID=this.id;const e=await this.client.send(t);return!!new Uint8Array(e)[0]}}class Ts extends g{constructor(t){super(),this.client=new Ur(t.storage),this.cardReader=new yr(this.client)}get state(){return this.client.state}connect(t=Ts.FORTIFY,e){return this.removeAllListeners(),this.client.connect(t,e).on("error",t=>{this.emit("error",t.error)}).on("event",t=>{(async()=>{switch(t.action){case We.ACTION:{const e=await We.importProto(await t.exportProto());this.emit("token",e)}case _e.ACTION:{const e=await _e.importProto(await t.exportProto());this.emit("auth",e)}}})()}).on("listening",()=>{this.emit("listening",t)}).on("close",t=>{this.emit("close",t.remoteAddress)}),this}close(){this.client.close()}on(t,e){return console.log("SocketProvider:on",t),super.on(t,e)}once(t,e){return super.once(t,e)}async info(){const t=new Me,e=await this.client.send(t);return await Je.importProto(e)}async challenge(){return this.client.challenge()}async isLoggedIn(){return this.client.isLoggedIn()}async login(){return this.client.login()}async getCrypto(t){const e=new He;return e.cryptoID=t,await this.client.send(e),new Rs(this.client,t)}}Ts.FORTIFY="127.0.0.1:31337";class Ks{}var Ds=Ir((function(t){!function(){function e(t){return Array.prototype.slice.call(t)}function r(t){return new Promise((function(e,r){t.onsuccess=function(){e(t.result)},t.onerror=function(){r(t.error)}}))}function i(t,e,i){var s,n=new Promise((function(n,o){r(s=t[e].apply(t,i)).then(n,o)}));return n.request=s,n}function s(t,e,r){var s=i(t,e,r);return s.then((function(t){if(t)return new h(t,s.request)}))}function n(t,e,r){r.forEach((function(r){Object.defineProperty(t.prototype,r,{get:function(){return this[e][r]},set:function(t){this[e][r]=t}})}))}function o(t,e,r,s){s.forEach((function(s){s in r.prototype&&(t.prototype[s]=function(){return i(this[e],s,arguments)})}))}function a(t,e,r,i){i.forEach((function(i){i in r.prototype&&(t.prototype[i]=function(){return this[e][i].apply(this[e],arguments)})}))}function c(t,e,r,i){i.forEach((function(i){i in r.prototype&&(t.prototype[i]=function(){return s(this[e],i,arguments)})}))}function u(t){this._index=t}function h(t,e){this._cursor=t,this._request=e}function f(t){this._store=t}function l(t){this._tx=t,this.complete=new Promise((function(e,r){t.oncomplete=function(){e()},t.onerror=function(){r(t.error)},t.onabort=function(){r(t.error)}}))}function d(t,e,r){this._db=t,this.oldVersion=e,this.transaction=new l(r)}function y(t){this._db=t}n(u,"_index",["name","keyPath","multiEntry","unique"]),o(u,"_index",IDBIndex,["get","getKey","getAll","getAllKeys","count"]),c(u,"_index",IDBIndex,["openCursor","openKeyCursor"]),n(h,"_cursor",["direction","key","primaryKey","value"]),o(h,"_cursor",IDBCursor,["update","delete"]),["advance","continue","continuePrimaryKey"].forEach((function(t){t in IDBCursor.prototype&&(h.prototype[t]=function(){var e=this,i=arguments;return Promise.resolve().then((function(){return e._cursor[t].apply(e._cursor,i),r(e._request).then((function(t){if(t)return new h(t,e._request)}))}))})})),f.prototype.createIndex=function(){return new u(this._store.createIndex.apply(this._store,arguments))},f.prototype.index=function(){return new u(this._store.index.apply(this._store,arguments))},n(f,"_store",["name","keyPath","indexNames","autoIncrement"]),o(f,"_store",IDBObjectStore,["put","add","delete","clear","get","getAll","getKey","getAllKeys","count"]),c(f,"_store",IDBObjectStore,["openCursor","openKeyCursor"]),a(f,"_store",IDBObjectStore,["deleteIndex"]),l.prototype.objectStore=function(){return new f(this._tx.objectStore.apply(this._tx,arguments))},n(l,"_tx",["objectStoreNames","mode"]),a(l,"_tx",IDBTransaction,["abort"]),d.prototype.createObjectStore=function(){return new f(this._db.createObjectStore.apply(this._db,arguments))},n(d,"_db",["name","version","objectStoreNames"]),a(d,"_db",IDBDatabase,["deleteObjectStore","close"]),y.prototype.transaction=function(){return new l(this._db.transaction.apply(this._db,arguments))},n(y,"_db",["name","version","objectStoreNames"]),a(y,"_db",IDBDatabase,["close"]),["openCursor","openKeyCursor"].forEach((function(t){[f,u].forEach((function(r){t in r.prototype&&(r.prototype[t.replace("open","iterate")]=function(){var r=e(arguments),i=r[r.length-1],s=this._store||this._index,n=s[t].apply(s,r.slice(0,-1));n.onsuccess=function(){i(n.result)}})}))})),[u,f].forEach((function(t){t.prototype.getAll||(t.prototype.getAll=function(t,e){var r=this,i=[];return new Promise((function(s){r.iterateCursor(t,(function(t){t?(i.push(t.value),void 0===e||i.length!=e?t.continue():s(i)):s(i)}))}))})})),t.exports={open:function(t,e,r){var s=i(indexedDB,"open",[t,e]),n=s.request;return n&&(n.onupgradeneeded=function(t){r&&r(new d(n.result,t.oldVersion,n.transaction))}),s.then((function(t){return new y(t)}))},delete:function(t){return i(indexedDB,"deleteDatabase",[t])}},t.exports.default=t.exports}()})),js=Ir((function(t){t.exports="undefined"!=typeof indexedDB?Ds:{open:function(){return Promise.reject("IDB requires a browser environment")},delete:function(){return Promise.reject("IDB requires a browser environment")}}}));class Ps extends Ks{constructor(t){super(),this.db=t}static async create(){const t=await js.open(this.STORAGE_NAME,2,t=>{1===t.oldVersion&&(t.deleteObjectStore(this.SESSION_STORAGE),t.deleteObjectStore(this.IDENTITY_STORAGE),t.deleteObjectStore(this.REMOTE_STORAGE)),t.createObjectStore(this.SESSION_STORAGE),t.createObjectStore(this.IDENTITY_STORAGE),t.createObjectStore(this.REMOTE_STORAGE)});return new Ps(t)}async loadWrapKey(){const t=await this.db.transaction(Ps.IDENTITY_STORAGE).objectStore(Ps.IDENTITY_STORAGE).get(Ps.WRAP_KEY);return t?(Er.iv=t.iv,t.key instanceof ArrayBuffer?{key:await T().crypto.subtle.importKey("raw",t.key,{name:Er.name,length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"]),iv:t.iv}:{key:t.key,iv:t.iv}):null}async saveWrapKey(t){let e;e=Ar()||Br()?{key:await T().crypto.subtle.exportKey("raw",t.key),iv:t.iv}:{...t},await this.db.transaction(Ps.IDENTITY_STORAGE,"readwrite").objectStore(Ps.IDENTITY_STORAGE).put(e,Ps.WRAP_KEY)}async loadIdentity(){const t=await this.db.transaction(Ps.IDENTITY_STORAGE).objectStore(Ps.IDENTITY_STORAGE).get(Ps.IDENTITY);let e=null;if(t){if(br()||Ar()||Br()){const e=await this.loadWrapKey();if(!(e&&e.key.usages.some(t=>"encrypt"===t)&&t.exchangeKey.privateKey instanceof ArrayBuffer))return null;t.exchangeKey.privateKey=await T().crypto.subtle.unwrapKey("jwk",t.exchangeKey.privateKey,e.key,Er,Sr,!1,["deriveKey","deriveBits"]),t.signingKey.privateKey=await T().crypto.subtle.unwrapKey("jwk",t.signingKey.privateKey,e.key,Er,kr,!1,["sign"]),t.exchangeKey.publicKey=await T().crypto.subtle.unwrapKey("jwk",t.exchangeKey.publicKey,e.key,Er,Sr,!0,[]),t.signingKey.publicKey=await T().crypto.subtle.unwrapKey("jwk",t.signingKey.publicKey,e.key,Er,kr,!0,["verify"])}e=await $.fromJSON(t)}return e}async saveIdentity(t){let e;if(br()||Ar()||Br()){e={key:await T().crypto.subtle.generateKey({name:Er.name,length:256},Ar()||Br(),["wrapKey","unwrapKey","encrypt","decrypt"]),iv:T().crypto.getRandomValues(new Uint8Array(Er.iv)).buffer},await this.saveWrapKey(e);const r=await T().crypto.subtle.generateKey(t.exchangeKey.privateKey.algorithm,!0,["deriveKey","deriveBits"]);t.exchangeKey.privateKey=r.privateKey,await xr(t.exchangeKey.publicKey,r.publicKey);const i=await T().crypto.subtle.generateKey(t.signingKey.privateKey.algorithm,!0,["sign","verify"]);t.signingKey.privateKey=i.privateKey,await xr(t.signingKey.publicKey,i.publicKey)}const r=await t.toJSON();e&&(r.exchangeKey.privateKey=await T().crypto.subtle.wrapKey("jwk",t.exchangeKey.privateKey,e.key,Er),r.signingKey.privateKey=await T().crypto.subtle.wrapKey("jwk",t.signingKey.privateKey,e.key,Er),r.exchangeKey.publicKey=await T().crypto.subtle.wrapKey("jwk",t.exchangeKey.publicKey.key,e.key,Er),r.signingKey.publicKey=await T().crypto.subtle.wrapKey("jwk",t.signingKey.publicKey.key,e.key,Er)),await this.db.transaction(Ps.IDENTITY_STORAGE,"readwrite").objectStore(Ps.IDENTITY_STORAGE).put(r,Ps.IDENTITY)}async loadRemoteIdentity(t){const e=await this.db.transaction(Ps.REMOTE_STORAGE).objectStore(Ps.REMOTE_STORAGE).get(t);let r=null;if(e){const t=await this.loadWrapKey();t&&(e.exchangeKey=await T().crypto.subtle.unwrapKey("jwk",e.exchangeKey,t.key,Er,Sr,!0,[]),e.signingKey=await T().crypto.subtle.unwrapKey("jwk",e.signingKey,t.key,Er,kr,!0,["verify"])),r=await V.fromJSON(e)}return r}async saveRemoteIdentity(t,e){const r=await e.toJSON(),i=await this.loadWrapKey();i&&(r.exchangeKey=await T().crypto.subtle.wrapKey("jwk",r.exchangeKey,i.key,Er),r.signingKey=await T().crypto.subtle.wrapKey("jwk",r.signingKey,i.key,Er)),await this.db.transaction(Ps.REMOTE_STORAGE,"readwrite").objectStore(Ps.REMOTE_STORAGE).put(r,t)}async loadSession(t){const e=await this.db.transaction(Ps.SESSION_STORAGE).objectStore(Ps.SESSION_STORAGE).get(t);let r=null;if(e){const i=await this.loadIdentity();if(!i)throw new Error("Identity is empty");const s=await this.loadRemoteIdentity(t);if(!s)throw new Error("Remote identity is not found");r=await it.fromJSON(i,s,e)}return r}async saveSession(t,e){const r=await e.toJSON();await this.db.transaction(Ps.SESSION_STORAGE,"readwrite").objectStore(Ps.SESSION_STORAGE).put(r,t)}}return Ps.STORAGE_NAME="webcrypto-remote",Ps.IDENTITY_STORAGE="identity",Ps.SESSION_STORAGE="sessions",Ps.REMOTE_STORAGE="remoteIdentity",Ps.WRAP_KEY="wkey",Ps.IDENTITY="identity",t.BrowserStorage=Ps,t.CertificateStorage=Cs,t.CryptoServerError=wr,t.KeyStorage=qs,t.MemoryStorage=class extends Ks{constructor(){super(...arguments),this.remoteIdentities={},this.sessions={}}async loadIdentity(){return this.identity||null}async saveIdentity(t){this.identity=t}async loadRemoteIdentity(t){return this.remoteIdentities[t]||null}async saveRemoteIdentity(t,e){this.remoteIdentities[t]=e}async loadSession(t){return this.sessions[t]||null}async saveSession(t,e){this.sessions[t]=e}},t.RatchetStorage=Ks,t.SocketCrypto=Rs,t.SocketProvider=Ts,t.getEngine=T,t.setEngine=function(t,e){R={crypto:e,name:t}},Object.defineProperty(t,"__esModule",{value:!0}),t}({},protobuf,fetch.bind(self),WebSocket);self.WebcryptoSocket=t;