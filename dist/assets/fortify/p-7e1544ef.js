import{c as r,a as t,u as e}from"./p-7005d10f.js";const n=e(r((function(r,t){!function(r){class t{static isArrayBuffer(r){return"[object ArrayBuffer]"===Object.prototype.toString.call(r)}static toArrayBuffer(r){const t=this.toUint8Array(r);return t.byteOffset||t.length?t.buffer.slice(t.byteOffset,t.byteOffset+t.length):t.buffer}static toUint8Array(r){if("undefined"!=typeof Buffer&&Buffer.isBuffer(r))return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);if(this.isArrayBuffer(r))return new Uint8Array(r);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(r){return this.isArrayBufferView(r)||this.isArrayBuffer(r)}static isArrayBufferView(r){return ArrayBuffer.isView(r)||r&&this.isArrayBuffer(r.buffer)}}function e(r){return"undefined"!=typeof Buffer&&Buffer.isBuffer(r)?new Uint8Array(r):t.isArrayBufferView(r)?new Uint8Array(r.buffer,r.byteOffset,r.byteLength):new Uint8Array(r)}class n{static isHex(r){return"string"==typeof r&&/^[a-z0-9]+$/i.test(r)}static isBase64(r){return"string"==typeof r&&/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(r)}static isBase64Url(r){return"string"==typeof r&&/^[a-zA-Z0-9-_]+$/i.test(r)}static ToString(r,t="utf8"){const n=e(r);switch(t.toLowerCase()){case"utf8":return this.ToUtf8String(n);case"binary":return this.ToBinary(n);case"hex":return this.ToHex(n);case"base64":return this.ToBase64(n);case"base64url":return this.ToBase64Url(n);default:throw new Error(`Unknown type of encoding '${t}'`)}}static FromString(r,t="utf8"){if(!r)return new ArrayBuffer(0);switch(t.toLowerCase()){case"utf8":return this.FromUtf8String(r);case"binary":return this.FromBinary(r);case"hex":return this.FromHex(r);case"base64":return this.FromBase64(r);case"base64url":return this.FromBase64Url(r);default:throw new Error(`Unknown type of encoding '${t}'`)}}static ToBase64(r){const t=e(r);if("undefined"!=typeof btoa){const r=this.ToString(t,"binary");return btoa(r)}return Buffer.from(t).toString("base64")}static FromBase64(r){const t=this.formatString(r);if(!t)return new ArrayBuffer(0);if(!n.isBase64(t))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(t)):new Uint8Array(Buffer.from(t,"base64")).buffer}static FromBase64Url(r){const t=this.formatString(r);if(!t)return new ArrayBuffer(0);if(!n.isBase64Url(t))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(t.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(r){return this.ToBase64(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(r){const t=unescape(encodeURIComponent(r)),e=new Uint8Array(t.length);for(let n=0;n<t.length;n++)e[n]=t.charCodeAt(n);return e.buffer}static ToUtf8String(r){const t=e(r),n=String.fromCharCode.apply(null,t);return decodeURIComponent(escape(n))}static FromBinary(r){const t=r.length,e=new Uint8Array(t);for(let n=0;n<t;n++)e[n]=r.charCodeAt(n);return e.buffer}static ToBinary(r){const t=e(r);let n="";const i=t.length;for(let e=0;e<i;e++)n+=String.fromCharCode(t[e]);return n}static ToHex(r){const t=e(r),n=[],i=t.length;for(let e=0;e<i;e++){const r=t[e].toString(16);n.push(1===r.length?"0"+r:r)}return n.join("")}static FromHex(r){let t=this.formatString(r);if(!t)return new ArrayBuffer(0);if(!n.isHex(t))throw new TypeError("Argument 'hexString' is not HEX encoded");t.length%2&&(t="0"+t);const e=new Uint8Array(t.length/2);for(let n=0;n<t.length;n+=2){const r=t.slice(n,n+2);e[n/2]=parseInt(r,16)}return e.buffer}static Base64Padding(r){const t=4-r.length%4;if(t<4)for(let e=0;e<t;e++)r+="=";return r}static formatString(r){return(null==r?void 0:r.replace(/[\n\r\t ]/g,""))||""}}r.BufferSourceConverter=t,r.Convert=n,r.assign=function(r){const t=arguments[0];for(let e=1;e<arguments.length;e++){const r=arguments[e];for(const e in r)t[e]=r[e]}return t},r.combine=function(...r){const t=r.map(r=>r.byteLength).reduce((r,t)=>r+t),e=new Uint8Array(t);let n=0;return r.map(r=>new Uint8Array(r)).forEach(r=>{for(const t of r)e[n++]=t}),e.buffer},r.isEqual=function(r,t){if(!r||!t)return!1;if(r.byteLength!==t.byteLength)return!1;const e=new Uint8Array(r),n=new Uint8Array(t);for(let i=0;i<r.byteLength;i++)if(e[i]!==n[i])return!1;return!0},Object.defineProperty(r,"__esModule",{value:!0})}(t)})));export{n as i}