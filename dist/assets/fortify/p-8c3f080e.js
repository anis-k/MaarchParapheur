var t=function(t,e,r,i){function s(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var n=s(r),o=s(i);class a{static isArrayBuffer(t){return"[object ArrayBuffer]"===Object.prototype.toString.call(t)}static toArrayBuffer(t){const e=this.toUint8Array(t);return e.byteOffset||e.length?e.buffer.slice(e.byteOffset,e.byteOffset+e.length):e.buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,e){if("undefined"!=typeof Buffer&&Buffer.isBuffer(t))return new e(t.buffer,t.byteOffset,t.byteLength);if(this.isArrayBuffer(t))return new e(t);if(this.isArrayBufferView(t))return new e(t.buffer,t.byteOffset,t.byteLength);throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}}class c{static isHex(t){return"string"==typeof t&&/^[a-z0-9]+$/i.test(t)}static isBase64(t){return"string"==typeof t&&/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}static isBase64Url(t){return"string"==typeof t&&/^[a-zA-Z0-9-_]+$/i.test(t)}static ToString(t,e="utf8"){const r=a.toUint8Array(t);switch(e.toLowerCase()){case"utf8":return this.ToUtf8String(r);case"binary":return this.ToBinary(r);case"hex":return this.ToHex(r);case"base64":return this.ToBase64(r);case"base64url":return this.ToBase64Url(r);default:throw new Error(`Unknown type of encoding '${e}'`)}}static FromString(t,e="utf8"){if(!t)return new ArrayBuffer(0);switch(e.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);default:throw new Error(`Unknown type of encoding '${e}'`)}}static ToBase64(t){const e=a.toUint8Array(t);if("undefined"!=typeof btoa){const t=this.ToString(e,"binary");return btoa(t)}return Buffer.from(e).toString("base64")}static FromBase64(t){const e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!c.isBase64(e))throw new TypeError("Argument 'base64Text' is not Base64 encoded");return"undefined"!=typeof atob?this.FromBinary(atob(e)):new Uint8Array(Buffer.from(e,"base64")).buffer}static FromBase64Url(t){const e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!c.isBase64Url(e))throw new TypeError("Argument 'base64url' is not Base64Url encoded");return this.FromBase64(this.Base64Padding(e.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t){const e=unescape(encodeURIComponent(t)),r=new Uint8Array(e.length);for(let i=0;i<e.length;i++)r[i]=e.charCodeAt(i);return r.buffer}static ToUtf8String(t){const e=a.toUint8Array(t);let r="";for(let i=0;i<e.length;i++)r+=String.fromCharCode(e[i]);return decodeURIComponent(escape(r))}static FromBinary(t){const e=t.length,r=new Uint8Array(e);for(let i=0;i<e;i++)r[i]=t.charCodeAt(i);return r.buffer}static ToBinary(t){const e=a.toUint8Array(t);let r="";for(let i=0;i<e.length;i++)r+=String.fromCharCode(e[i]);return r}static ToHex(t){const e=a.toUint8Array(t),r=[],i=e.length;for(let s=0;s<i;s++){const t=e[s].toString(16).padStart(2,"0");r.push(t)}return r.join("")}static FromHex(t){let e=this.formatString(t);if(!e)return new ArrayBuffer(0);if(!c.isHex(e))throw new TypeError("Argument 'hexString' is not HEX encoded");e.length%2&&(e="0"+e);const r=new Uint8Array(e.length/2);for(let i=0;i<e.length;i+=2){const t=e.slice(i,i+2);r[i/2]=parseInt(t,16)}return r.buffer}static Base64Padding(t){const e=4-t.length%4;if(e<4)for(let r=0;r<e;r++)t+="=";return t}static formatString(t){return(null==t?void 0:t.replace(/[\n\r\t ]/g,""))||""}}function h(t){const e=arguments[0];for(let r=1;r<arguments.length;r++){const t=arguments[r];for(const r in t)e[r]=t[r]}return e}function u(...t){const e=t.map(t=>t.byteLength).reduce((t,e)=>t+e),r=new Uint8Array(e);let i=0;return t.map(t=>new Uint8Array(t)).forEach(t=>{for(const e of t)r[i++]=e}),r.buffer}function f(t,e){if(!t||!e)return!1;if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),i=new Uint8Array(e);for(let s=0;s<t.byteLength;s++)if(r[s]!==i[s])return!1;return!0}
/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */function l(t,e,r,i){var s,n=arguments.length,o=n<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,r,i);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(o=(n<3?s(o):n>3?s(e,r,o):s(e,r))||o);return n>3&&o&&Object.defineProperty(e,r,o),o}class d{static async set(t){return new Uint8Array(t)}static async get(t){return new Uint8Array(t).buffer}}function y(t){return r=>{const i=r;i.localName=t.name||i.name||i.toString().match(/^function\s*([^\s(]+)/)[1],i.items=i.items||{},i.target=r,i.items=h({},i.items);const s=new e.Type(i.localName);for(const t in i.items){const r=i.items[t];let n=void 0;r.repeated?n="repeated":r.required&&(n="required"),s.add(new e.Field(r.name,r.id,r.type,n))}i.protobuf=s}}function w(t){return(e,r)=>{const i=e.constructor,s=r;i.items=i.items||{},i.target!==i&&(i.items=h({},i.items),i.target=i),i.items[s]={id:t.id,type:t.type||"bytes",defaultValue:t.defaultValue,converter:t.converter||null,parser:t.parser||null},t.name=t.name||s,i.items[s].name=t.name,i.items[s].required=t.required||!1,i.items[s].repeated=t.repeated||!1,function(t,e,r){const i="_"+e,s={set:function(t){this[i]!==t&&(this.raw=null,this[i]=t)},get:function(){if(void 0===this[i]){let t=r.defaultValue;r.parser&&!r.repeated&&(t=new r.parser),this[i]=t}return this[i]},enumerable:!0};Object.defineProperty(t,i,{writable:!0,enumerable:!1}),Object.defineProperty(t,e,s)}(e,s,i.items[s])}}class p{static async importProto(t){const e=new this;return await e.importProto(t),e}isEmpty(){return void 0===this.raw}hasChanged(){if(null===this.raw)return!0;const t=this.constructor,e=this;for(const r in t.items){const i=t.items[r];if(i.repeated){if(i.parser)return e[r].some(t=>t.hasChanged())}else if(i.parser&&e[r]&&e[r].hasChanged())return!0}return!1}async importProto(t){const e=this.constructor,r=this;let i,s;s=t instanceof p?await t.exportProto():t;try{i=e.protobuf.decode(new Uint8Array(s))}catch(n){throw new Error(`Error: Cannot decode message for ${e.localName}.\n$ProtobufError: ${n.message}`)}for(const o in e.items){const t=e.items[o];let s=i[t.name];ArrayBuffer.isView(s)&&(s=new Uint8Array(s)),Array.isArray(s)||(t.repeated?r[o]=s=[]:s=[s]),t.repeated&&!r[o]&&(r[o]=[]);for(const e of s)t.repeated?r[o].push(await this.importItem(t,e)):r[o]=await this.importItem(t,e)}this.raw=s}async exportProto(){if(!this.hasChanged())return this.raw;const t=this.constructor,e=this,r={};for(const i in t.items){const s=t.items[i];let n=e[i];Array.isArray(n)||(n=void 0===n?[]:[n]);for(const t of n){const e=await this.exportItem(s,t);s.repeated?(r[s.name]||(r[s.name]=[]),r[s.name].push(e)):r[s.name]=e}}return this.raw=new Uint8Array(t.protobuf.encode(r).finish()).buffer,this.raw}async exportItem(t,e){const r=this.constructor;let i;if(t.parser){const s=e,n=await s.exportProto();if(t.required&&!n)throw new Error(`Error: Paramter '${t.name}' is required in '${r.localName}' protobuf message.`);n&&(i=new Uint8Array(n))}else{if(t.required&&void 0===e)throw new Error(`Error: Paramter '${t.name}' is required in '${r.localName}' protobuf message.`);t.converter?void 0!==e&&(i=await t.converter.set(e)):(e instanceof ArrayBuffer&&(e=new Uint8Array(e)),i=e)}return i}async importItem(t,e){const r=this.constructor;let i;if(t.parser){const s=t.parser;if(e&&e.byteLength)i=await s.importProto(new Uint8Array(e).buffer);else if(t.required)throw new Error(`Error: Parameter '${t.name}' is required in '${r.localName}' protobuf message.`)}else if(t.converter){if(e&&e.byteLength)i=await t.converter.get(e);else if(t.required)throw new Error(`Error: Parameter '${t.name}' is required in '${r.localName}' protobuf message.`)}else i=e;return i}}function v(){}function g(){g.init.call(this)}function m(t){return void 0===t._maxListeners?g.defaultMaxListeners:t._maxListeners}function b(t,e,r){if(e)t.call(r);else for(var i=t.length,s=U(t,i),n=0;n<i;++n)s[n].call(r)}function A(t,e,r,i){if(e)t.call(r,i);else for(var s=t.length,n=U(t,s),o=0;o<s;++o)n[o].call(r,i)}function S(t,e,r,i,s){if(e)t.call(r,i,s);else for(var n=t.length,o=U(t,n),a=0;a<n;++a)o[a].call(r,i,s)}function B(t,e,r,i,s,n){if(e)t.call(r,i,s,n);else for(var o=t.length,a=U(t,o),c=0;c<o;++c)a[c].call(r,i,s,n)}function E(t,e,r,i){if(e)t.apply(r,i);else for(var s=t.length,n=U(t,s),o=0;o<s;++o)n[o].apply(r,i)}function k(t,e,r,i){var s,n,o,a;if("function"!=typeof r)throw new TypeError('"listener" argument must be a function');if((n=t._events)?(n.newListener&&(t.emit("newListener",e,r.listener?r.listener:r),n=t._events),o=n[e]):(n=t._events=new v,t._eventsCount=0),o){if("function"==typeof o?o=n[e]=i?[r,o]:[o,r]:i?o.unshift(r):o.push(r),!o.warned&&(s=m(t))&&s>0&&o.length>s){o.warned=!0;var c=new Error("Possible EventEmitter memory leak detected. "+o.length+" "+e+" listeners added. Use emitter.setMaxListeners() to increase limit");c.name="MaxListenersExceededWarning",c.emitter=t,c.type=e,c.count=o.length,a=c,"function"==typeof console.warn?console.warn(a):console.log(a)}}else o=n[e]=r,++t._eventsCount;return t}function x(t,e,r){var i=!1;function s(){t.removeListener(e,s),i||(i=!0,r.apply(t,arguments))}return s.listener=r,s}function N(t){var e=this._events;if(e){var r=e[t];if("function"==typeof r)return 1;if(r)return r.length}return 0}function U(t,e){for(var r=new Array(e);e--;)r[e]=t[e];return r}v.prototype=Object.create(null),g.EventEmitter=g,g.usingDomains=!1,g.prototype.domain=void 0,g.prototype._events=void 0,g.prototype._maxListeners=void 0,g.defaultMaxListeners=10,g.init=function(){this.domain=null,this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=new v,this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},g.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||isNaN(t))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=t,this},g.prototype.getMaxListeners=function(){return m(this)},g.prototype.emit=function(t){var e,r,i,s,n,o,a,c="error"===t;if(o=this._events)c=c&&null==o.error;else if(!c)return!1;if(a=this.domain,c){if(e=arguments[1],!a){if(e instanceof Error)throw e;var h=new Error('Uncaught, unspecified "error" event. ('+e+")");throw h.context=e,h}return e||(e=new Error('Uncaught, unspecified "error" event')),e.domainEmitter=this,e.domain=a,e.domainThrown=!1,a.emit("error",e),!1}if(!(r=o[t]))return!1;var u="function"==typeof r;switch(i=arguments.length){case 1:b(r,u,this);break;case 2:A(r,u,this,arguments[1]);break;case 3:S(r,u,this,arguments[1],arguments[2]);break;case 4:B(r,u,this,arguments[1],arguments[2],arguments[3]);break;default:for(s=new Array(i-1),n=1;n<i;n++)s[n-1]=arguments[n];E(r,u,this,s)}return!0},g.prototype.on=g.prototype.addListener=function(t,e){return k(this,t,e,!1)},g.prototype.prependListener=function(t,e){return k(this,t,e,!0)},g.prototype.once=function(t,e){if("function"!=typeof e)throw new TypeError('"listener" argument must be a function');return this.on(t,x(this,t,e)),this},g.prototype.prependOnceListener=function(t,e){if("function"!=typeof e)throw new TypeError('"listener" argument must be a function');return this.prependListener(t,x(this,t,e)),this},g.prototype.removeListener=function(t,e){var r,i,s,n,o;if("function"!=typeof e)throw new TypeError('"listener" argument must be a function');if(!(i=this._events))return this;if(!(r=i[t]))return this;if(r===e||r.listener&&r.listener===e)0==--this._eventsCount?this._events=new v:(delete i[t],i.removeListener&&this.emit("removeListener",t,r.listener||e));else if("function"!=typeof r){for(s=-1,n=r.length;n-- >0;)if(r[n]===e||r[n].listener&&r[n].listener===e){o=r[n].listener,s=n;break}if(s<0)return this;if(1===r.length){if(r[0]=void 0,0==--this._eventsCount)return this._events=new v,this;delete i[t]}else!function(t,e){for(var r=e,i=r+1,s=t.length;i<s;r+=1,i+=1)t[r]=t[i];t.pop()}(r,s);i.removeListener&&this.emit("removeListener",t,o||e)}return this},g.prototype.removeAllListeners=function(t){var e,r;if(!(r=this._events))return this;if(!r.removeListener)return 0===arguments.length?(this._events=new v,this._eventsCount=0):r[t]&&(0==--this._eventsCount?this._events=new v:delete r[t]),this;if(0===arguments.length){for(var i,s=Object.keys(r),n=0;n<s.length;++n)"removeListener"!==(i=s[n])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=new v,this._eventsCount=0,this}if("function"==typeof(e=r[t]))this.removeListener(t,e);else if(e)do{this.removeListener(t,e[e.length-1])}while(e[0]);return this},g.prototype.listeners=function(t){var e,r=this._events;return r&&(e=r[t])?"function"==typeof e?[e.listener||e]:function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(e):[]},g.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):N.call(t,e)},g.prototype.listenerCount=N,g.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};const I=c.FromBinary("InfoText"),C=c.FromBinary("InfoRatchet"),q=c.FromBinary("InfoMessageKeys");let O=null;function R(){if(!O)throw new Error("WebCrypto engine is empty. Use setEngine to resolve it.");return O}"undefined"!=typeof self&&(O={crypto:self.crypto,name:"WebCrypto"});let T=(()=>{class t{static async generateKeyPair(t,e){const r=t,i="ECDSA"===t?["sign","verify"]:["deriveKey","deriveBits"],s=await R().crypto.subtle.generateKey({name:r,namedCurve:this.NAMED_CURVE},e,i),n=await j.create(s.publicKey);return{privateKey:s.privateKey,publicKey:n}}static deriveBytes(t,e){return R().crypto.subtle.deriveBits({name:"ECDH",public:e.key},t,256)}static verify(t,e,r){return R().crypto.subtle.verify({name:"ECDSA",hash:this.DIGEST_ALGORITHM},t.key,r,e)}static async sign(t,e){return R().crypto.subtle.sign({name:"ECDSA",hash:this.DIGEST_ALGORITHM},t,e)}static async ecKeyPairToJson(t){return{privateKey:t.privateKey,publicKey:t.publicKey.key,thumbprint:await t.publicKey.thumbprint()}}static async ecKeyPairFromJson(t){return{privateKey:t.privateKey,publicKey:await j.create(t.publicKey)}}}return t.NAMED_CURVE="P-256",t.DIGEST_ALGORITHM="SHA-512",t})();const K={name:"AES-CBC",length:256};class D{static randomBytes(t){const e=new Uint8Array(t);return R().crypto.getRandomValues(e),e.buffer}static digest(t,e){return R().crypto.subtle.digest(t,e)}static encrypt(t,e,r){return R().crypto.subtle.encrypt({name:"AES-CBC",iv:new Uint8Array(r)},t,e)}static decrypt(t,e,r){return R().crypto.subtle.decrypt({name:"AES-CBC",iv:new Uint8Array(r)},t,e)}static importHMAC(t){return R().crypto.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign","verify"])}static importAES(t){return R().crypto.subtle.importKey("raw",t,K,!1,["encrypt","decrypt"])}static async sign(t,e){return await R().crypto.subtle.sign({name:"HMAC",hash:"SHA-256"},t,e)}static async HKDF(t,e=1,r,i=new ArrayBuffer(0)){r||(r=await this.importHMAC(new Uint8Array(32).buffer));const s=await this.sign(r,t),n=await this.importHMAC(s),o=[new ArrayBuffer(0)];for(let a=0;a<e;a++)o[a+1]=await this.sign(n,u(o[a],i,new Uint8Array([a+1]).buffer));return o.slice(1)}}class j{static async create(t){const e=new this,r=t.algorithm.name.toUpperCase();if("ECDH"!==r&&"ECDSA"!==r)throw new Error("Error: Unsupported asymmetric key algorithm.");if("public"!==t.type)throw new Error("Error: Expected key type to be public but it was not.");e.key=t;const i=await R().crypto.subtle.exportKey("jwk",t);if(!i.x||!i.y)throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const s=c.FromBase64Url(i.x),n=c.FromBase64Url(i.y),o=c.ToBinary(s)+c.ToBinary(n);return e.serialized=c.FromBinary(o),e.id=await e.thumbprint(),e}static async importKey(t,e){const r=c.ToBase64Url(t.slice(0,32)),i=c.ToBase64Url(t.slice(32)),s={crv:T.NAMED_CURVE,kty:"EC",x:r,y:i},n="ECDSA"===e?["verify"]:[],o=await R().crypto.subtle.importKey("jwk",s,{name:e,namedCurve:T.NAMED_CURVE},!0,n);return await j.create(o)}serialize(){return this.serialized}async thumbprint(){const t=await this.serialize(),e=await D.digest("SHA-256",t);return c.ToHex(e)}async isEqual(t){return!!(t&&t instanceof j)&&f(this.serialized,t.serialized)}}class ${constructor(t,e,r){this.id=t,this.signingKey=e,this.exchangeKey=r,this.preKeys=[],this.signedPreKeys=[]}static async fromJSON(t){const e=await T.ecKeyPairFromJson(t.signingKey),r=await T.ecKeyPairFromJson(t.exchangeKey),i=new this(t.id,e,r);return i.createdAt=new Date(t.createdAt),await i.fromJSON(t),i}static async create(t,e=0,r=0,i=!1){const s=await T.generateKeyPair("ECDSA",i),n=await T.generateKeyPair("ECDH",i),o=new $(t,s,n);o.createdAt=new Date;for(let a=0;a<r;a++)o.preKeys.push(await T.generateKeyPair("ECDH",i));for(let a=0;a<e;a++)o.signedPreKeys.push(await T.generateKeyPair("ECDH",i));return o}async toJSON(){const t=[],e=[];for(const r of this.preKeys)t.push(await T.ecKeyPairToJson(r));for(const r of this.signedPreKeys)e.push(await T.ecKeyPairToJson(r));return{createdAt:this.createdAt.toISOString(),exchangeKey:await T.ecKeyPairToJson(this.exchangeKey),id:this.id,preKeys:t,signedPreKeys:e,signingKey:await T.ecKeyPairToJson(this.signingKey)}}async fromJSON(t){this.id=t.id,this.signingKey=await T.ecKeyPairFromJson(t.signingKey),this.exchangeKey=await T.ecKeyPairFromJson(t.exchangeKey),this.preKeys=[];for(const e of t.preKeys)this.preKeys.push(await T.ecKeyPairFromJson(e));this.signedPreKeys=[];for(const e of t.signedPreKeys)this.signedPreKeys.push(await T.ecKeyPairFromJson(e))}}class P{static fill(t){const e=new P;return e.fill(t),e}static async fromJSON(t){const e=new this;return await e.fromJSON(t),e}fill(t){this.signingKey=t.signingKey,this.exchangeKey=t.exchangeKey,this.signature=t.signature,this.createdAt=t.createdAt}verify(){return T.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async toJSON(){return{createdAt:this.createdAt.toISOString(),exchangeKey:await this.exchangeKey.key,id:this.id,signature:this.signature,signingKey:await this.signingKey.key,thumbprint:await this.signingKey.thumbprint()}}async fromJSON(t){if(this.id=t.id,this.signature=t.signature,this.signingKey=await j.create(t.signingKey),this.exchangeKey=await j.create(t.exchangeKey),this.createdAt=new Date(t.createdAt),!(await this.verify()))throw new Error("Error: Wrong signature for RemoteIdentity")}}let J=(()=>{let t=class extends p{};return l([w({id:0,type:"uint32",defaultValue:1})],t.prototype,"version",void 0),t=l([y({name:"Base"})],t),t})();class V{static async set(t){return new Uint8Array(t.serialize())}static async get(t){return j.importKey(t.buffer,"ECDSA")}}class M{static async set(t){return new Uint8Array(t.serialize())}static async get(t){return j.importKey(t.buffer,"ECDH")}}class H{static async set(t){return new Uint8Array(c.FromString(t.toISOString()))}static async get(t){return new Date(c.ToString(t))}}let W=(()=>{var t;let e=t=class extends J{static async fill(e){const r=new t;return await r.fill(e),r}async sign(t){this.signature=await T.sign(t,this.exchangeKey.serialize())}async verify(){return await T.verify(this.signingKey,this.exchangeKey.serialize(),this.signature)}async fill(t){this.signingKey=t.signingKey.publicKey,this.exchangeKey=t.exchangeKey.publicKey,this.createdAt=t.createdAt,await this.sign(t.signingKey.privateKey)}};return l([w({id:1,converter:V})],e.prototype,"signingKey",void 0),l([w({id:2,converter:M})],e.prototype,"exchangeKey",void 0),l([w({id:3})],e.prototype,"signature",void 0),l([w({id:4,converter:H})],e.prototype,"createdAt",void 0),e=t=l([y({name:"Identity"})],e),e})(),_=(()=>{let t=class extends J{};return l([w({id:1,converter:M,required:!0})],t.prototype,"senderRatchetKey",void 0),l([w({id:2,type:"uint32",required:!0})],t.prototype,"counter",void 0),l([w({id:3,type:"uint32",required:!0})],t.prototype,"previousCounter",void 0),l([w({id:4,converter:d,required:!0})],t.prototype,"cipherText",void 0),t=l([y({name:"Message"})],t),t})(),L=(()=>{let t=class extends J{async sign(t){this.signature=await this.signHMAC(t)}async verify(t){return f(await this.signHMAC(t),this.signature)}async getSignedRaw(){return u(this.receiverKey.serialize(),this.senderKey.serialize(),await this.message.exportProto())}async signHMAC(t){const e=await this.getSignedRaw();return await D.sign(t,e)}};return l([w({id:1,converter:V,required:!0})],t.prototype,"senderKey",void 0),l([w({id:2,parser:_,required:!0})],t.prototype,"message",void 0),l([w({id:3,required:!0})],t.prototype,"signature",void 0),t=l([y({name:"MessageSigned"})],t),t})(),G=(()=>{let t=class extends J{};return l([w({id:1,type:"uint32",required:!0})],t.prototype,"registrationId",void 0),l([w({id:2,type:"uint32"})],t.prototype,"preKeyId",void 0),l([w({id:3,type:"uint32",required:!0})],t.prototype,"preKeySignedId",void 0),l([w({id:4,converter:M,required:!0})],t.prototype,"baseKey",void 0),l([w({id:5,parser:W,required:!0})],t.prototype,"identity",void 0),l([w({id:6,parser:L,required:!0})],t.prototype,"signedMessage",void 0),t=l([y({name:"PreKeyMessage"})],t),t})(),z=(()=>{let t=class extends J{};return l([w({id:1,type:"uint32",required:!0})],t.prototype,"id",void 0),l([w({id:2,converter:M,required:!0})],t.prototype,"key",void 0),t=l([y({name:"PreKey"})],t),t})(),F=(()=>{let t=class extends z{async sign(t){this.signature=await T.sign(t,this.key.serialize())}verify(t){return T.verify(t,this.key.serialize(),this.signature)}};return l([w({id:3,converter:d,required:!0})],t.prototype,"signature",void 0),t=l([y({name:"PreKeySigned"})],t),t})(),Z=(()=>{let t=class extends J{};return l([w({id:1,type:"uint32",required:!0})],t.prototype,"registrationId",void 0),l([w({id:2,parser:W,required:!0})],t.prototype,"identity",void 0),l([w({id:3,parser:z})],t.prototype,"preKey",void 0),l([w({id:4,parser:F,required:!0})],t.prototype,"preKeySigned",void 0),t=l([y({name:"PreKeyBundle"})],t),t})();const X=new Uint8Array([1]).buffer,Q=new Uint8Array([2]).buffer;class Y{constructor(t){this.counter=0,this.rootKey=t}static async fromJSON(t){const e=new this(t.rootKey);return e.fromJSON(t),e}async toJSON(){return{counter:this.counter,rootKey:this.rootKey}}async fromJSON(t){this.counter=t.counter,this.rootKey=t.rootKey}async calculateKey(t){const e=await D.sign(t,X),r=await D.sign(t,Q);return{cipher:e,rootKey:await D.importHMAC(r)}}async click(){const t=this.rootKey,e=await this.calculateKey(t);return this.rootKey=e.rootKey,this.counter++,e.cipher}}class tt extends Y{async encrypt(t){const e=await this.click(),r=await D.HKDF(e,3,void 0,q),i=await D.importAES(r[0]),s=await D.importHMAC(r[1]),n=r[2].slice(0,16);return{cipherText:await D.encrypt(i,t,n),hmacKey:s}}}class et extends Y{constructor(){super(...arguments),this.keys=[]}async toJSON(){const t=await super.toJSON();return t.keys=this.keys,t}async fromJSON(t){await super.fromJSON(t),this.keys=t.keys}async decrypt(t,e){const r=await this.getKey(e),i=await D.HKDF(r,3,void 0,q),s=await D.importAES(i[0]),n=await D.importHMAC(i[1]),o=i[2].slice(0,16);return{cipherText:await D.decrypt(s,t,o),hmacKey:n}}async getKey(t){for(;this.counter<=t;){const t=await this.click();this.keys.push(t)}return this.keys[t]}}class rt extends g{constructor(t={}){super(),this.options=t,this.counter=0,this.currentStep=new it,this.steps=new st(20),this.promises={}}static async create(t,e,r={}){let i;const s=new rt(r);if(e instanceof Z){if(!(await e.identity.verify()))throw new Error("Error: Remote client's identity key is invalid.");if(!(await e.preKeySigned.verify(e.identity.signingKey)))throw new Error("Error: Remote client's signed prekey is invalid.");s.currentRatchetKey=await s.generateRatchetKey(),s.currentStep.remoteRatchetKey=e.preKeySigned.key,s.remoteIdentity=P.fill(e.identity),s.remoteIdentity.id=e.registrationId,s.remotePreKeyId=e.preKey.id,s.remotePreKeySignedId=e.preKeySigned.id,i=await async function(t,e,r,i,s){const n=await T.deriveBytes(t.exchangeKey.privateKey,i),o=await T.deriveBytes(e.privateKey,r),a=await T.deriveBytes(e.privateKey,i);let c=new ArrayBuffer(0);s&&(c=await T.deriveBytes(e.privateKey,s));const h=new Uint8Array(32);for(let u=0;u<h.length;u++)h[u]=255;const f=u(h.buffer,n,o,a,c),l=await D.HKDF(f,1,void 0,I);return await D.importHMAC(l[0])}(t,s.currentRatchetKey,e.identity.exchangeKey,e.preKeySigned.key,e.preKey.key)}else{if(!(await e.identity.verify()))throw new Error("Error: Remote client's identity key is invalid.");const r=t.signedPreKeys[e.preKeySignedId];if(!r)throw new Error(`Error: PreKey with id ${e.preKeySignedId} not found`);let n;void 0!==e.preKeyId&&(n=t.preKeys[e.preKeyId]),s.remoteIdentity=P.fill(e.identity),s.currentRatchetKey=r,i=await async function(t,e,r,i,s){const n=await T.deriveBytes(e.privateKey,r),o=await T.deriveBytes(t.exchangeKey.privateKey,i),a=await T.deriveBytes(e.privateKey,i);let c=new ArrayBuffer(0);s&&(c=await T.deriveBytes(s,i));const h=new Uint8Array(32);for(let u=0;u<h.length;u++)h[u]=255;const f=u(h.buffer,n,o,a,c),l=await D.HKDF(f,1,void 0,I);return await D.importHMAC(l[0])}(t,s.currentRatchetKey,e.identity.exchangeKey,e.signedMessage.message.senderRatchetKey,n&&n.privateKey)}return s.identity=t,s.id=t.id,s.rootKey=i,s}static async fromJSON(t,e,r){const i=new rt;return i.identity=t,i.remoteIdentity=e,await i.fromJSON(r),i}on(t,e){return super.on(t,e)}once(t,e){return super.once(t,e)}async decrypt(t){return this.queuePromise("encrypt",async()=>{const e=t.message.senderRatchetKey,r=t.message;if(t.message.previousCounter<this.counter-20)throw new Error("Error: Too old message");let i=this.steps.getStep(e);if(!i){const t=new it;t.remoteRatchetKey=e,this.steps.push(t),this.currentStep=t,i=t}i.receivingChain||(i.receivingChain=await this.createChain(this.currentRatchetKey.privateKey,e,et));const s=await i.receivingChain.decrypt(r.cipherText,r.counter);if(this.update(),t.senderKey=this.remoteIdentity.signingKey,t.receiverKey=this.identity.signingKey.publicKey,!(await t.verify(s.hmacKey)))throw new Error("Error: The Message did not successfully verify!");return s.cipherText})}async encrypt(t){return this.queuePromise("encrypt",async()=>{if(this.currentStep.receivingChain&&!this.currentStep.sendingChain&&(this.counter++,this.currentRatchetKey=await this.generateRatchetKey()),!this.currentStep.sendingChain){if(!this.currentStep.remoteRatchetKey)throw new Error("currentStep has empty remoteRatchetKey");this.currentStep.sendingChain=await this.createChain(this.currentRatchetKey.privateKey,this.currentStep.remoteRatchetKey,tt)}const e=await this.currentStep.sendingChain.encrypt(t);let r;this.update(),0!==this.steps.length||this.currentStep.receivingChain||1!==this.currentStep.sendingChain.counter||(r=new G,r.registrationId=this.identity.id,r.preKeyId=this.remotePreKeyId,r.preKeySignedId=this.remotePreKeySignedId,r.baseKey=this.currentRatchetKey.publicKey,await r.identity.fill(this.identity));const i=new L;return i.receiverKey=this.remoteIdentity.signingKey,i.senderKey=this.identity.signingKey.publicKey,i.message.cipherText=e.cipherText,i.message.counter=this.currentStep.sendingChain.counter-1,i.message.previousCounter=this.counter,i.message.senderRatchetKey=this.currentRatchetKey.publicKey,await i.sign(e.hmacKey),r?(r.signedMessage=i,r):i})}async hasRatchetKey(t){let e;e=t instanceof j?t:await j.create(t);for(const r of this.steps.items)if(await r.remoteRatchetKey.isEqual(e))return!0;return!1}async toJSON(){return{counter:this.counter,ratchetKey:await T.ecKeyPairToJson(this.currentRatchetKey),remoteIdentity:await this.remoteIdentity.signingKey.thumbprint(),rootKey:this.rootKey,steps:await this.steps.toJSON()}}async fromJSON(t){this.currentRatchetKey=await T.ecKeyPairFromJson(t.ratchetKey),this.counter=t.counter,this.rootKey=t.rootKey;for(const e of t.steps)this.currentStep=await it.fromJSON(e),this.steps.push(this.currentStep)}update(){this.emit("update")}generateRatchetKey(){return T.generateKeyPair("ECDH",!!this.options.exportableKeys)}async createChain(t,e,r){const i=await T.deriveBytes(t,e),s=await D.HKDF(i,2,this.rootKey,C),n=await D.importHMAC(s[0]),o=new r(await D.importHMAC(s[1]));return this.rootKey=n,o}queuePromise(t,e){const r=this.promises[t]||Promise.resolve(),i=this.promises[t]=r.then(e,e);return i.then(()=>{this.promises[t]===i&&delete this.promises[t]}),i}}class it{static async fromJSON(t){const e=new this;return await e.fromJSON(t),e}async toJSON(){const t={};return this.remoteRatchetKey&&(t.remoteRatchetKey=this.remoteRatchetKey.key),this.sendingChain&&(t.sendingChain=await this.sendingChain.toJSON()),this.receivingChain&&(t.receivingChain=await this.receivingChain.toJSON()),t}async fromJSON(t){t.remoteRatchetKey&&(this.remoteRatchetKey=await j.create(t.remoteRatchetKey)),t.sendingChain&&(this.sendingChain=await tt.fromJSON(t.sendingChain)),t.receivingChain&&(this.receivingChain=await et.fromJSON(t.receivingChain))}}class st extends class{constructor(t=20){this.items=[],this.maxSize=t}get length(){return this.items.length}get latest(){return this.items[this.length-1]}push(t){this.length===this.maxSize&&(this.items=this.items.slice(1)),this.items.push(t)}async toJSON(){const t=[];for(const e of this.items)t.push(await e.toJSON());return t}async fromJSON(t){this.items=t}}{getStep(t){let e;return this.items.some(r=>(r.remoteRatchetKey.id===t.id&&(e=r),!!e)),e}}
/*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */function nt(t,e,r,i){var s,n=arguments.length,o=n<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,r):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(t,e,r,i);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(o=(n<3?s(o):n>3?s(e,r,o):s(e,r))||o);return n>3&&o&&Object.defineProperty(e,r,o),o}class ot{static async set(t){return new Uint8Array(c.FromUtf8String(t.toISOString()))}static async get(t){return new Date(c.ToUtf8String(t))}}class at{static async set(t){return new Uint8Array(c.FromHex(t))}static async get(t){return c.ToHex(t)}}class ct{static async set(t){return new Uint8Array(c.FromUtf8String(t.toString(10)))}static async get(t){return parseInt(c.ToUtf8String(t),10)}}var ht,ut,ft,lt,dt,yt,wt,pt,vt;let gt=ht=class extends p{constructor(){super(...arguments),this.version=0}};gt.INDEX=1,nt([w({id:ht.INDEX++,type:"uint32",required:!0,defaultValue:1})],gt.prototype,"version",void 0),gt=ht=nt([y({name:"BaseMessage"})],gt);let mt=ut=class extends gt{constructor(){super(),this.actionId="",this.action=this.constructor.ACTION}};mt.INDEX=gt.INDEX,mt.ACTION="action",nt([w({id:ut.INDEX++,type:"string",required:!0})],mt.prototype,"action",void 0),nt([w({id:ut.INDEX++,type:"string",required:!1})],mt.prototype,"actionId",void 0),mt=ut=nt([y({name:"Action"})],mt);let bt=ft=class extends gt{constructor(){super(...arguments),this.name=""}isEmpty(){return!this.name}toAlgorithm(){return{name:this.name}}fromAlgorithm(t){this.name=t.name}};bt.INDEX=gt.INDEX,nt([w({id:ft.INDEX++,type:"string",required:!0})],bt.prototype,"name",void 0),bt=ft=nt([y({name:"BaseAlgorithm"})],bt);let At=lt=class extends bt{toAlgorithm(){const t={},e=this.constructor;for(const r in e.items){if("version"===r)continue;const e=this[r];"labelStr"!==r?void 0!==e&&(e instanceof bt?e.isEmpty()||(t[r]=e.toAlgorithm()):t[r]=e):t.label=e}return t}fromAlgorithm(t){t instanceof lt&&(t=t.toAlgorithm());const e=this.constructor;for(const r in t)if(e.items&&r in e.items){const i=e.items[r];if(i.parser)switch(i.parser){case bt:this[r].fromAlgorithm(t[r]);break;default:throw new Error(`Unsupported parser '${i.parser.name}'`)}else"label"===r&&"string"==typeof t.label?this.labelStr=t.label:this[r]=t[r]}}};At.INDEX=bt.INDEX,nt([w({id:lt.INDEX++,type:"bytes",parser:bt})],At.prototype,"hash",void 0),nt([w({id:lt.INDEX++,type:"bytes"})],At.prototype,"publicExponent",void 0),nt([w({id:lt.INDEX++,type:"uint32"})],At.prototype,"modulusLength",void 0),nt([w({id:lt.INDEX++,type:"uint32"})],At.prototype,"saltLength",void 0),nt([w({id:lt.INDEX++,type:"bytes"})],At.prototype,"label",void 0),nt([w({id:lt.INDEX++,type:"string"})],At.prototype,"namedCurve",void 0),nt([w({id:lt.INDEX++,converter:d})],At.prototype,"public",void 0),nt([w({id:lt.INDEX++,type:"uint32"})],At.prototype,"length",void 0),nt([w({id:lt.INDEX++})],At.prototype,"iv",void 0),nt([w({id:lt.INDEX++,type:"bool"})],At.prototype,"token",void 0),nt([w({id:lt.INDEX++,type:"bool"})],At.prototype,"sensitive",void 0),nt([w({id:lt.INDEX++,type:"string"})],At.prototype,"labelStr",void 0),At=lt=nt([y({name:"Algorithm"})],At);let St=dt=class extends gt{constructor(){super(...arguments),this.providerID="",this.id="",this.type=""}};St.INDEX=gt.INDEX,nt([w({id:dt.INDEX++,type:"string",required:!0})],St.prototype,"providerID",void 0),nt([w({id:dt.INDEX++,type:"bytes",required:!0,converter:at})],St.prototype,"id",void 0),nt([w({id:dt.INDEX++,type:"string",required:!0})],St.prototype,"type",void 0),St=dt=nt([y({name:"CryptoItem"})],St);let Bt=yt=class extends St{constructor(){super(...arguments),this.type="secret",this.algorithm={name:""},this.extractable=!1,this.usages=[]}};Bt.INDEX=St.INDEX,nt([w({id:yt.INDEX++,type:"bytes",required:!0,converter:class{static async set(t){const e=new At;e.fromAlgorithm(t);const r=await e.exportProto();return new Uint8Array(r)}static async get(t){const e=new At;return await e.importProto(t),e.toAlgorithm()}}})],Bt.prototype,"algorithm",void 0),nt([w({id:yt.INDEX++,type:"bool"})],Bt.prototype,"extractable",void 0),nt([w({id:yt.INDEX++,type:"string",repeated:!0})],Bt.prototype,"usages",void 0),Bt=yt=nt([y({name:"CryptoKey"})],Bt);let Et=wt=class extends gt{constructor(){super(...arguments),this.privateKey=new Bt,this.publicKey=new Bt}};Et.INDEX=gt.INDEX,nt([w({id:wt.INDEX++,name:"privateKey",type:"bytes",required:!0,parser:Bt})],Et.prototype,"privateKey",void 0),nt([w({id:wt.INDEX++,name:"publicKey",type:"bytes",parser:Bt})],Et.prototype,"publicKey",void 0),Et=wt=nt([y({name:"CryptoKeyPair"})],Et);let kt=pt=class extends gt{constructor(t,e=0,r="error"){super(),this.code=0,this.type="error",this.message="",this.name="Error",this.stack="",t&&(this.message=t,this.code=e,this.type=r)}};kt.INDEX=gt.INDEX,nt([w({id:pt.INDEX++,type:"uint32",defaultValue:0})],kt.prototype,"code",void 0),nt([w({id:pt.INDEX++,type:"string",defaultValue:"error"})],kt.prototype,"type",void 0),nt([w({id:pt.INDEX++,type:"string",defaultValue:""})],kt.prototype,"message",void 0),nt([w({id:pt.INDEX++,type:"string",defaultValue:"Error"})],kt.prototype,"name",void 0),nt([w({id:pt.INDEX++,type:"string",defaultValue:""})],kt.prototype,"stack",void 0),kt=pt=nt([y({name:"Error"})],kt);let xt=vt=class extends mt{constructor(t){super(),this.status=!1,t&&(this.actionId=t.actionId,this.action=t.action)}};xt.INDEX=mt.INDEX,nt([w({id:vt.INDEX++,type:"bool",defaultValue:!1})],xt.prototype,"status",void 0),nt([w({id:vt.INDEX++,type:"bytes",parser:kt})],xt.prototype,"error",void 0),nt([w({id:vt.INDEX++,type:"bytes",converter:d})],xt.prototype,"data",void 0),xt=vt=nt([y({name:"Result"})],xt);let Nt=class extends mt{};Nt.INDEX=mt.INDEX,Nt.ACTION="auth",Nt=nt([y({name:"AuthRequest"})],Nt);let Ut=class extends mt{};Ut.INDEX=mt.INDEX,Ut.ACTION="server/login",Ut=nt([y({})],Ut);let It=class extends mt{};var Ct;It.INDEX=mt.INDEX,It.ACTION="server/isLoggedIn",It=nt([y({})],It);let qt=class extends mt{};qt.INDEX=mt.INDEX,qt.ACTION="cardReader",qt=nt([y({})],qt);let Ot=class extends mt{};Ot.INDEX=mt.INDEX,Ot.ACTION="cardReader/readers",Ot=nt([y({})],Ot);let Rt=Ct=class extends qt{constructor(t,e){super(),this.reader="",this.atr="",t&&e&&(this.reader=t,this.atr=e)}};Rt.INDEX=qt.INDEX,nt([w({id:Ct.INDEX++,required:!0,type:"string",defaultValue:""})],Rt.prototype,"reader",void 0),nt([w({id:Ct.INDEX++,required:!0,converter:at})],Rt.prototype,"atr",void 0),Rt=Ct=nt([y({})],Rt);let Tt=class extends Rt{};Tt.INDEX=Rt.INDEX,Tt.ACTION=Rt.ACTION+"/insert",Tt=nt([y({})],Tt);let Kt=class extends Rt{};var Dt;Kt.INDEX=Rt.INDEX,Kt.ACTION=Rt.ACTION+"/remove",Kt=nt([y({})],Kt);let jt=Dt=class extends mt{constructor(){super(...arguments),this.providerID=""}};jt.INDEX=mt.INDEX,jt.ACTION="crypto",nt([w({id:Dt.INDEX++,required:!0,type:"string"})],jt.prototype,"providerID",void 0),jt=Dt=nt([y({})],jt);let $t=class extends jt{};$t.INDEX=jt.INDEX,$t.ACTION="crypto/login",$t=nt([y({})],$t);let Pt=class extends jt{};Pt.INDEX=jt.INDEX,Pt.ACTION="crypto/logout",Pt=nt([y({})],Pt);let Jt=class extends jt{};Jt.INDEX=jt.INDEX,Jt.ACTION="crypto/isLoggedIn",Jt=nt([y({})],Jt);let Vt=class extends jt{};var Mt,Ht,Wt,_t,Lt,Gt,zt,Ft,Zt,Xt,Qt,Yt,te,ee,re;Vt.INDEX=jt.INDEX,Vt.ACTION="crypto/reset",Vt=nt([y({})],Vt);let ie=Mt=class extends St{constructor(){super(...arguments),this.id="",this.publicKey=new Bt,this.type="x509",this.label="",this.token=!1,this.sensitive=!1}};ie.INDEX=St.INDEX,nt([w({id:Mt.INDEX++,required:!0,converter:at})],ie.prototype,"id",void 0),nt([w({id:Mt.INDEX++,required:!0,parser:Bt})],ie.prototype,"publicKey",void 0),nt([w({id:Mt.INDEX++,required:!0,type:"string"})],ie.prototype,"type",void 0),nt([w({id:Mt.INDEX++,type:"string",defaultValue:""})],ie.prototype,"label",void 0),nt([w({id:Mt.INDEX++,type:"bool",defaultValue:!1})],ie.prototype,"token",void 0),nt([w({id:Mt.INDEX++,type:"bool",defaultValue:!1})],ie.prototype,"sensitive",void 0),ie=Mt=nt([y({})],ie);let se=Ht=class extends ie{constructor(){super(...arguments),this.type="x509",this.serialNumber="",this.issuerName="",this.subjectName="",this.notBefore=new Date,this.notAfter=new Date}};se.INDEX=ie.INDEX,nt([w({id:Ht.INDEX++,required:!0,converter:at})],se.prototype,"serialNumber",void 0),nt([w({id:Ht.INDEX++,required:!0,type:"string"})],se.prototype,"issuerName",void 0),nt([w({id:Ht.INDEX++,required:!0,type:"string"})],se.prototype,"subjectName",void 0),nt([w({id:Ht.INDEX++,required:!0,converter:ot})],se.prototype,"notBefore",void 0),nt([w({id:Ht.INDEX++,required:!0,converter:ot})],se.prototype,"notAfter",void 0),se=Ht=nt([y({})],se);let ne=Wt=class extends ie{constructor(){super(...arguments),this.type="request",this.subjectName=""}};ne.INDEX=ie.INDEX,nt([w({id:Wt.INDEX++,required:!0,type:"string"})],ne.prototype,"subjectName",void 0),ne=Wt=nt([y({})],ne);let oe=_t=class extends gt{constructor(){super(...arguments),this.type="",this.value=new ArrayBuffer(0)}};oe.INDEX=gt.INDEX,nt([w({id:_t.INDEX++,required:!0,type:"string"})],oe.prototype,"type",void 0),nt([w({id:_t.INDEX++,required:!0,converter:d})],oe.prototype,"value",void 0),oe=_t=nt([y({})],oe);let ae=Lt=class extends gt{constructor(){super(...arguments),this.items=[]}};ae.INDEX=gt.INDEX,nt([w({id:Lt.INDEX++,required:!0,repeated:!0,parser:oe})],ae.prototype,"items",void 0),ae=Lt=nt([y({})],ae);let ce=Gt=class extends jt{constructor(){super(...arguments),this.item=new ie}};ce.INDEX=jt.INDEX,ce.ACTION="crypto/certificateStorage/setItem",nt([w({id:Gt.INDEX++,required:!0,parser:ie})],ce.prototype,"item",void 0),ce=Gt=nt([y({})],ce);let he=zt=class extends jt{constructor(){super(...arguments),this.key="",this.algorithm=new At,this.keyUsages=[]}};he.INDEX=jt.INDEX,he.ACTION="crypto/certificateStorage/getItem",nt([w({id:zt.INDEX++,required:!0,type:"string"})],he.prototype,"key",void 0),nt([w({id:zt.INDEX++,parser:At})],he.prototype,"algorithm",void 0),nt([w({id:zt.INDEX++,repeated:!0,type:"string"})],he.prototype,"keyUsages",void 0),he=zt=nt([y({})],he);let ue=class extends jt{};ue.INDEX=jt.INDEX,ue.ACTION="crypto/certificateStorage/keys",ue=nt([y({})],ue);let fe=Ft=class extends jt{constructor(){super(...arguments),this.key=""}};fe.INDEX=jt.INDEX,fe.ACTION="crypto/certificateStorage/getValue",nt([w({id:Ft.INDEX++,required:!0,type:"string"})],fe.prototype,"key",void 0),fe=Ft=nt([y({})],fe);let le=Zt=class extends jt{constructor(){super(...arguments),this.key=""}};le.INDEX=jt.INDEX,le.ACTION="crypto/certificateStorage/removeItem",nt([w({id:Zt.INDEX++,required:!0,type:"string"})],le.prototype,"key",void 0),le=Zt=nt([y({})],le);let de=class extends jt{};de.INDEX=jt.INDEX,de.ACTION="crypto/certificateStorage/clear",de=nt([y({})],de);let ye=Xt=class extends jt{constructor(){super(...arguments),this.format="raw",this.data=new ArrayBuffer(0),this.algorithm=new At,this.keyUsages=[]}};ye.INDEX=jt.INDEX,ye.ACTION="crypto/certificateStorage/import",nt([w({id:Xt.INDEX++,required:!0,type:"string"})],ye.prototype,"format",void 0),nt([w({id:Xt.INDEX++,required:!0,converter:d})],ye.prototype,"data",void 0),nt([w({id:Xt.INDEX++,required:!0,parser:At})],ye.prototype,"algorithm",void 0),nt([w({id:Xt.INDEX++,repeated:!0,type:"string"})],ye.prototype,"keyUsages",void 0),ye=Xt=nt([y({})],ye);let we=Qt=class extends jt{constructor(){super(...arguments),this.format="raw",this.item=new ie}};we.INDEX=jt.INDEX,we.ACTION="crypto/certificateStorage/export",nt([w({id:Qt.INDEX++,required:!0,type:"string"})],we.prototype,"format",void 0),nt([w({id:Qt.INDEX++,required:!0,parser:ie})],we.prototype,"item",void 0),we=Qt=nt([y({})],we);let pe=Yt=class extends jt{constructor(){super(...arguments),this.item=new ie}};pe.INDEX=jt.INDEX,pe.ACTION="crypto/certificateStorage/indexOf",nt([w({id:Yt.INDEX++,required:!0,parser:ie})],pe.prototype,"item",void 0),pe=Yt=nt([y({})],pe);let ve=class extends jt{constructor(){super(...arguments),this.item=new ie}};ve.INDEX=jt.INDEX,ve.ACTION="crypto/certificateStorage/getChain",nt([w({id:ce.INDEX++,required:!0,parser:ie})],ve.prototype,"item",void 0),ve=nt([y({})],ve);let ge=te=class extends jt{constructor(){super(...arguments),this.url=""}};ge.INDEX=jt.INDEX,ge.ACTION="crypto/certificateStorage/getCRL",nt([w({id:te.INDEX++,required:!0,type:"string"})],ge.prototype,"url",void 0),ge=te=nt([y({})],ge);let me=ee=class extends gt{constructor(){super(...arguments),this.method="get"}};me.INDEX=gt.INDEX,nt([w({id:ee.INDEX++,required:!1,type:"string",defaultValue:"get"})],me.prototype,"method",void 0),me=ee=nt([y({})],me);let be=re=class extends jt{constructor(){super(...arguments),this.url="",this.request=new ArrayBuffer(0),this.options=new me}};var Ae,Se,Be,Ee;be.INDEX=jt.INDEX,be.ACTION="crypto/certificateStorage/getOCSP",nt([w({id:re.INDEX++,required:!0,type:"string"})],be.prototype,"url",void 0),nt([w({id:re.INDEX++,required:!0,converter:d})],be.prototype,"request",void 0),nt([w({id:re.INDEX++,required:!1,parser:me})],be.prototype,"options",void 0),be=re=nt([y({})],be);let ke=Ae=class extends jt{constructor(){super(...arguments),this.item=new Bt}};ke.INDEX=jt.INDEX,ke.ACTION="crypto/keyStorage/setItem",nt([w({id:Ae.INDEX++,required:!0,parser:Bt})],ke.prototype,"item",void 0),ke=Ae=nt([y({})],ke);let xe=Se=class extends jt{constructor(){super(...arguments),this.key="",this.algorithm=new At,this.extractable=!1,this.keyUsages=[]}};xe.INDEX=jt.INDEX,xe.ACTION="crypto/keyStorage/getItem",nt([w({id:Se.INDEX++,required:!0,type:"string"})],xe.prototype,"key",void 0),nt([w({id:Se.INDEX++,parser:At})],xe.prototype,"algorithm",void 0),nt([w({id:Se.INDEX++,type:"bool"})],xe.prototype,"extractable",void 0),nt([w({id:Se.INDEX++,repeated:!0,type:"string"})],xe.prototype,"keyUsages",void 0),xe=Se=nt([y({})],xe);let Ne=class extends jt{};Ne.INDEX=jt.INDEX,Ne.ACTION="crypto/keyStorage/keys",Ne=nt([y({})],Ne);let Ue=Be=class extends jt{constructor(){super(...arguments),this.key=""}};Ue.INDEX=jt.INDEX,Ue.ACTION="crypto/keyStorage/removeItem",nt([w({id:Be.INDEX++,required:!0,type:"string"})],Ue.prototype,"key",void 0),Ue=Be=nt([y({})],Ue);let Ie=class extends jt{};Ie.INDEX=jt.INDEX,Ie.ACTION="crypto/keyStorage/clear",Ie=nt([y({})],Ie);let Ce=Ee=class extends jt{constructor(){super(...arguments),this.item=new Bt}};var qe,Oe,Re,Te,Ke,De;Ce.INDEX=jt.INDEX,Ce.ACTION="crypto/keyStorage/indexOf",nt([w({id:Ee.INDEX++,required:!0,parser:Bt})],Ce.prototype,"item",void 0),Ce=Ee=nt([y({})],Ce);let je=qe=class extends gt{constructor(t){super(),this.major=0,this.minor=0,t&&h(this,t)}};je.INDEX=gt.INDEX,nt([w({id:qe.INDEX++,required:!0,type:"uint32"})],je.prototype,"major",void 0),nt([w({id:qe.INDEX++,required:!0,type:"uint32"})],je.prototype,"minor",void 0),je=qe=nt([y({})],je);let $e=Oe=class extends gt{constructor(t){super(),this.label="",this.manufacturerID="",this.model="",this.serialNumber="",this.flags=0,this.hardwareVersion=new je,this.firmwareVersion=new je,this.maxSessionCount=0,this.sessionCount=0,this.maxRwSessionCount=0,this.rwSessionCount=0,this.maxPinLen=0,this.minPinLen=0,this.totalPublicMemory=0,this.freePublicMemory=0,this.totalPrivateMemory=0,this.freePrivateMemory=0,t&&(h(this,t),this.firmwareVersion=new je(t.firmwareVersion),this.hardwareVersion=new je(t.hardwareVersion))}};$e.INDEX=gt.INDEX,nt([w({id:Oe.INDEX++,required:!0,type:"string"})],$e.prototype,"label",void 0),nt([w({id:Oe.INDEX++,required:!0,type:"string"})],$e.prototype,"manufacturerID",void 0),nt([w({id:Oe.INDEX++,required:!0,type:"string"})],$e.prototype,"model",void 0),nt([w({id:Oe.INDEX++,required:!0,type:"string"})],$e.prototype,"serialNumber",void 0),nt([w({id:Oe.INDEX++,required:!0,type:"uint32"})],$e.prototype,"flags",void 0),nt([w({id:Oe.INDEX++,required:!0,parser:je})],$e.prototype,"hardwareVersion",void 0),nt([w({id:Oe.INDEX++,required:!0,parser:je})],$e.prototype,"firmwareVersion",void 0),nt([w({id:Oe.INDEX++,required:!0,type:"uint32"})],$e.prototype,"maxSessionCount",void 0),nt([w({id:Oe.INDEX++,required:!0,type:"uint32"})],$e.prototype,"sessionCount",void 0),nt([w({id:Oe.INDEX++,required:!0,type:"uint32"})],$e.prototype,"maxRwSessionCount",void 0),nt([w({id:Oe.INDEX++,required:!0,type:"uint32"})],$e.prototype,"rwSessionCount",void 0),nt([w({id:Oe.INDEX++,required:!0,type:"uint32"})],$e.prototype,"maxPinLen",void 0),nt([w({id:Oe.INDEX++,required:!0,type:"uint32"})],$e.prototype,"minPinLen",void 0),nt([w({id:Oe.INDEX++,required:!0,converter:ct})],$e.prototype,"totalPublicMemory",void 0),nt([w({id:Oe.INDEX++,required:!0,converter:ct})],$e.prototype,"freePublicMemory",void 0),nt([w({id:Oe.INDEX++,required:!0,converter:ct})],$e.prototype,"totalPrivateMemory",void 0),nt([w({id:Oe.INDEX++,required:!0,converter:ct})],$e.prototype,"freePrivateMemory",void 0),$e=Oe=nt([y({})],$e);let Pe=Re=class extends gt{constructor(t){super(),this.id="",this.name="",this.readOnly=!1,this.algorithms=[],this.isRemovable=!1,this.atr="",this.isHardware=!1,this.card="",t&&(h(this,t),t.token&&(this.token=new $e(t.token)))}};Pe.INDEX=gt.INDEX,nt([w({id:Re.INDEX++,required:!0,type:"string"})],Pe.prototype,"id",void 0),nt([w({id:Re.INDEX++,required:!0,type:"string"})],Pe.prototype,"name",void 0),nt([w({id:Re.INDEX++,type:"bool",defaultValue:!1})],Pe.prototype,"readOnly",void 0),nt([w({id:Re.INDEX++,repeated:!0,type:"string"})],Pe.prototype,"algorithms",void 0),nt([w({id:Re.INDEX++,type:"bool",defaultValue:!1})],Pe.prototype,"isRemovable",void 0),nt([w({id:Re.INDEX++,type:"string"})],Pe.prototype,"atr",void 0),nt([w({id:Re.INDEX++,type:"bool",defaultValue:!1})],Pe.prototype,"isHardware",void 0),nt([w({id:Re.INDEX++,type:"string"})],Pe.prototype,"card",void 0),nt([w({id:Re.INDEX++,parser:$e})],Pe.prototype,"token",void 0),Pe=Re=nt([y({})],Pe);let Je=Te=class extends gt{constructor(){super(...arguments),this.name="",this.providers=[]}};Je.INDEX=gt.INDEX,nt([w({id:Te.INDEX++,type:"string",required:!0})],Je.prototype,"name",void 0),nt([w({id:Te.INDEX++,repeated:!0,parser:Pe})],Je.prototype,"providers",void 0),Je=Te=nt([y({})],Je);let Ve=class extends mt{};Ve.INDEX=mt.INDEX,Ve.ACTION="provider/action/info",Ve=nt([y({})],Ve);let Me=Ke=class extends mt{constructor(){super(...arguments),this.cryptoID=""}};Me.INDEX=mt.INDEX,Me.ACTION="provider/action/getCrypto",nt([w({id:Ke.INDEX++,required:!0,type:"string"})],Me.prototype,"cryptoID",void 0),Me=Ke=nt([y({})],Me);let He=class extends mt{};He.INDEX=mt.INDEX,He.ACTION="provider/event/authorized",He=nt([y({})],He);let We=De=class extends mt{constructor(t){super(),this.added=[],this.removed=[],t&&h(this,t)}};var _e,Le,Ge,ze,Fe,Ze,Xe,Qe,Ye,tr;We.INDEX=mt.INDEX,We.ACTION="provider/event/token",nt([w({id:De.INDEX++,repeated:!0,parser:Pe})],We.prototype,"added",void 0),nt([w({id:De.INDEX++,repeated:!0,parser:Pe})],We.prototype,"removed",void 0),nt([w({id:De.INDEX++,type:"bytes",parser:kt})],We.prototype,"error",void 0),We=De=nt([y({name:"ProviderTokenEvent"})],We);let er=_e=class extends jt{constructor(){super(...arguments),this.algorithm=new At,this.data=new ArrayBuffer(0)}};er.INDEX=jt.INDEX,er.ACTION="crypto/subtle/digest",nt([w({id:_e.INDEX++,required:!0,parser:At})],er.prototype,"algorithm",void 0),nt([w({id:_e.INDEX++,required:!0,converter:d})],er.prototype,"data",void 0),er=_e=nt([y({})],er);let rr=Le=class extends jt{constructor(){super(...arguments),this.algorithm=new At,this.extractable=!1,this.usage=[]}};rr.INDEX=jt.INDEX,rr.ACTION="crypto/subtle/generateKey",nt([w({id:Le.INDEX++,type:"bytes",required:!0,parser:At})],rr.prototype,"algorithm",void 0),nt([w({id:Le.INDEX++,type:"bool",required:!0})],rr.prototype,"extractable",void 0),nt([w({id:Le.INDEX++,type:"string",repeated:!0})],rr.prototype,"usage",void 0),rr=Le=nt([y({})],rr);let ir=Ge=class extends jt{constructor(){super(...arguments),this.algorithm=new At,this.key=new Bt,this.data=new ArrayBuffer(0)}};ir.INDEX=jt.INDEX,ir.ACTION="crypto/subtle/sign",nt([w({id:Ge.INDEX++,required:!0,parser:At})],ir.prototype,"algorithm",void 0),nt([w({id:Ge.INDEX++,required:!0,parser:Bt})],ir.prototype,"key",void 0),nt([w({id:Ge.INDEX++,required:!0,converter:d})],ir.prototype,"data",void 0),ir=Ge=nt([y({})],ir);let sr=ze=class extends ir{constructor(){super(...arguments),this.signature=new ArrayBuffer(0)}};sr.INDEX=ir.INDEX,sr.ACTION="crypto/subtle/verify",nt([w({id:ze.INDEX++,required:!0,converter:d})],sr.prototype,"signature",void 0),sr=ze=nt([y({})],sr);let nr=class extends ir{};nr.INDEX=ir.INDEX,nr.ACTION="crypto/subtle/encrypt",nr=nt([y({})],nr);let or=class extends ir{};or.INDEX=ir.INDEX,or.ACTION="crypto/subtle/decrypt",or=nt([y({})],or);let ar=Fe=class extends jt{constructor(){super(...arguments),this.algorithm=new At,this.key=new Bt,this.length=0}};ar.INDEX=jt.INDEX,ar.ACTION="crypto/subtle/deriveBits",nt([w({id:Fe.INDEX++,required:!0,parser:At})],ar.prototype,"algorithm",void 0),nt([w({id:Fe.INDEX++,required:!0,parser:Bt})],ar.prototype,"key",void 0),nt([w({id:Fe.INDEX++,required:!0,type:"uint32"})],ar.prototype,"length",void 0),ar=Fe=nt([y({})],ar);let cr=Ze=class extends jt{constructor(){super(...arguments),this.algorithm=new At,this.key=new Bt,this.derivedKeyType=new At,this.extractable=!1,this.usage=[]}};cr.INDEX=jt.INDEX,cr.ACTION="crypto/subtle/deriveKey",nt([w({id:Ze.INDEX++,required:!0,parser:At})],cr.prototype,"algorithm",void 0),nt([w({id:Ze.INDEX++,required:!0,parser:Bt})],cr.prototype,"key",void 0),nt([w({id:Ze.INDEX++,required:!0,parser:At})],cr.prototype,"derivedKeyType",void 0),nt([w({id:Ze.INDEX++,type:"bool"})],cr.prototype,"extractable",void 0),nt([w({id:Ze.INDEX++,type:"string",repeated:!0})],cr.prototype,"usage",void 0),cr=Ze=nt([y({})],cr);let hr=Xe=class extends jt{constructor(){super(...arguments),this.format="",this.wrappedKey=new ArrayBuffer(0),this.unwrappingKey=new Bt,this.unwrapAlgorithm=new At,this.unwrappedKeyAlgorithm=new At,this.extractable=!1,this.keyUsage=[]}};hr.INDEX=jt.INDEX,hr.ACTION="crypto/subtle/unwrapKey",nt([w({id:Xe.INDEX++,required:!0,type:"string"})],hr.prototype,"format",void 0),nt([w({id:Xe.INDEX++,required:!0,converter:d})],hr.prototype,"wrappedKey",void 0),nt([w({id:Xe.INDEX++,required:!0,parser:Bt})],hr.prototype,"unwrappingKey",void 0),nt([w({id:Xe.INDEX++,required:!0,parser:At})],hr.prototype,"unwrapAlgorithm",void 0),nt([w({id:Xe.INDEX++,required:!0,parser:At})],hr.prototype,"unwrappedKeyAlgorithm",void 0),nt([w({id:Xe.INDEX++,type:"bool"})],hr.prototype,"extractable",void 0),nt([w({id:Xe.INDEX++,type:"string",repeated:!0})],hr.prototype,"keyUsage",void 0),hr=Xe=nt([y({})],hr);let ur=Qe=class extends jt{constructor(){super(...arguments),this.format="",this.key=new Bt,this.wrappingKey=new Bt,this.wrapAlgorithm=new At}};ur.INDEX=jt.INDEX,ur.ACTION="crypto/subtle/wrapKey",nt([w({id:Qe.INDEX++,required:!0,type:"string"})],ur.prototype,"format",void 0),nt([w({id:Qe.INDEX++,required:!0,parser:Bt})],ur.prototype,"key",void 0),nt([w({id:Qe.INDEX++,required:!0,parser:Bt})],ur.prototype,"wrappingKey",void 0),nt([w({id:Qe.INDEX++,required:!0,parser:At})],ur.prototype,"wrapAlgorithm",void 0),ur=Qe=nt([y({})],ur);let fr=Ye=class extends jt{constructor(){super(...arguments),this.format="",this.key=new Bt}};fr.INDEX=jt.INDEX,fr.ACTION="crypto/subtle/exportKey",nt([w({id:Ye.INDEX++,type:"string",required:!0})],fr.prototype,"format",void 0),nt([w({id:Ye.INDEX++,required:!0,parser:Bt})],fr.prototype,"key",void 0),fr=Ye=nt([y({})],fr);let lr=tr=class extends jt{constructor(){super(...arguments),this.format="",this.keyData=new ArrayBuffer(0),this.algorithm=new At,this.extractable=!1,this.keyUsages=[]}};lr.INDEX=jt.INDEX,lr.ACTION="crypto/subtle/importKey",nt([w({id:tr.INDEX++,type:"string",required:!0})],lr.prototype,"format",void 0),nt([w({id:tr.INDEX++,required:!0,converter:d})],lr.prototype,"keyData",void 0),nt([w({id:tr.INDEX++,required:!0,parser:At})],lr.prototype,"algorithm",void 0),nt([w({id:tr.INDEX++,required:!0,type:"bool"})],lr.prototype,"extractable",void 0),nt([w({id:tr.INDEX++,type:"string",repeated:!0})],lr.prototype,"keyUsages",void 0),lr=tr=nt([y({})],lr);class dr extends g{constructor(t){super(),this.client=t,this.onEvent=this.onEvent.bind(this),this.client.on("listening",()=>{this.client.on("event",this.onEvent)}).on("close",()=>{this.client.removeListener("event",this.onEvent)})}async readers(){const t=await this.client.send(new Ot);return JSON.parse(c.ToString(t))}on(t,e){return super.on(t,e)}emit(t,...e){return super.emit(t,...e)}onEvent(t){(async()=>{switch(t.action){case Tt.ACTION:this.onInsert(await Tt.importProto(t));break;case Kt.ACTION:this.onRemove(await Kt.importProto(t))}})().catch(t=>this.emit("error",t))}onInsert(t){this.emit("insert",t)}onRemove(t){this.emit("remove",t)}}class yr extends Error{constructor(t){super(t.message),this.name="CryptoServerError",this.code=t.code,this.type=t.type}}class wr extends class{constructor(t,e){this.target=t,this.event=e}}{}class pr extends wr{constructor(t,e,r,i){super(t,"close"),this.remoteAddress=e,this.reasonCode=r,this.description=i}}class vr extends wr{constructor(t,e){super(t,"error"),this.error=e}}class gr extends wr{constructor(t,e){super(t,"listening"),this.address=e}}function mr(){return/firefox\/([\w\.-]+)$/i.test(self.navigator.userAgent)}function br(){return/(edge|edgios|edga|edg)\/((\d+)?[\w\.]+)/i.test(self.navigator.userAgent)}function Ar(){return/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i.test(self.navigator.userAgent)}const Sr={name:"ECDH",namedCurve:"P-256"},Br={name:"ECDSA",namedCurve:"P-256"},Er={name:"AES-CBC",iv:new ArrayBuffer(16)};async function kr(t,e){const r=await async function(t){const e=t.algorithm.name.toUpperCase();if("ECDH"!==e&&"ECDSA"!==e)throw new Error("Error: Unsupported asymmetric key algorithm.");if("public"!==t.type)throw new Error("Error: Expected key type to be public but it was not.");const r=await R().crypto.subtle.exportKey("jwk",t);if(!r.x||!r.y)throw new Error("Wrong JWK data for EC public key. Parameters x and y are required.");const i=c.FromBase64Url(r.x),s=c.FromBase64Url(r.y),n=c.ToBinary(i)+c.ToBinary(s),o=t,a=c.FromBinary(n);return{id:c.ToHex(await R().crypto.subtle.digest("SHA-256",a)),key:o,serialized:a}}(e);t.id=r.id,t.key=r.key,t.serialized=r.serialized}var xr;!function(t){t[t.connecting=0]="connecting",t[t.open=1]="open",t[t.closing=2]="closing",t[t.closed=3]="closed"}(xr||(xr={}));class Nr extends g{constructor(t){super(),this.stack={},this.messageCounter=0,this.storage=t}get state(){return this.socket?this.socket.readyState:xr.closed}connect(t,e){return this.getServerInfo(t).then(r=>{const[i,s,n]=r.version.split(".").map(t=>parseInt(t,10));if(i<1||1===i&&s<2)throw new Error(`Current version of WebCryptoSocket doesn't work with WebCryptoServer v${r.version}. Please update your client to the latest version.`);this.serviceInfo=r;const a="wss://"+t;this.socket=e?new o.default(a,void 0,e):new o.default(a),this.socket.binaryType="arraybuffer",this.socket.onerror=t=>{this.emit("error",new vr(this,t.error))},this.socket.onopen=()=>{(async()=>{let e=await this.storage.loadIdentity();e||(e=await $.create(1,0,0,Ar()||br()||mr()),await this.storage.saveIdentity(e));const i=await Z.importProto(c.FromBase64(r.preKey));this.cipher=await rt.create(e,i),await this.storage.saveRemoteIdentity("0",this.cipher.remoteIdentity),this.emit("listening",new gr(this,t))})().catch(t=>this.emit("error",new vr(this,t)))},this.socket.onclose=e=>{for(const t in this.stack)this.stack[t].reject(new Error("Cannot finish operation. Session was closed"));this.emit("close",new pr(this,t,e.code,e.reason))},this.socket.onmessage=t=>{t.data instanceof ArrayBuffer&&L.importProto(t.data).then(t=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.decrypt(t)}).then(t=>{this.onMessage(t)}).catch(t=>{this.emit("error",new vr(this,t))})}}).catch(t=>{this.emit("error",new vr(this,t))}),this}close(){this.socket&&this.socket.close()}on(t,e){return super.on(t,e)}once(t,e){return super.once(t,e)}async challenge(){if(!this.cipher)throw new Error("Client cipher is not initialized");return async function(t,e){const r=await t.thumbprint(),i=await e.thumbprint(),s=c.FromHex(r+i),n=await R().crypto.subtle.digest("SHA-256",s);return parseInt(c.ToHex(n),16).toString().substr(2,6)}(this.cipher.remoteIdentity.signingKey,this.cipher.identity.signingKey.publicKey)}async isLoggedIn(){const t=new It,e=await this.send(t);return!!e&&!!new Uint8Array(e)[0]}async login(){const t=new Ut;await this.send(t)}send(t){return new Promise((e,r)=>{this.checkSocketState(),t||(t=new mt),t.action=t.action,t.actionId=(this.messageCounter++).toString(),t.exportProto().then(t=>{if(!this.cipher)throw new Error("Client cipher is not initialized");return this.cipher.encrypt(t).then(t=>t.exportProto())}).then(i=>{if(!this.socket)throw new Error("Client socket is not initialized");this.stack[t.actionId]={resolve:e,reject:r},this.socket.send(i)}).catch(r)})}async getServerInfo(t){const e=`https://${t}/.well-known/webcrypto-socket`,r=await n.default(e);if(200!==r.status)throw new Error("Cannot get wellknown link");return await r.json()}checkSocketState(){if(this.state!==xr.open)throw new Error("Socket connection is not open")}async onMessage(t){const e=await mt.importProto(t),r=this.stack[e.actionId];if(r){delete this.stack[e.actionId];const t=await xt.importProto(await e.exportProto());if(t.error&&t.error.message){const e=new yr(t.error);r.reject(e)}else r.resolve(t.data)}else this.emit("event",e)}}function Ur(t,e,r){return t instanceof Object==0?r:e in t?t[e]:r}function Ir(t,e=0,r=t.byteLength-e,i=!1){let s="";for(const n of new Uint8Array(t,e,r)){const t=n.toString(16).toUpperCase();1===t.length&&(s+="0"),s+=t,i&&(s+=" ")}return s.trim()}function Cr(t,e,r,i){return e instanceof ArrayBuffer==0?(t.error='Wrong parameter: inputBuffer must be "ArrayBuffer"',!1):0===e.byteLength?(t.error="Wrong parameter: inputBuffer has zero length",!1):r<0?(t.error="Wrong parameter: inputOffset less than zero",!1):i<0?(t.error="Wrong parameter: inputLength less than zero",!1):!(e.byteLength-r-i<0&&(t.error="End of input reached before message was fully decoded (inconsistent offset and length values)",1))}function qr(t,e){let r=0;if(1===t.length)return t[0];for(let i=t.length-1;i>=0;i--)r+=t[t.length-1-i]*Math.pow(2,e*i);return r}function Or(t,e,r=-1){const i=r;let s=t,n=0,o=Math.pow(2,e);for(let a=1;a<8;a++){if(t<o){let t;if(i<0)t=new ArrayBuffer(a),n=a;else{if(i<a)return new ArrayBuffer(0);t=new ArrayBuffer(i),n=i}const r=new Uint8Array(t);for(let i=a-1;i>=0;i--){const t=Math.pow(2,i*e);r[n-i-1]=Math.floor(s/t),s-=r[n-i-1]*t}return t}o*=Math.pow(2,e)}return new ArrayBuffer(0)}function Rr(...t){let e=0,r=0;for(const n of t)e+=n.byteLength;const i=new ArrayBuffer(e),s=new Uint8Array(i);for(const n of t)s.set(new Uint8Array(n),r),r+=n.byteLength;return i}function Tr(...t){let e=0,r=0;for(const n of t)e+=n.length;const i=new ArrayBuffer(e),s=new Uint8Array(i);for(const n of t)s.set(n,r),r+=n.length;return s}function Kr(){const t=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const e=0===t[0]&&0==(128&t[1]);(255===t[0]&&128&t[1]||e)&&this.warnings.push("Needlessly long format")}const e=new ArrayBuffer(this.valueHex.byteLength),r=new Uint8Array(e);for(let o=0;o<this.valueHex.byteLength;o++)r[o]=0;r[0]=128&t[0];const i=qr(r,8),s=new ArrayBuffer(this.valueHex.byteLength),n=new Uint8Array(s);for(let o=0;o<this.valueHex.byteLength;o++)n[o]=t[o];return n[0]&=127,qr(n,8)-i}function Dr(t,e){if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),i=new Uint8Array(e);for(let s=0;s<r.length;s++)if(r[s]!==i[s])return!1;return!0}function jr(t,e){const r=t.toString(10);if(e<r.length)return"";const i=e-r.length,s=new Array(i);for(let n=0;n<i;n++)s[n]="0";return s.join("").concat(r)}const $r=[new Uint8Array([1])];class Pr{constructor(t={}){this.blockLength=Ur(t,"blockLength",0),this.error=Ur(t,"error",""),this.warnings=Ur(t,"warnings",[]),this.valueBeforeDecode="valueBeforeDecode"in t?t.valueBeforeDecode.slice(0):new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:Ir(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const Jr=t=>class extends t{constructor(t={}){super(t),this.isHexOnly=Ur(t,"isHexOnly",!1),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(t,e,r){return!1===Cr(this,t,e,r)?-1:0===new Uint8Array(t,e,r).length?(this.warnings.push("Zero buffer length"),e):(this.valueHex=t.slice(e,e+r),this.blockLength=r,e+r)}toBER(t=!1){return!0!==this.isHexOnly?(this.error='Flag "isHexOnly" is not set, abort',new ArrayBuffer(0)):!0===t?new ArrayBuffer(this.valueHex.byteLength):this.valueHex.slice(0)}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isHexOnly=this.isHexOnly,t.valueHex=Ir(this.valueHex,0,this.valueHex.byteLength),t}};class Vr extends(Jr(Pr)){constructor(t={}){super(),"idBlock"in t?(this.isHexOnly=Ur(t.idBlock,"isHexOnly",!1),this.valueHex=Ur(t.idBlock,"valueHex",new ArrayBuffer(0)),this.tagClass=Ur(t.idBlock,"tagClass",-1),this.tagNumber=Ur(t.idBlock,"tagNumber",-1),this.isConstructed=Ur(t.idBlock,"isConstructed",!1)):(this.tagClass=-1,this.tagNumber=-1,this.isConstructed=!1)}static blockName(){return"identificationBlock"}toBER(t=!1){let e,r,i=0;switch(this.tagClass){case 1:i|=0;break;case 2:i|=64;break;case 3:i|=128;break;case 4:i|=192;break;default:return this.error="Unknown tag class",new ArrayBuffer(0)}if(this.isConstructed&&(i|=32),this.tagNumber<31&&!this.isHexOnly){if(e=new ArrayBuffer(1),r=new Uint8Array(e),!t){let t=this.tagNumber;t&=31,i|=t,r[0]=i}return e}if(!1===this.isHexOnly){const s=Or(this.tagNumber,7),n=new Uint8Array(s),o=s.byteLength;if(e=new ArrayBuffer(o+1),r=new Uint8Array(e),r[0]=31|i,!t){for(let t=0;t<o-1;t++)r[t+1]=128|n[t];r[o]=n[o-1]}return e}if(e=new ArrayBuffer(this.valueHex.byteLength+1),r=new Uint8Array(e),r[0]=31|i,!1===t){const t=new Uint8Array(this.valueHex);for(let e=0;e<t.length-1;e++)r[e+1]=128|t[e];r[this.valueHex.byteLength]=t[t.length-1]}return e}fromBER(t,e,r){if(!1===Cr(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);if(0===i.length)return this.error="Zero buffer length",-1;switch(192&i[0]){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:return this.error="Unknown tag class",-1}this.isConstructed=32==(32&i[0]),this.isHexOnly=!1;const s=31&i[0];if(31!==s)this.tagNumber=s,this.blockLength=1;else{let t=1;this.valueHex=new ArrayBuffer(255);let e=255,r=new Uint8Array(this.valueHex);for(;128&i[t];){if(r[t-1]=127&i[t],t++,t>=i.length)return this.error="End of input reached before message was fully decoded",-1;if(t===e){e+=255;const t=new ArrayBuffer(e),i=new Uint8Array(t);for(let e=0;e<r.length;e++)i[e]=r[e];this.valueHex=new ArrayBuffer(e),r=new Uint8Array(this.valueHex)}}this.blockLength=t+1,r[t-1]=127&i[t];const s=new ArrayBuffer(t),n=new Uint8Array(s);for(let i=0;i<t;i++)n[i]=r[i];this.valueHex=new ArrayBuffer(t),r=new Uint8Array(this.valueHex),r.set(n),this.blockLength<=9?this.tagNumber=qr(r,7):(this.isHexOnly=!0,this.warnings.push("Tag too long, represented as hex-coded"))}if(1===this.tagClass&&this.isConstructed)switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:return this.error="Constructed encoding used for primitive type",-1}return e+this.blockLength}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.tagClass=this.tagClass,t.tagNumber=this.tagNumber,t.isConstructed=this.isConstructed,t}}class Mr extends Pr{constructor(t={}){super(),"lenBlock"in t?(this.isIndefiniteForm=Ur(t.lenBlock,"isIndefiniteForm",!1),this.longFormUsed=Ur(t.lenBlock,"longFormUsed",!1),this.length=Ur(t.lenBlock,"length",0)):(this.isIndefiniteForm=!1,this.longFormUsed=!1,this.length=0)}static blockName(){return"lengthBlock"}fromBER(t,e,r){if(!1===Cr(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);if(0===i.length)return this.error="Zero buffer length",-1;if(255===i[0])return this.error="Length block 0xFF is reserved by standard",-1;if(this.isIndefiniteForm=128===i[0],!0===this.isIndefiniteForm)return this.blockLength=1,e+this.blockLength;if(this.longFormUsed=!!(128&i[0]),!1===this.longFormUsed)return this.length=i[0],this.blockLength=1,e+this.blockLength;const s=127&i[0];if(s>8)return this.error="Too big integer",-1;if(s+1>i.length)return this.error="End of input reached before message was fully decoded",-1;const n=new Uint8Array(s);for(let o=0;o<s;o++)n[o]=i[o+1];return 0===n[s-1]&&this.warnings.push("Needlessly long encoded length"),this.length=qr(n,8),this.longFormUsed&&this.length<=127&&this.warnings.push("Unnecessary usage of long length form"),this.blockLength=s+1,e+this.blockLength}toBER(t=!1){let e,r;if(this.length>127&&(this.longFormUsed=!0),this.isIndefiniteForm)return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=128),e;if(!0===this.longFormUsed){const i=Or(this.length,8);if(i.byteLength>127)return this.error="Too big length",new ArrayBuffer(0);if(e=new ArrayBuffer(i.byteLength+1),!0===t)return e;const s=new Uint8Array(i);r=new Uint8Array(e),r[0]=128|i.byteLength;for(let t=0;t<i.byteLength;t++)r[t+1]=s[t];return e}return e=new ArrayBuffer(1),!1===t&&(r=new Uint8Array(e),r[0]=this.length),e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.blockName=this.constructor.blockName(),t.isIndefiniteForm=this.isIndefiniteForm,t.longFormUsed=this.longFormUsed,t.length=this.length,t}}class Hr extends Pr{constructor(t={}){super(t)}static blockName(){return"valueBlock"}fromBER(t,e,r){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}toBER(t=!1){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}}class Wr extends Pr{constructor(t={},e=Hr){super(t),"name"in t&&(this.name=t.name),"optional"in t&&(this.optional=t.optional),"primitiveSchema"in t&&(this.primitiveSchema=t.primitiveSchema),this.idBlock=new Vr(t),this.lenBlock=new Mr(t),this.valueBlock=new e(t)}static blockName(){return"BaseBlock"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}toBER(t=!1){let e;const r=this.idBlock.toBER(t),i=this.valueBlock.toBER(!0);let s;if(this.lenBlock.length=i.byteLength,e=Rr(r,this.lenBlock.toBER(t)),s=!1===t?this.valueBlock.toBER(t):new ArrayBuffer(this.lenBlock.length),e=Rr(e,s),!0===this.lenBlock.isIndefiniteForm){const r=new ArrayBuffer(2);if(!1===t){const t=new Uint8Array(r);t[0]=0,t[1]=0}e=Rr(e,r)}return e}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.idBlock=this.idBlock.toJSON(),t.lenBlock=this.lenBlock.toJSON(),t.valueBlock=this.valueBlock.toJSON(),"name"in this&&(t.name=this.name),"optional"in this&&(t.optional=this.optional),"primitiveSchema"in this&&(t.primitiveSchema=this.primitiveSchema.toJSON()),t}toString(){return`${this.constructor.blockName()} : ${Ir(this.valueBlock.valueHex)}`}}class _r extends Hr{constructor(t={}){super(t),this.valueHex="valueHex"in t?t.valueHex.slice(0):new ArrayBuffer(0),this.isHexOnly=Ur(t,"isHexOnly",!0)}fromBER(t,e,r){if(!1===Cr(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);if(0===i.length)return this.warnings.push("Zero buffer length"),e;this.valueHex=new ArrayBuffer(i.length);const s=new Uint8Array(this.valueHex);for(let n=0;n<i.length;n++)s[n]=i[n];return this.blockLength=r,e+r}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueHex=Ir(this.valueHex,0,this.valueHex.byteLength),t.isHexOnly=this.isHexOnly,t}}class Lr extends Wr{constructor(t={}){super(t,_r),this.idBlock.isConstructed=!1}static blockName(){return"PRIMITIVE"}}class Gr extends Hr{constructor(t={}){super(t),this.value=Ur(t,"value",[]),this.isIndefiniteForm=Ur(t,"isIndefiniteForm",!1)}fromBER(t,e,r){const i=e,s=r;if(!1===Cr(this,t,e,r))return-1;if(0===new Uint8Array(t,e,r).length)return this.warnings.push("Zero buffer length"),e;let n=e;for(;(!0===this.isIndefiniteForm?1:r)>0;){const e=Mi(t,n,r);if(-1===e.offset)return this.error=e.result.error,this.warnings.concat(e.result.warnings),-1;if(n=e.offset,this.blockLength+=e.result.blockLength,r-=e.result.blockLength,this.value.push(e.result),!0===this.isIndefiniteForm&&e.result.constructor.blockName()===Zr.blockName())break}return!0===this.isIndefiniteForm&&(this.value[this.value.length-1].constructor.blockName()===Zr.blockName()?this.value.pop():this.warnings.push("No EndOfContent block encoded")),this.valueBeforeDecode=t.slice(i,i+s),n}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++)e=Rr(e,this.value[r].toBER(t));return e}static blockName(){return"ConstructedValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.isIndefiniteForm=this.isIndefiniteForm,t.value=[];for(let r=0;r<this.value.length;r++)t.value.push(this.value[r].toJSON());return t}}class zr extends Wr{constructor(t={}){super(t,Gr),this.idBlock.isConstructed=!0}static blockName(){return"CONSTRUCTED"}fromBER(t,e,r){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}toString(){const t=[];for(const r of this.valueBlock.value)t.push(r.toString().split("\n").map(t=>"  "+t).join("\n"));const e=3===this.idBlock.tagClass?`[${this.idBlock.tagNumber}]`:this.constructor.blockName();return t.length?`${e} :\n${t.join("\n")}`:e+" :"}}class Fr extends Hr{constructor(t={}){super(t)}fromBER(t,e,r){return e}toBER(t=!1){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class Zr extends Wr{constructor(t={}){super(t,Fr),this.idBlock.tagClass=1,this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}class Xr extends Hr{constructor(t={}){super(t),this.value=Ur(t,"value",!1),this.isHexOnly=Ur(t,"isHexOnly",!1),"valueHex"in t?this.valueHex=t.valueHex.slice(0):(this.valueHex=new ArrayBuffer(1),!0===this.value&&(new Uint8Array(this.valueHex)[0]=255))}fromBER(t,e,r){if(!1===Cr(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);r>1&&this.warnings.push("Boolean value encoded in more then 1 octet"),this.isHexOnly=!0,this.valueHex=new ArrayBuffer(i.length);const s=new Uint8Array(this.valueHex);for(let n=0;n<i.length;n++)s[n]=i[n];return this.value=0!==Kr.call(this),this.blockLength=r,e+r}toBER(t=!1){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t.isHexOnly=this.isHexOnly,t.valueHex=Ir(this.valueHex,0,this.valueHex.byteLength),t}}class Qr extends Wr{constructor(t={}){super(t,Xr),this.idBlock.tagClass=1,this.idBlock.tagNumber=1}static blockName(){return"BOOLEAN"}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.value}`}}class Yr extends zr{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=16}static blockName(){return"SEQUENCE"}}class ti extends zr{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=17}static blockName(){return"SET"}}class ei extends Wr{constructor(t={}){super(t,Pr),this.idBlock.tagClass=1,this.idBlock.tagNumber=5}static blockName(){return"NULL"}fromBER(t,e,r){return this.lenBlock.length>0&&this.warnings.push("Non-zero length of value block for Null type"),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),this.blockLength+=r,e+r>t.byteLength?(this.error="End of input reached before message was fully decoded (inconsistent offset and length values)",-1):e+r}toBER(t=!1){const e=new ArrayBuffer(2);if(!0===t)return e;const r=new Uint8Array(e);return r[0]=5,r[1]=0,e}toString(){return""+this.constructor.blockName()}}class ri extends(Jr(Gr)){constructor(t={}){super(t),this.isConstructed=Ur(t,"isConstructed",!1)}fromBER(t,e,r){let i=0;if(!0===this.isConstructed){if(this.isHexOnly=!1,i=Gr.prototype.fromBER.call(this,t,e,r),-1===i)return i;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===Zr.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only",-1}if(e!==ii.blockName())return this.error="OCTET STRING may consists of OCTET STRINGs only",-1}}else this.isHexOnly=!0,i=super.fromBER(t,e,r),this.blockLength=r;return i}toBER(t=!1){if(!0===this.isConstructed)return Gr.prototype.toBER.call(this,t);let e=new ArrayBuffer(this.valueHex.byteLength);return!0===t||0===this.valueHex.byteLength||(e=this.valueHex.slice(0)),e}static blockName(){return"OctetStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=Ir(this.valueHex,0,this.valueHex.byteLength),t}}class ii extends Wr{constructor(t={}){super(t,ri),this.idBlock.tagClass=1,this.idBlock.tagNumber=4}fromBER(t,e,r){if(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,0===r)return 0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),e;if(!this.valueBlock.isConstructed){const s=t.slice(e,e+r);try{const t=Hi(s);-1!==t.offset&&t.offset===r&&(this.valueBlock.value=[t.result])}catch(i){}}return super.fromBER(t,e,r)}static blockName(){return"OCTET STRING"}isEqual(t){return t instanceof ii!=0&&JSON.stringify(this)===JSON.stringify(t)}toString(){return this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length?zr.prototype.toString.call(this):`${this.constructor.blockName()} : ${Ir(this.valueBlock.valueHex)}`}}class si extends(Jr(Gr)){constructor(t={}){super(t),this.unusedBits=Ur(t,"unusedBits",0),this.isConstructed=Ur(t,"isConstructed",!1),this.blockLength=this.valueHex.byteLength}fromBER(t,e,r){if(0===r)return e;let i=-1;if(!0===this.isConstructed){if(i=Gr.prototype.fromBER.call(this,t,e,r),-1===i)return i;for(let t=0;t<this.value.length;t++){const e=this.value[t].constructor.blockName();if(e===Zr.blockName()){if(!0===this.isIndefiniteForm)break;return this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only",-1}if(e!==ni.blockName())return this.error="BIT STRING may consists of BIT STRINGs only",-1;if(this.unusedBits>0&&this.value[t].valueBlock.unusedBits>0)return this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only',-1;if(this.unusedBits=this.value[t].valueBlock.unusedBits,this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1}return i}if(!1===Cr(this,t,e,r))return-1;const s=new Uint8Array(t,e,r);if(this.unusedBits=s[0],this.unusedBits>7)return this.error="Unused bits for BitString must be in range 0-7",-1;if(!this.unusedBits){const i=t.slice(e+1,e+r);try{const t=Hi(i);-1!==t.offset&&t.offset===r-1&&(this.value=[t.result])}catch(o){}}this.valueHex=new ArrayBuffer(s.length-1);const n=new Uint8Array(this.valueHex);for(let a=0;a<r-1;a++)n[a]=s[a+1];return this.blockLength=s.length,e+r}toBER(t=!1){if(!0===this.isConstructed)return Gr.prototype.toBER.call(this,t);if(!0===t)return new ArrayBuffer(this.valueHex.byteLength+1);if(0===this.valueHex.byteLength)return new ArrayBuffer(0);const e=new Uint8Array(this.valueHex),r=new ArrayBuffer(this.valueHex.byteLength+1),i=new Uint8Array(r);i[0]=this.unusedBits;for(let s=0;s<this.valueHex.byteLength;s++)i[s+1]=e[s];return r}static blockName(){return"BitStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.unusedBits=this.unusedBits,t.isConstructed=this.isConstructed,t.isHexOnly=this.isHexOnly,t.valueHex=Ir(this.valueHex,0,this.valueHex.byteLength),t}}class ni extends Wr{constructor(t={}){super(t,si),this.idBlock.tagClass=1,this.idBlock.tagNumber=3}static blockName(){return"BIT STRING"}fromBER(t,e,r){return 0===r?e:(this.valueBlock.isConstructed=this.idBlock.isConstructed,this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm,super.fromBER(t,e,r))}isEqual(t){return t instanceof ni!=0&&JSON.stringify(this)===JSON.stringify(t)}toString(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length)return zr.prototype.toString.call(this);{const t=[],e=new Uint8Array(this.valueBlock.valueHex);for(const r of e)t.push(r.toString(2).padStart(8,"0"));return`${this.constructor.blockName()} : ${t.join("")}`}}}class oi extends(Jr(Hr)){constructor(t={}){super(t),"value"in t&&(this.valueDec=t.value)}set valueHex(t){this._valueHex=t.slice(0),t.byteLength>=4?(this.warnings.push("Too big Integer for decoding, hex only"),this.isHexOnly=!0,this._valueDec=0):(this.isHexOnly=!1,t.byteLength>0&&(this._valueDec=Kr.call(this)))}get valueHex(){return this._valueHex}set valueDec(t){this._valueDec=t,this.isHexOnly=!1,this._valueHex=function(t){const e=t<0?-1*t:t;let r=128;for(let i=1;i<8;i++){if(e<=r){if(t<0){const t=Or(r-e,8,i);return new Uint8Array(t)[0]|=128,t}let s=Or(e,8,i),n=new Uint8Array(s);if(128&n[0]){const t=s.slice(0),e=new Uint8Array(t);s=new ArrayBuffer(s.byteLength+1),n=new Uint8Array(s);for(let r=0;r<t.byteLength;r++)n[r+1]=e[r];n[0]=0}return s}r*=Math.pow(2,8)}return new ArrayBuffer(0)}(t)}get valueDec(){return this._valueDec}fromDER(t,e,r,i=0){const s=this.fromBER(t,e,r);if(-1===s)return s;const n=new Uint8Array(this._valueHex);if(0===n[0]&&0!=(128&n[1])){const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}else if(0!==i&&this._valueHex.byteLength<i){i-this._valueHex.byteLength>1&&(i=this._valueHex.byteLength+1);const t=new ArrayBuffer(i);new Uint8Array(t).set(n,i-this._valueHex.byteLength),this._valueHex=t.slice(0)}return s}toDER(t=!1){const e=new Uint8Array(this._valueHex);switch(!0){case 0!=(128&e[0]):{const t=new ArrayBuffer(this._valueHex.byteLength+1),r=new Uint8Array(t);r[0]=0,r.set(e,1),this._valueHex=t.slice(0)}break;case 0===e[0]&&0==(128&e[1]):{const t=new ArrayBuffer(this._valueHex.byteLength-1);new Uint8Array(t).set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1)),this._valueHex=t.slice(0)}}return this.toBER(t)}fromBER(t,e,r){const i=super.fromBER(t,e,r);return-1===i?i:(this.blockLength=r,e+r)}toBER(t=!1){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}toString(){function t(t,e){const r=new Uint8Array([0]);let i=new Uint8Array(t),s=new Uint8Array(e),n=i.slice(0);const o=n.length-1;let a=s.slice(0);const c=a.length-1;let h=0,u=0;for(let f=c<o?o:c;f>=0;f--,u++){switch(!0){case u<a.length:h=n[o-u]+a[c-u]+r[0];break;default:h=n[o-u]+r[0]}switch(r[0]=h/10,!0){case u>=n.length:n=Tr(new Uint8Array([h%10]),n);break;default:n[o-u]=h%10}}return r[0]>0&&(n=Tr(r,n)),n.slice(0)}function e(t){if(t>=$r.length)for(let e=$r.length;e<=t;e++){const t=new Uint8Array([0]);let r=$r[e-1].slice(0);for(let e=r.length-1;e>=0;e--){const i=new Uint8Array([(r[e]<<1)+t[0]]);t[0]=i[0]/10,r[e]=i[0]%10}t[0]>0&&(r=Tr(t,r)),$r.push(r)}return $r[t]}function r(t,e){let r=0,i=new Uint8Array(t),s=new Uint8Array(e),n=i.slice(0);const o=n.length-1;let a=s.slice(0);const c=a.length-1;let h,u=0;for(let f=c;f>=0;f--,u++)switch(h=n[o-u]-a[c-u]-r,!0){case h<0:r=1,n[o-u]=h+10;break;default:r=0,n[o-u]=h}if(r>0)for(let f=o-c+1;f>=0;f--,u++){if(h=n[o-u]-r,!(h<0)){r=0,n[o-u]=h;break}r=1,n[o-u]=h+10}return n.slice()}const i=8*this._valueHex.byteLength-1;let s,n=new Uint8Array(8*this._valueHex.byteLength/3),o=0;const a=new Uint8Array(this._valueHex);let c="",h=!1;for(let u=this._valueHex.byteLength-1;u>=0;u--){s=a[u];for(let a=0;a<8;a++){if(1==(1&s))switch(o){case i:n=r(e(o),n),c="-";break;default:n=t(n,e(o))}o++,s>>=1}}for(let u=0;u<n.length;u++)n[u]&&(h=!0),h&&(c+="0123456789".charAt(n[u]));return!1===h&&(c+="0123456789".charAt(0)),c}}class ai extends Wr{constructor(t={}){super(t,oi),this.idBlock.tagClass=1,this.idBlock.tagNumber=2}static blockName(){return"INTEGER"}isEqual(t){return t instanceof ai?this.valueBlock.isHexOnly&&t.valueBlock.isHexOnly?Dr(this.valueBlock.valueHex,t.valueBlock.valueHex):this.valueBlock.isHexOnly===t.valueBlock.isHexOnly&&this.valueBlock.valueDec===t.valueBlock.valueDec:t instanceof ArrayBuffer&&Dr(this.valueBlock.valueHex,t)}convertToDER(){const t=new ai({valueHex:this.valueBlock.valueHex});return t.valueBlock.toDER(),t}convertFromDER(){const t=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength,e=new ai({valueHex:this.valueBlock.valueHex});return e.valueBlock.fromDER(e.valueBlock.valueHex,0,e.valueBlock.valueHex.byteLength,t),e}toString(){const t=Ir(this.valueBlock.valueHex),e=BigInt("0x"+t);return`${this.constructor.blockName()} : ${e.toString()}`}}class ci extends ai{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=10}static blockName(){return"ENUMERATED"}}class hi extends(Jr(Pr)){constructor(t={}){super(t),this.valueDec=Ur(t,"valueDec",-1),this.isFirstSid=Ur(t,"isFirstSid",!1)}static blockName(){return"sidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===Cr(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let s=new Uint8Array(this.valueHex);for(let a=0;a<r&&(s[a]=127&i[a],this.blockLength++,0!=(128&i[a]));a++);const n=new ArrayBuffer(this.blockLength),o=new Uint8Array(n);for(let a=0;a<this.blockLength;a++)o[a]=s[a];return this.valueHex=n.slice(0),s=new Uint8Array(this.valueHex),0!=(128&i[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===s[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=qr(s,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const i=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|i[t];return r[this.blockLength-1]=i[this.blockLength-1],e}const i=Or(this.valueDec,7);if(0===i.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(i.byteLength),!1===t){const t=new Uint8Array(i);r=new Uint8Array(e);for(let e=0;e<i.byteLength-1;e++)r[e]=128|t[e];r[i.byteLength-1]=t[i.byteLength-1]}return e}toString(){let t="";if(!0===this.isHexOnly)t=Ir(this.valueHex,0,this.valueHex.byteLength);else if(this.isFirstSid){let e=this.valueDec;this.valueDec<=39?t="0.":this.valueDec<=79?(t="1.",e-=40):(t="2.",e-=80),t+=e.toString()}else t=this.valueDec.toString();return t}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t.isFirstSid=this.isFirstSid,t}}class ui extends Hr{constructor(t={}){super(t),this.fromString(Ur(t,"value",""))}fromBER(t,e,r){let i=e;for(;r>0;){const e=new hi;if(i=e.fromBER(t,i,r),-1===i)return this.blockLength=0,this.error=e.error,i;0===this.value.length&&(e.isFirstSid=!0),this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return i}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const i=this.value[r].toBER(t);if(0===i.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=Rr(e,i)}return e}fromString(t){this.value=[];let e=0,r=0,i="",s=!1;do{if(r=t.indexOf(".",e),i=-1===r?t.substr(e):t.substr(e,r-e),e=r+1,s){const t=this.value[0];let e=0;switch(t.valueDec){case 0:break;case 1:e=40;break;case 2:e=80;break;default:return this.value=[],!1}const r=parseInt(i,10);if(isNaN(r))return!0;t.valueDec=r+e,s=!1}else{const t=new hi;if(t.valueDec=parseInt(i,10),isNaN(t.valueDec))return!0;0===this.value.length&&(t.isFirstSid=!0,s=!0),this.value.push(t)}}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let i=this.value[r].toString();0!==r&&(t+="."),e?(i=`{${i}}`,this.value[r].isFirstSid?t=`2.{${i} - 80}`:t+=i):t+=i}return t}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class fi extends Wr{constructor(t={}){super(t,ui),this.idBlock.tagClass=1,this.idBlock.tagNumber=6}static blockName(){return"OBJECT IDENTIFIER"}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.toString()}`}}class li extends(Jr(Pr)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class di extends Wr{constructor(t={}){super(t,li),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=12}static blockName(){return"UTF8String"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(e){this.warnings.push(`Error during "decodeURIComponent": ${e}, using raw string`)}}fromString(t){const e=unescape(encodeURIComponent(t)),r=e.length;this.valueBlock.valueHex=new ArrayBuffer(r);const i=new Uint8Array(this.valueBlock.valueHex);for(let s=0;s<r;s++)i[s]=e.charCodeAt(s);this.valueBlock.value=t}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.value}`}}class yi extends(Jr(Pr)){constructor(t={}){super(t),this.valueDec=Ur(t,"valueDec",-1)}static blockName(){return"relativeSidBlock"}fromBER(t,e,r){if(0===r)return e;if(!1===Cr(this,t,e,r))return-1;const i=new Uint8Array(t,e,r);this.valueHex=new ArrayBuffer(r);let s=new Uint8Array(this.valueHex);for(let a=0;a<r&&(s[a]=127&i[a],this.blockLength++,0!=(128&i[a]));a++);const n=new ArrayBuffer(this.blockLength),o=new Uint8Array(n);for(let a=0;a<this.blockLength;a++)o[a]=s[a];return this.valueHex=n.slice(0),s=new Uint8Array(this.valueHex),0!=(128&i[this.blockLength-1])?(this.error="End of input reached before message was fully decoded",-1):(0===s[0]&&this.warnings.push("Needlessly long format of SID encoding"),this.blockLength<=8?this.valueDec=qr(s,7):(this.isHexOnly=!0,this.warnings.push("Too big SID for decoding, hex only")),e+this.blockLength)}toBER(t=!1){let e,r;if(this.isHexOnly){if(!0===t)return new ArrayBuffer(this.valueHex.byteLength);const i=new Uint8Array(this.valueHex);e=new ArrayBuffer(this.blockLength),r=new Uint8Array(e);for(let t=0;t<this.blockLength-1;t++)r[t]=128|i[t];return r[this.blockLength-1]=i[this.blockLength-1],e}const i=Or(this.valueDec,7);if(0===i.byteLength)return this.error="Error during encoding SID value",new ArrayBuffer(0);if(e=new ArrayBuffer(i.byteLength),!1===t){const t=new Uint8Array(i);r=new Uint8Array(e);for(let e=0;e<i.byteLength-1;e++)r[e]=128|t[e];r[i.byteLength-1]=t[i.byteLength-1]}return e}toString(){let t="";return t=!0===this.isHexOnly?Ir(this.valueHex,0,this.valueHex.byteLength):this.valueDec.toString(),t}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.valueDec=this.valueDec,t}}class wi extends Hr{constructor(t={}){super(t),this.fromString(Ur(t,"value",""))}fromBER(t,e,r){let i=e;for(;r>0;){const e=new yi;if(i=e.fromBER(t,i,r),-1===i)return this.blockLength=0,this.error=e.error,i;this.blockLength+=e.blockLength,r-=e.blockLength,this.value.push(e)}return i}toBER(t=!1){let e=new ArrayBuffer(0);for(let r=0;r<this.value.length;r++){const i=this.value[r].toBER(t);if(0===i.byteLength)return this.error=this.value[r].error,new ArrayBuffer(0);e=Rr(e,i)}return e}fromString(t){this.value=[];let e=0,r=0,i="";do{r=t.indexOf(".",e),i=-1===r?t.substr(e):t.substr(e,r-e),e=r+1;const s=new yi;if(s.valueDec=parseInt(i,10),isNaN(s.valueDec))return!0;this.value.push(s)}while(-1!==r);return!0}toString(){let t="",e=!1;for(let r=0;r<this.value.length;r++){e=this.value[r].isHexOnly;let i=this.value[r].toString();0!==r&&(t+="."),e?(i=`{${i}}`,t+=i):t+=i}return t}static blockName(){return"RelativeObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}t.value=this.toString(),t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class pi extends Wr{constructor(t={}){super(t,wi),this.idBlock.tagClass=1,this.idBlock.tagNumber=13}static blockName(){return"RelativeObjectIdentifier"}}class vi extends(Jr(Pr)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class gi extends Wr{constructor(t={}){super(t,vi),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=30}static blockName(){return"BMPString"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let i=0;i<r.length;i+=2){const t=r[i];r[i]=r[i+1],r[i+1]=t}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(2*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<e;i++){const e=Or(t.charCodeAt(i),8),s=new Uint8Array(e);if(s.length>2)continue;const n=2-s.length;for(let t=s.length-1;t>=0;t--)r[2*i+t+n]=s[t]}this.valueBlock.value=t}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.value}`}}class mi extends(Jr(Pr)){constructor(t={}){super(t),this.isHexOnly=!0,this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class bi extends Wr{constructor(t={}){super(t,mi),"value"in t&&this.fromString(t.value),this.idBlock.tagClass=1,this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){const e=t.slice(0),r=new Uint8Array(e);for(let i=0;i<r.length;i+=4)r[i]=r[i+3],r[i+1]=r[i+2],r[i+2]=0,r[i+3]=0;this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(e))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(4*e);const r=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<e;i++){const e=Or(t.charCodeAt(i),8),s=new Uint8Array(e);if(s.length>4)continue;const n=4-s.length;for(let t=s.length-1;t>=0;t--)r[4*i+t+n]=s[t]}this.valueBlock.value=t}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.value}`}}class Ai extends(Jr(Pr)){constructor(t={}){super(t),this.value="",this.isHexOnly=!0}static blockName(){return"SimpleStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.value=this.value,t}}class Si extends Wr{constructor(t={}){super(t,Ai),"value"in t&&this.fromString(t.value)}static blockName(){return"SIMPLESTRING"}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t))}fromString(t){const e=t.length;this.valueBlock.valueHex=new ArrayBuffer(e);const r=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<e;i++)r[i]=t.charCodeAt(i);this.valueBlock.value=t}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.value}`}}class Bi extends Si{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}class Ei extends Si{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}class ki extends Si{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}class xi extends Si{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}class Ni extends Si{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}class Ui extends Si{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}class Ii extends Si{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}class Ci extends Si{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}class qi extends Si{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}class Oi extends Ii{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=23}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let i=0;i<t.length;i++)r[i]=t.charCodeAt(i);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(t){const e=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi.exec(t);if(null===e)return void(this.error="Wrong input string for convertion");const r=parseInt(e[1],10);this.year=r>=50?1900+r:2e3+r,this.month=parseInt(e[2],10),this.day=parseInt(e[3],10),this.hour=parseInt(e[4],10),this.minute=parseInt(e[5],10),this.second=parseInt(e[6],10)}toString(){const t=new Array(7);return t[0]=jr(this.year<2e3?this.year-1900:this.year-2e3,2),t[1]=jr(this.month,2),t[2]=jr(this.day,2),t[3]=jr(this.hour,2),t[4]=jr(this.minute,2),t[5]=jr(this.second,2),t[6]="Z",t.join("")}static blockName(){return"UTCTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t}}class Ri extends Ii{constructor(t={}){if(super(t),this.year=0,this.month=0,this.day=0,this.hour=0,this.minute=0,this.second=0,this.millisecond=0,"value"in t){this.fromString(t.value),this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const e=new Uint8Array(this.valueBlock.valueHex);for(let r=0;r<t.value.length;r++)e[r]=t.value.charCodeAt(r)}"valueDate"in t&&(this.fromDate(t.valueDate),this.valueBlock.valueHex=this.toBuffer()),this.idBlock.tagClass=1,this.idBlock.tagNumber=24}fromBER(t,e,r){const i=this.valueBlock.fromBER(t,e,!0===this.lenBlock.isIndefiniteForm?r:this.lenBlock.length);return-1===i?(this.error=this.valueBlock.error,i):(this.fromBuffer(this.valueBlock.valueHex),0===this.idBlock.error.length&&(this.blockLength+=this.idBlock.blockLength),0===this.lenBlock.error.length&&(this.blockLength+=this.lenBlock.blockLength),0===this.valueBlock.error.length&&(this.blockLength+=this.valueBlock.blockLength),i)}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString(),e=new ArrayBuffer(t.length),r=new Uint8Array(e);for(let i=0;i<t.length;i++)r[i]=t.charCodeAt(i);return e}fromDate(t){this.year=t.getUTCFullYear(),this.month=t.getUTCMonth()+1,this.day=t.getUTCDate(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(t){let e,r=!1,i="",s="",n=0,o=0,a=0;if("Z"===t[t.length-1])i=t.substr(0,t.length-1),r=!0;else{const e=new Number(t[t.length-1]);if(isNaN(e.valueOf()))throw new Error("Wrong input string for convertion");i=t}if(r){if(-1!==i.indexOf("+"))throw new Error("Wrong input string for convertion");if(-1!==i.indexOf("-"))throw new Error("Wrong input string for convertion")}else{let t=1,e=i.indexOf("+"),r="";if(-1===e&&(e=i.indexOf("-"),t=-1),-1!==e){if(r=i.substr(e+1),i=i.substr(0,e),2!==r.length&&4!==r.length)throw new Error("Wrong input string for convertion");let s=new Number(r.substr(0,2));if(isNaN(s.valueOf()))throw new Error("Wrong input string for convertion");if(o=t*s,4===r.length){if(s=new Number(r.substr(2,2)),isNaN(s.valueOf()))throw new Error("Wrong input string for convertion");a=t*s}}}let c=i.indexOf(".");if(-1===c&&(c=i.indexOf(",")),-1!==c){const t=new Number("0"+i.substr(c));if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");n=t.valueOf(),s=i.substr(0,c)}else s=i;switch(!0){case 8===s.length:if(e=/(\d{4})(\d{2})(\d{2})/gi,-1!==c)throw new Error("Wrong input string for convertion");break;case 10===s.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let t=60*n;this.minute=Math.floor(t),t=60*(t-this.minute),this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 12===s.length:if(e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c){let t=60*n;this.second=Math.floor(t),t=1e3*(t-this.second),this.millisecond=Math.floor(t)}break;case 14===s.length:e=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi,-1!==c&&(this.millisecond=Math.floor(1e3*n));break;default:throw new Error("Wrong input string for convertion")}const h=e.exec(s);if(null===h)throw new Error("Wrong input string for convertion");for(let u=1;u<h.length;u++)switch(u){case 1:this.year=parseInt(h[u],10);break;case 2:this.month=parseInt(h[u],10);break;case 3:this.day=parseInt(h[u],10);break;case 4:this.hour=parseInt(h[u],10)+o;break;case 5:this.minute=parseInt(h[u],10)+a;break;case 6:this.second=parseInt(h[u],10);break;default:throw new Error("Wrong input string for convertion")}if(!1===r){const t=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=t.getUTCFullYear(),this.month=t.getUTCMonth(),this.day=t.getUTCDay(),this.hour=t.getUTCHours(),this.minute=t.getUTCMinutes(),this.second=t.getUTCSeconds(),this.millisecond=t.getUTCMilliseconds()}}toString(){const t=[];return t.push(jr(this.year,4)),t.push(jr(this.month,2)),t.push(jr(this.day,2)),t.push(jr(this.hour,2)),t.push(jr(this.minute,2)),t.push(jr(this.second,2)),0!==this.millisecond&&(t.push("."),t.push(jr(this.millisecond,3))),t.push("Z"),t.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let t={};try{t=super.toJSON()}catch(e){}return t.year=this.year,t.month=this.month,t.day=this.day,t.hour=this.hour,t.minute=this.minute,t.second=this.second,t.millisecond=this.millisecond,t}}class Ti extends di{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=31}static blockName(){return"DATE"}}class Ki extends di{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}class Di extends di{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}class ji extends di{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=34}static blockName(){return"Duration"}}class $i extends di{constructor(t={}){super(t),this.idBlock.tagClass=1,this.idBlock.tagNumber=14}static blockName(){return"TIME"}}class Pi{constructor(t={}){this.value=Ur(t,"value",[]),this.optional=Ur(t,"optional",!1)}}class Ji{constructor(t={}){this.name=Ur(t,"name",""),this.optional=Ur(t,"optional",!1)}}class Vi{constructor(t={}){this.name=Ur(t,"name",""),this.optional=Ur(t,"optional",!1),this.value=Ur(t,"value",new Ji),this.local=Ur(t,"local",!1)}}function Mi(t,e,r){const i=e;let s=new Wr({},Object);const n=new Pr;if(!1===Cr(n,t,e,r))return s.error=n.error,{offset:-1,result:s};if(0===new Uint8Array(t,e,r).length)return s.error="Zero buffer length",{offset:-1,result:s};let o=s.idBlock.fromBER(t,e,r);if(s.warnings.concat(s.idBlock.warnings),-1===o)return s.error=s.idBlock.error,{offset:-1,result:s};if(o=s.lenBlock.fromBER(t,e=o,r-=s.idBlock.blockLength),s.warnings.concat(s.lenBlock.warnings),-1===o)return s.error=s.lenBlock.error,{offset:-1,result:s};if(e=o,r-=s.lenBlock.blockLength,!1===s.idBlock.isConstructed&&!0===s.lenBlock.isIndefiniteForm)return s.error="Indefinite length form used for primitive encoding form",{offset:-1,result:s};let a=Wr;switch(s.idBlock.tagClass){case 1:if(s.idBlock.tagNumber>=37&&!1===s.idBlock.isHexOnly)return s.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard",{offset:-1,result:s};switch(s.idBlock.tagNumber){case 0:if(!0===s.idBlock.isConstructed&&s.lenBlock.length>0)return s.error="Type [UNIVERSAL 0] is reserved",{offset:-1,result:s};a=Zr;break;case 1:a=Qr;break;case 2:a=ai;break;case 3:a=ni;break;case 4:a=ii;break;case 5:a=ei;break;case 6:a=fi;break;case 10:a=ci;break;case 12:a=di;break;case 13:a=pi;break;case 14:a=$i;break;case 15:return s.error="[UNIVERSAL 15] is reserved by ASN.1 standard",{offset:-1,result:s};case 16:a=Yr;break;case 17:a=ti;break;case 18:a=Bi;break;case 19:a=Ei;break;case 20:a=ki;break;case 21:a=xi;break;case 22:a=Ni;break;case 23:a=Oi;break;case 24:a=Ri;break;case 25:a=Ui;break;case 26:a=Ii;break;case 27:a=Ci;break;case 28:a=bi;break;case 29:a=qi;break;case 30:a=gi;break;case 31:a=Ti;break;case 32:a=Ki;break;case 33:a=Di;break;case 34:a=ji;break;default:{let t;t=!0===s.idBlock.isConstructed?new zr:new Lr,t.idBlock=s.idBlock,t.lenBlock=s.lenBlock,t.warnings=s.warnings,s=t}}break;case 2:case 3:case 4:default:a=!0===s.idBlock.isConstructed?zr:Lr}return s=function(t,e){if(t instanceof e)return t;const r=new e;return r.idBlock=t.idBlock,r.lenBlock=t.lenBlock,r.warnings=t.warnings,r.valueBeforeDecode=t.valueBeforeDecode.slice(0),r}(s,a),o=s.fromBER(t,e,!0===s.lenBlock.isIndefiniteForm?r:s.lenBlock.length),s.valueBeforeDecode=t.slice(i,i+s.blockLength),{offset:o,result:s}}function Hi(t){if(0===t.byteLength){const t=new Wr({},Object);return t.error="Input buffer has zero length",{offset:-1,result:t}}return Mi(t,0,t.byteLength)}function Wi(t,e,r){if(r instanceof Pi){for(let i=0;i<r.value.length;i++)if(!0===Wi(t,e,r.value[i]).verified)return{verified:!0,result:t};{const t={verified:!1,result:{error:"Wrong values for Choice type"}};return r.hasOwnProperty("name")&&(t.name=r.name),t}}if(r instanceof Ji)return r.hasOwnProperty("name")&&(t[r.name]=e),{verified:!0,result:t};if(t instanceof Object==0)return{verified:!1,result:{error:"Wrong root object"}};if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 data"}};if(r instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("idBlock"in r==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("fromBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if("toBER"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const i=r.idBlock.toBER(!1);if(0===i.byteLength)return{verified:!1,result:{error:"Error encoding idBlock for ASN.1 schema"}};if(-1===r.idBlock.fromBER(i,0,i.byteLength))return{verified:!1,result:{error:"Error decoding idBlock for ASN.1 schema"}};if(!1===r.idBlock.hasOwnProperty("tagClass"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagClass!==e.idBlock.tagClass)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("tagNumber"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.tagNumber!==e.idBlock.tagNumber)return{verified:!1,result:t};if(!1===r.idBlock.hasOwnProperty("isConstructed"))return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isConstructed!==e.idBlock.isConstructed)return{verified:!1,result:t};if("isHexOnly"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};if(r.idBlock.isHexOnly!==e.idBlock.isHexOnly)return{verified:!1,result:t};if(!0===r.idBlock.isHexOnly){if("valueHex"in r.idBlock==0)return{verified:!1,result:{error:"Wrong ASN.1 schema"}};const i=new Uint8Array(r.idBlock.valueHex),s=new Uint8Array(e.idBlock.valueHex);if(i.length!==s.length)return{verified:!1,result:t};for(let e=0;e<i.length;e++)if(i[e]!==s[1])return{verified:!1,result:t}}if(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(t[r.name]=e)),!0===r.idBlock.isConstructed){let i=0,s={verified:!1},n=r.valueBlock.value.length;if(n>0&&r.valueBlock.value[0]instanceof Vi&&(n=e.valueBlock.value.length),0===n)return{verified:!0,result:t};if(0===e.valueBlock.value.length&&0!==r.valueBlock.value.length){let e=!0;for(let t=0;t<r.valueBlock.value.length;t++)e=e&&(r.valueBlock.value[t].optional||!1);return!0===e?{verified:!0,result:t}:(r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),t.error="Inconsistent object length",{verified:!1,result:t})}for(let o=0;o<n;o++)if(o-i>=e.valueBlock.value.length){if(!1===r.valueBlock.value[o].optional){const e={verified:!1,result:t};return t.error="Inconsistent length between ASN.1 data and schema",r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}}else if(r.valueBlock.value[0]instanceof Vi){if(s=Wi(t,e.valueBlock.value[o],r.valueBlock.value[0].value),!1===s.verified){if(!0!==r.valueBlock.value[0].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),s;i++}if("name"in r.valueBlock.value[0]&&r.valueBlock.value[0].name.length>0){let i={};i="local"in r.valueBlock.value[0]&&!0===r.valueBlock.value[0].local?e:t,void 0===i[r.valueBlock.value[0].name]&&(i[r.valueBlock.value[0].name]=[]),i[r.valueBlock.value[0].name].push(e.valueBlock.value[o])}}else if(s=Wi(t,e.valueBlock.value[o-i],r.valueBlock.value[o]),!1===s.verified){if(!0!==r.valueBlock.value[o].optional)return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&delete t[r.name]),s;i++}if(!1===s.verified){const e={verified:!1,result:t};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return{verified:!0,result:t}}if("primitiveSchema"in r&&"valueHex"in e.valueBlock){const i=Hi(e.valueBlock.valueHex);if(-1===i.offset){const e={verified:!1,result:i.result};return r.hasOwnProperty("name")&&(r.name=r.name.replace(/^\s+|\s+$/g,""),""!==r.name&&(delete t[r.name],e.name=r.name)),e}return Wi(t,i.result,r.primitiveSchema)}return{verified:!0,result:t}}var _i,Li,Gi=Object.freeze({__proto__:null,HexBlock:Jr,ValueBlock:Hr,BaseBlock:Wr,Primitive:Lr,Constructed:zr,EndOfContent:Zr,Boolean:Qr,Sequence:Yr,Set:ti,Null:ei,OctetString:ii,BitString:ni,Integer:ai,Enumerated:ci,ObjectIdentifier:fi,Utf8String:di,RelativeObjectIdentifier:pi,BmpString:gi,UniversalString:bi,NumericString:Bi,PrintableString:Ei,TeletexString:ki,VideotexString:xi,IA5String:Ni,GraphicString:Ui,VisibleString:Ii,GeneralString:Ci,CharacterString:qi,UTCTime:Oi,GeneralizedTime:Ri,DATE:Ti,TimeOfDay:Ki,DateTime:Di,Duration:ji,TIME:$i,Choice:Pi,Any:Ji,Repeated:Vi,RawData:class{constructor(t={}){this.data=Ur(t,"data",new ArrayBuffer(0))}fromBER(t,e,r){return this.data=t.slice(e,r),e+r}toBER(t=!1){return this.data}},fromBER:Hi,compareSchema:Wi,verifySchema:function(t,e){if(e instanceof Object==0)return{verified:!1,result:{error:"Wrong ASN.1 schema type"}};const r=Hi(t);return-1===r.offset?{verified:!1,result:r.result}:Wi(r.result,r.result,e)},fromJSON:function(){}});!function(t){t[t.Sequence=0]="Sequence",t[t.Set=1]="Set",t[t.Choice=2]="Choice"}(_i||(_i={})),function(t){t[t.Any=1]="Any",t[t.Boolean=2]="Boolean",t[t.OctetString=3]="OctetString",t[t.BitString=4]="BitString",t[t.Integer=5]="Integer",t[t.Enumerated=6]="Enumerated",t[t.ObjectIdentifier=7]="ObjectIdentifier",t[t.Utf8String=8]="Utf8String",t[t.BmpString=9]="BmpString",t[t.UniversalString=10]="UniversalString",t[t.NumericString=11]="NumericString",t[t.PrintableString=12]="PrintableString",t[t.TeletexString=13]="TeletexString",t[t.VideotexString=14]="VideotexString",t[t.IA5String=15]="IA5String",t[t.GraphicString=16]="GraphicString",t[t.VisibleString=17]="VisibleString",t[t.GeneralString=18]="GeneralString",t[t.CharacterString=19]="CharacterString",t[t.UTCTime=20]="UTCTime",t[t.GeneralizedTime=21]="GeneralizedTime",t[t.DATE=22]="DATE",t[t.TimeOfDay=23]="TimeOfDay",t[t.DateTime=24]="DateTime",t[t.Duration=25]="Duration",t[t.TIME=26]="TIME",t[t.Null=27]="Null"}(Li||(Li={}));const zi={fromASN:t=>t instanceof ei?null:t.valueBeforeDecode,toASN:t=>{if(null===t)return new ei;const e=Hi(t);if(e.result.error)throw new Error(e.result.error);return e.result}},Fi={fromASN:t=>t.valueBlock.valueHex.byteLength>4?t.valueBlock.toString():t.valueBlock.valueDec,toASN:t=>new ai({value:t})},Zi={fromASN:t=>t.valueBlock.valueDec,toASN:t=>new ci({value:t})},Xi={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new ni({valueHex:t})},Qi={fromASN:t=>t.valueBlock.toString(),toASN:t=>new fi({value:t})},Yi={fromASN:t=>t.valueBlock.value,toASN:t=>new Qr({value:t})},ts={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new ii({valueHex:t})};function es(t){return{fromASN:t=>t.valueBlock.value,toASN:e=>new t({value:e})}}const rs=es(di),is=es(gi),ss=es(bi),ns=es(Bi),os=es(Ei),as=es(ki),cs=es(xi),hs=es(Ni),us=es(Ui),fs=es(Ii),ls=es(Ci),ds=es(qi),ys={fromASN:t=>t.toDate(),toASN:t=>new Oi({valueDate:t})},ws={fromASN:t=>t.toDate(),toASN:t=>new Ri({valueDate:t})},ps={fromASN:()=>null,toASN:()=>new ei};function vs(t){switch(t){case Li.Any:return zi;case Li.BitString:return Xi;case Li.BmpString:return is;case Li.Boolean:return Yi;case Li.CharacterString:return ds;case Li.Enumerated:return Zi;case Li.GeneralString:return ls;case Li.GeneralizedTime:return ws;case Li.GraphicString:return us;case Li.IA5String:return hs;case Li.Integer:return Fi;case Li.Null:return ps;case Li.NumericString:return ns;case Li.ObjectIdentifier:return Qi;case Li.OctetString:return ts;case Li.PrintableString:return os;case Li.TeletexString:return as;case Li.UTCTime:return ys;case Li.UniversalString:return ss;case Li.Utf8String:return rs;case Li.VideotexString:return cs;case Li.VisibleString:return fs;default:return null}}function gs(t){return t&&t.prototype?!(!t.prototype.toASN||!t.prototype.fromASN)||gs(t.prototype):!!(t&&t.toASN&&t.fromASN)}function ms(t,e){if(!t||!e)return!1;if(t.byteLength!==e.byteLength)return!1;const r=new Uint8Array(t),i=new Uint8Array(e);for(let s=0;s<t.byteLength;s++)if(r[s]!==i[s])return!1;return!0}const bs=new class{constructor(){this.items=new WeakMap}has(t){return this.items.has(t)}get(t){var e,r,i,s;const n=this.items.get(t);if(!n)throw new Error(`Cannot get schema for '${null!==(s=null===(i=null===(r=null===(e=t)||void 0===e?void 0:e.prototype)||void 0===r?void 0:r.constructor)||void 0===i?void 0:i.name)&&void 0!==s?s:t}' target`);return n}cache(t){const e=this.get(t);e.schema||(e.schema=this.create(t,!0))}createDefault(t){const e={type:_i.Sequence,items:{}},r=this.findParentSchema(t);return r&&(Object.assign(e,r),e.items=Object.assign({},e.items,r.items)),e}create(t,e){const r=this.items.get(t)||this.createDefault(t),i=[];for(const s in r.items){const t=r.items[s],n=e?s:"";let o;if("number"==typeof t.type){const e=Li[t.type],r=Gi[e];if(!r)throw new Error(`Cannot get ASN1 class by name '${e}'`);o=new r({name:n})}else gs(t.type)?o=(new t.type).toSchema(n):t.optional?this.get(t.type).type===_i.Choice?o=new Ji({name:n}):(o=this.create(t.type,!1),o.name=n):o=new Ji({name:n});const a=!!t.optional||void 0!==t.defaultValue;if(t.repeated&&(o.name="",o=new("set"===t.repeated?ti:Yr)({name:"",value:[new Vi({name:n,value:o})]})),null!=t.context)if(t.implicit)if("number"==typeof t.type||gs(t.type))i.push(new(t.repeated?zr:Lr)({name:n,optional:a,idBlock:{tagClass:3,tagNumber:t.context}}));else{this.cache(t.type);const e=!!t.repeated;let r=e?o:this.get(t.type).schema;r=r.valueBlock?r.valueBlock.value:r.value,i.push(new zr({name:e?"":n,optional:a,idBlock:{tagClass:3,tagNumber:t.context},value:r}))}else i.push(new zr({optional:a,idBlock:{tagClass:3,tagNumber:t.context},value:[o]}));else o.optional=a,i.push(o)}switch(r.type){case _i.Sequence:return new Yr({value:i,name:""});case _i.Set:return new ti({value:i,name:""});case _i.Choice:return new Pi({value:i,name:""});default:throw new Error("Unsupported ASN1 type in use")}}set(t,e){return this.items.set(t,e),this}findParentSchema(t){const e=t.__proto__;return e?this.items.get(e)||this.findParentSchema(e):null}},As=t=>e=>{let r;bs.has(e)?r=bs.get(e):(r=bs.createDefault(e),bs.set(e,r)),Object.assign(r,t)},Ss=t=>(e,r)=>{let i;bs.has(e.constructor)?i=bs.get(e.constructor):(i=bs.createDefault(e.constructor),bs.set(e.constructor,i));const s=Object.assign({},t);if("number"==typeof s.type&&!s.converter){const i=vs(t.type);if(!i)throw new Error(`Cannot get default converter for property '${r}' of ${e.constructor.name}`);s.converter=i}i.items[r]=s};class Bs{static serialize(t){return t instanceof Wr?t.toBER(!1):this.toASN(t).toBER(!1)}static toASN(t){if(t&&gs(t.constructor))return t.toASN();const e=t.constructor,r=bs.get(e);bs.cache(e);let i,s=[];if(r.itemType)if("number"==typeof r.itemType){const i=vs(r.itemType);if(!i)throw new Error(`Cannot get default converter for array item of ${e.name} ASN1 schema`);s=t.map(t=>i.toASN(t))}else s=t.map(t=>this.toAsnItem({type:r.itemType},"[]",e,t));else for(const n in r.items){const i=r.items[n],o=t[n];if(void 0===o||i.defaultValue===o||"object"==typeof i.defaultValue&&"object"==typeof o&&ms(this.serialize(i.defaultValue),this.serialize(o)))continue;let a=Bs.toAsnItem(i,n,e,o);if("number"==typeof i.context)if(i.implicit)if(i.repeated||"number"!=typeof i.type&&!gs(i.type))s.push(new zr({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:a.valueBlock.value}));else{const t={};t.valueHex=a instanceof ei?a.valueBeforeDecode:a.valueBlock.toBER(),s.push(new Lr(Object.assign({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context}},t)))}else s.push(new zr({optional:i.optional,idBlock:{tagClass:3,tagNumber:i.context},value:[a]}));else i.repeated?s=s.concat(a):s.push(a)}switch(r.type){case _i.Sequence:i=new Yr({value:s});break;case _i.Set:i=new ti({value:s});break;case _i.Choice:if(!s[0])throw new Error(`Schema '${e.name}' has wrong data. Choice cannot be empty.`);i=s[0]}return i}static toAsnItem(t,e,r,i){let s;if("number"==typeof t.type){const n=t.converter;if(!n)throw new Error(`Property '${e}' doesn't have converter for type ${Li[t.type]} in schema '${r.name}'`);if(t.repeated){const e=Array.from(i,t=>n.toASN(t));s=new("sequence"===t.repeated?Yr:ti)({value:e})}else s=n.toASN(i)}else if(t.repeated){const e=Array.from(i,t=>this.toASN(t));s=new("sequence"===t.repeated?Yr:ti)({value:e})}else s=this.toASN(i);return s}}class Es extends Error{constructor(t,e){super(e?t+". See the inner exception for more details.":t),this.message=t,this.innerError=e}}class ks extends Es{}var xs;function Ns(t,e){if(!function(t,e){switch(e){case xs.Boolean:return"boolean"==typeof t;case xs.Number:return"number"==typeof t;case xs.String:return"string"==typeof t}return!0}(t,e))throw new TypeError("Value must be "+xs[e])}!function(t){t[t.Any=0]="Any",t[t.Boolean=1]="Boolean",t[t.Number=2]="Number",t[t.String=3]="String"}(xs||(xs={}));const Us=new class{constructor(){this.items=new Map}has(t){return this.items.has(t)||!!this.findParentSchema(t)}get(t){const e=this.items.get(t)||this.findParentSchema(t);if(!e)throw new Error("Cannot get schema for current target");return e}create(t){const e={names:{}},r=this.findParentSchema(t);if(r){Object.assign(e,r),e.names={};for(const t in r.names)e.names[t]=Object.assign({},r.names[t])}return e.target=t,e}set(t,e){return this.items.set(t,e),this}findParentSchema(t){const e=t.__proto__;return e?this.items.get(e)||this.findParentSchema(e):null}};class Is{constructor(t){this.pattern=new RegExp(t)}validate(t){const e=new RegExp(this.pattern.source,this.pattern.flags);if("string"!=typeof t)throw new ks("Incoming value must be string");if(!e.exec(t))throw new ks(`Value doesn't match to pattern '${e.toString()}'`)}}class Cs{constructor(t=Number.MIN_VALUE,e=Number.MAX_VALUE){this.min=t,this.max=e}validate(t){if(Ns(t,xs.Number),!(this.min<=t&&t<=this.max))throw new ks(`Value doesn't match to diapason [${this.min===Number.MIN_VALUE?"MIN":this.min},${this.max===Number.MAX_VALUE?"MAX":this.max}]`)}}class qs{constructor(t=Number.MIN_VALUE,e=Number.MAX_VALUE){this.min=t,this.max=e}validate(t){if(Ns(t,xs.Number),!(this.min<t&&t<this.max))throw new ks(`Value doesn't match to diapason (${this.min===Number.MIN_VALUE?"MIN":this.min},${this.max===Number.MAX_VALUE?"MAX":this.max})`)}}class Os{constructor(t,e,r){this.length=t,this.minLength=e,this.maxLength=r}validate(t){if(void 0===this.length){if(void 0!==this.minLength&&t.length<this.minLength)throw new ks(`Value length must be more than ${this.minLength}.`);if(void 0!==this.maxLength&&t.length>this.maxLength)throw new ks(`Value length must be less than ${this.maxLength}.`)}else if(t.length!==this.length)throw new ks(`Value length must be exactly ${this.length}.`)}}class Rs{constructor(t){this.enumeration=t}validate(t){if(Ns(t,xs.String),!this.enumeration.includes(t))throw new ks("Value must be one of "+this.enumeration.map(t=>`'${t}'`).join(", "))}}const Ts=(t={})=>(e,r)=>{const i=`Cannot set type for ${r} property of ${e.constructor.name} schema`;let s;Us.has(e.constructor)?(s=Us.get(e.constructor),s.target!==e.constructor&&(s=Us.create(e.constructor),Us.set(e.constructor,s))):(s=Us.create(e.constructor),Us.set(e.constructor,s));const n=Object.assign({type:xs.Any,validations:[]},t);if(n.validations=function(t){const e=[];return t.pattern&&e.push(new Is(t.pattern)),t.type!==xs.Number&&t.type!==xs.Any||(void 0===t.minInclusive&&void 0===t.maxInclusive||e.push(new Cs(t.minInclusive,t.maxInclusive)),void 0===t.minExclusive&&void 0===t.maxExclusive||e.push(new qs(t.minExclusive,t.maxExclusive)),void 0!==t.enumeration&&e.push(new Rs(t.enumeration))),(t.type===xs.String||t.repeated||t.type===xs.Any)&&(void 0===t.length&&void 0===t.minLength&&void 0===t.maxLength||e.push(new Os(t.length,t.minLength,t.maxLength))),e}(n),"number"!=typeof n.type&&!Us.has(n.type)&&!function t(e){return e&&e.prototype?!(!e.prototype.toJSON||!e.prototype.fromJSON)||t(e.prototype):!!(e&&e.toJSON&&e.fromJSON)}(n.type))throw new Error(i+". Assigning type doesn't have schema.");let o;o=Array.isArray(t.schema)?t.schema:[t.schema||"default"];for(const t of o)s.names[t]||(s.names[t]={}),s.names[t][r]=n};class Ks extends Error{}class Ds{static toArrayBuffer(t){const e=t.replace(/-{5}(BEGIN|END) .*-{5}/g,"").replace("\r","").replace("\n","");return c.FromBase64(e)}static toUint8Array(t){const e=this.toArrayBuffer(t);return new Uint8Array(e)}static fromBufferSource(t,e){const r=c.ToBase64(t);let i,s=0;const n=[];for(;i=r.slice(s,s+=64),i.length&&(n.push(i),!(i.length<64)););const o=e.toUpperCase();return`-----BEGIN ${o}-----\n${n.join("\n")}\n-----END ${o}-----`}static isPEM(t){return/-----BEGIN .+-----[A-Za-z0-9+\/\+\=\s\n]+-----END .+-----/i.test(t)}static getTagName(t){if(!this.isPEM(t))throw new Error("Bad parameter. Incoming data is not right PEM");const e=/-----BEGIN (.+)-----/.exec(t);if(!e)throw new Error("Cannot get tag from PEM");return e[1]}static hasTagName(t,e){const r=this.getTagName(t);return e.toLowerCase()===r.toLowerCase()}static isCertificate(t){return this.hasTagName(t,"certificate")}static isCertificateRequest(t){return this.hasTagName(t,"certificate request")}static isCRL(t){return this.hasTagName(t,"x509 crl")}static isPublicKey(t){return this.hasTagName(t,"public key")}}let js=class{constructor(t){t&&(this.value=t)}};nt([Ss({type:Li.ObjectIdentifier})],js.prototype,"value",void 0),js=nt([As({type:_i.Choice})],js);class $s{constructor(t){Object.assign(this,t)}}nt([Ss({type:Li.ObjectIdentifier})],$s.prototype,"algorithm",void 0),nt([Ss({type:Li.Any,optional:!0})],$s.prototype,"parameters",void 0);class Ps{constructor(){this.version=0,this.privateKeyAlgorithm=new $s,this.privateKey=new ArrayBuffer(0)}}nt([Ss({type:Li.Integer})],Ps.prototype,"version",void 0),nt([Ss({type:$s})],Ps.prototype,"privateKeyAlgorithm",void 0),nt([Ss({type:Li.OctetString})],Ps.prototype,"privateKey",void 0),nt([Ss({type:Li.Any,optional:!0})],Ps.prototype,"attributes",void 0);class Js{constructor(){this.publicKeyAlgorithm=new $s,this.publicKey=new ArrayBuffer(0)}}nt([Ss({type:$s})],Js.prototype,"publicKeyAlgorithm",void 0),nt([Ss({type:Li.BitString})],Js.prototype,"publicKey",void 0);const Vs={fromJSON:t=>c.FromBase64Url(t),toJSON:t=>c.ToBase64Url(new Uint8Array(t))},Ms={fromASN:t=>new Uint8Array(t.valueBlock.valueHex)[0]?t.valueBlock.valueHex:t.valueBlock.valueHex.slice(1),toASN:t=>{const e=new Uint8Array(t)[0]>127?Buffer.concat([Buffer.from([0]),Buffer.from(t)]):Buffer.from(t);return new ai({valueHex:new Uint8Array(e).buffer})}};var Hs=Object.freeze({__proto__:null,JsonBase64UrlArrayBufferConverter:Vs,AsnIntegerArrayBufferConverter:Ms});class Ws{constructor(){this.version=0,this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0),this.privateExponent=new ArrayBuffer(0),this.prime1=new ArrayBuffer(0),this.prime2=new ArrayBuffer(0),this.exponent1=new ArrayBuffer(0),this.exponent2=new ArrayBuffer(0),this.coefficient=new ArrayBuffer(0)}}nt([Ss({type:Li.Integer,converter:Fi})],Ws.prototype,"version",void 0),nt([Ss({type:Li.Integer,converter:Ms}),Ts({name:"n",converter:Vs})],Ws.prototype,"modulus",void 0),nt([Ss({type:Li.Integer,converter:Ms}),Ts({name:"e",converter:Vs})],Ws.prototype,"publicExponent",void 0),nt([Ss({type:Li.Integer,converter:Ms}),Ts({name:"d",converter:Vs})],Ws.prototype,"privateExponent",void 0),nt([Ss({type:Li.Integer,converter:Ms}),Ts({name:"p",converter:Vs})],Ws.prototype,"prime1",void 0),nt([Ss({type:Li.Integer,converter:Ms}),Ts({name:"q",converter:Vs})],Ws.prototype,"prime2",void 0),nt([Ss({type:Li.Integer,converter:Ms}),Ts({name:"dp",converter:Vs})],Ws.prototype,"exponent1",void 0),nt([Ss({type:Li.Integer,converter:Ms}),Ts({name:"dq",converter:Vs})],Ws.prototype,"exponent2",void 0),nt([Ss({type:Li.Integer,converter:Ms}),Ts({name:"qi",converter:Vs})],Ws.prototype,"coefficient",void 0),nt([Ss({type:Li.Any,optional:!0})],Ws.prototype,"otherPrimeInfos",void 0);class _s{constructor(){this.modulus=new ArrayBuffer(0),this.publicExponent=new ArrayBuffer(0)}}nt([Ss({type:Li.Integer,converter:Ms}),Ts({name:"n",converter:Vs})],_s.prototype,"modulus",void 0),nt([Ss({type:Li.Integer,converter:Ms}),Ts({name:"e",converter:Vs})],_s.prototype,"publicExponent",void 0);let Ls=class{constructor(t){this.value=new ArrayBuffer(0),t&&(this.value=t)}toJSON(){let t=new Uint8Array(this.value);if(4!==t[0])throw new Ks("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");t=new Uint8Array(this.value.slice(1));const e=t.length/2;return{x:c.ToBase64Url(t.buffer.slice(0,0+e)),y:c.ToBase64Url(t.buffer.slice(0+e,0+e+e))}}fromJSON(t){if(!("x"in t))throw new Error("x: Missing required property");if(!("y"in t))throw new Error("y: Missing required property");const e=c.FromBase64Url(t.x),r=c.FromBase64Url(t.y),i=Buffer.concat([new Uint8Array([4]),new Uint8Array(e),new Uint8Array(r)]);return this.value=new Uint8Array(i).buffer,this}};nt([Ss({type:Li.OctetString})],Ls.prototype,"value",void 0),Ls=nt([As({type:_i.Choice})],Ls);class Gs{constructor(){this.version=1,this.privateKey=new ArrayBuffer(0)}fromJSON(t){if(!("d"in t))throw new Error("d: Missing required property");if(this.privateKey=c.FromBase64Url(t.d),"x"in t){const e=new Ls;e.fromJSON(t),this.publicKey=Bs.toASN(e).valueBlock.valueHex}return this}toJSON(){const t={};return t.d=c.ToBase64Url(this.privateKey),this.publicKey&&Object.assign(t,new Ls(this.publicKey).toJSON()),t}}nt([Ss({type:Li.Integer,converter:Fi})],Gs.prototype,"version",void 0),nt([Ss({type:Li.OctetString})],Gs.prototype,"privateKey",void 0),nt([Ss({context:0,type:Li.Any,optional:!0})],Gs.prototype,"parameters",void 0),nt([Ss({context:1,type:Li.BitString,optional:!0})],Gs.prototype,"publicKey",void 0);const zs={fromASN:t=>{const e=new Uint8Array(t.valueBlock.valueHex);return 0===e[0]?e.buffer.slice(1):e.buffer},toASN:t=>{const e=new Uint8Array(t);if(e[0]>127){const t=new Uint8Array(e.length+1);return t.set(e,1),new ai({valueHex:t.buffer})}return new ai({valueHex:t})}};var Fs=Object.freeze({__proto__:null,AsnIntegerWithoutPaddingConverter:zs});class Zs{constructor(){this.r=new ArrayBuffer(0),this.s=new ArrayBuffer(0)}static fromWebCryptoSignature(t){const e=a.toUint8Array(t),r=e.byteLength/2,i=new this;return i.r=i.removePadding(e.slice(0,r)),i.s=i.removePadding(e.slice(r,2*r)),i}toWebCryptoSignature(t){t=this.getPointSize();const e=this.addPadding(t,a.toUint8Array(this.r)),r=this.addPadding(t,a.toUint8Array(this.s)),i=new Uint8Array(e.byteLength+r.byteLength);return i.set(e,0),i.set(r,e.length),i.buffer}getPointSize(){switch(Math.max(this.r.byteLength,this.s.byteLength)){case 31:case 32:return 32;case 47:case 48:return 48;case 65:case 66:return 66}throw new Error("Unsupported EC point size")}addPadding(t,e){const r=new Uint8Array(t),i=a.toUint8Array(e);return r.set(i,t-i.length),r}removePadding(t){const e=a.toUint8Array(t);for(let r=0;r<e.length;r++)if(e[r])return e.slice(r);return new Uint8Array(0)}}nt([Ss({type:Li.Integer,converter:zs})],Zs.prototype,"r",void 0),nt([Ss({type:Li.Integer,converter:zs})],Zs.prototype,"s",void 0);let Xs=class{};function Qs(t){if(t instanceof At)return t;const e=new At;if("string"==typeof t)e.fromAlgorithm({name:t});else if((r=t)instanceof Object&&"name"in r&&"hash"in r){const r={...t};r.hash=Qs(t.hash),e.fromAlgorithm(r)}else e.fromAlgorithm({...t});var r;return e}function Ys(t,e){if(!t||"object"!=typeof t&&"string"!=typeof t)throw new TypeError(e+": Is wrong type. Must be Object or String");if("object"==typeof t&&!("name"in t))throw new TypeError(e+": Required property 'name' is missed")}function tn(t,e){if(!function(t){return t instanceof Bt}(t))throw new TypeError(e+": Is not type CryptoKey")}function en(t,e){if(!function(t){return t instanceof ie}(t))throw new TypeError(e+": Is not type CryptoCertificate")}function rn(t,e){if(!a.isBufferSource(t))throw new TypeError(e+": Is wrong type. Must be ArrayBuffer or ArrayBuffer view")}function sn(t,e){if(!Array.isArray(t))throw new TypeError(e+": Is not type Array")}function nn(t,e,r){if(typeof t!==e)throw new TypeError(`${r}: Is not type '${e}'`)}nt([Ss({type:Li.OctetString}),Ts({type:xs.String,converter:Vs})],Xs.prototype,"d",void 0),Xs=nt([As({type:_i.Choice})],Xs),Object.freeze({__proto__:null,converters:Fs,get ObjectIdentifier(){return js},AlgorithmIdentifier:$s,PrivateKeyInfo:Ps,PublicKeyInfo:Js,RsaPrivateKey:Ws,RsaPublicKey:_s,EcPrivateKey:Gs,get EcPublicKey(){return Ls},EcDsaSignature:Zs,get CurvePrivateKey(){return Xs},idX25519:"1.3.101.110",idX448:"1.3.101.111",idEd25519:"1.3.101.112",idEd448:"1.3.101.113"}),Object.freeze({__proto__:null,converters:Hs});const on=["raw","pem","x509","request"];class an{constructor(t){this.provider=t}static isX509Certificate(t){return t instanceof se}static isCertificateRequest(t){return t instanceof ne}async indexOf(t){en(t,"item");const e=new pe;e.providerID=this.provider.id,e.item=t;const r=await this.provider.client.send(e);return r?c.ToUtf8String(r):null}async hasItem(t){return!!(await this.indexOf(t))}async exportCert(t,e){nn(t,"string","format"),en(e,"item");const r=new we;r.providerID=this.provider.id,r.format="raw",r.item=e;const i=await this.provider.client.send(r);if("raw"===t)return i;{let t="";switch(e.type){case"x509":t="CERTIFICATE";break;case"request":t="CERTIFICATE REQUEST";break;default:throw new Error("Cannot create PEM for unknown type of certificate item")}return Ds.fromBufferSource(i,t)}}async importCert(t,e,r,i){if(nn(t,"string","format"),!~on.indexOf(t))throw new TypeError("format: Is invalid value. Must be "+on.join(", "));"pem"===t?nn(e,"string","data"):rn(e,"data"),Ys(r,"algorithm"),sn(i,"keyUsages");const s=Qs(r);let n;if(a.isBufferSource(e))n=a.toArrayBuffer(e);else{if("string"!=typeof e)throw new TypeError("data: Is not type String, ArrayBuffer or ArrayBufferView");n=Ds.toArrayBuffer(e)}const o=new ye;o.providerID=this.provider.id,o.format="raw",o.data=n,o.algorithm=s,o.keyUsages=i;const c=await this.provider.client.send(o),h=await ie.importProto(c);if(("request"===t||"x509"===t)&&h.type!==t)throw new TypeError("Imported item is not "+t);return this.prepareCertItem(h)}async keys(){const t=new ue;t.providerID=this.provider.id;const e=await this.provider.client.send(t);return e?c.ToUtf8String(e).split(","):[]}async getValue(t){nn(t,"string","key");const e=new fe;e.providerID=this.provider.id,e.key=t;return await this.provider.client.send(e)||null}async getItem(t,e,r){nn(t,"string","key"),e&&(Ys(e,"algorithm"),sn(r,"keyUsages"));const i=new he;i.providerID=this.provider.id,i.key=t,e&&(i.algorithm=Qs(e),i.keyUsages=r);const s=await this.provider.client.send(i);if(s&&s.byteLength){const t=await ie.importProto(s);return this.prepareCertItem(t)}throw new Error("Cannot get CryptoCertificate from storage by index")}async setItem(t){en(t,"value");const e=new ce;e.providerID=this.provider.id,e.item=t;const r=await this.provider.client.send(e);return c.ToUtf8String(r)}async removeItem(t){nn(t,"string","key");const e=new le;e.providerID=this.provider.id,e.key=t,await this.provider.client.send(e)}async clear(){const t=new de;t.providerID=this.provider.id,await this.provider.client.send(t)}async getChain(t){en(t,"value");const e=new ve;e.providerID=this.provider.id,e.item=t;const r=await this.provider.client.send(e);return(await ae.importProto(r)).items}async getCRL(t){nn(t,"string","url");const e=new ge;return e.providerID=this.provider.id,e.url=t,await this.provider.client.send(e)}async getOCSP(t,e,r){nn(t,"string","url"),rn(e,"request");const i=new be;if(i.providerID=this.provider.id,i.url=t,i.request=a.toArrayBuffer(e),r)for(const s in r)i.options[s]=r[s];return await this.provider.client.send(i)}async findPrivateKey(t){let e="string"==typeof t?t:await this.provider.certStorage.indexOf(t);e||(e="");const[,,r]=e.split("-"),i=(await this.provider.keyStorage.keys()).find(t=>{const[e,,i]=t.split("-");return"private"===e&&i===r});return i?await this.provider.keyStorage.getItem(i):null}async prepareCertItem(t){const e=await t.exportProto();let r;switch(t.type){case"x509":r=await se.importProto(e);break;case"request":r=await ne.importProto(e);break;default:throw new Error(`Unsupported CertificateItem type '${t.type}'`)}return r.provider=this.provider,r}}class cn{constructor(t){this.service=t}async keys(){const t=new Ne;t.providerID=this.service.id;const e=await this.service.client.send(t);return e?c.ToUtf8String(e).split(","):[]}async indexOf(t){tn(t,"item");const e=new Ce;e.providerID=this.service.id,e.item=t;const r=await this.service.client.send(e);return r?c.ToUtf8String(r):null}async hasItem(t){return!!(await this.indexOf(t))}async getItem(t,e,r,i){nn(t,"string","key"),e&&(Ys(e,"algorithm"),nn(r,"boolean","extractable"),sn(i,"usages"));const s=new xe;s.providerID=this.service.id,s.key=t,e&&(s.algorithm=Qs(e),s.extractable=r,s.keyUsages=i);const n=await this.service.client.send(s);let o;if(!n||!n.byteLength)throw new Error("Cannot get CryptoKey from key storage by index");return o=await Bt.importProto(n),o}async setItem(t){tn(t,"value");const e=new ke;e.providerID=this.service.id,e.item=t;const r=await this.service.client.send(e);return c.ToUtf8String(r)}async removeItem(t){nn(t,"string","key");const e=new Ue;e.providerID=this.service.id,e.key=t,await this.service.client.send(e)}async clear(){const t=new Ie;t.providerID=this.service.id,await this.service.client.send(t)}}class hn{constructor(t){this.service=t}async encrypt(t,e,r){return this.encryptData(t,e,r,"encrypt")}async decrypt(t,e,r){return this.encryptData(t,e,r,"decrypt")}async deriveBits(t,e,r){Ys(t,"algorithm"),tn(e,"baseKey"),nn(r,"number","length");const i=Qs(t);tn(i.public,"algorithm.public"),i.public=await i.public.exportProto();const s=new ar;return s.providerID=this.service.id,s.algorithm=i,s.key=e,s.length=r,await this.service.client.send(s)}async deriveKey(t,e,r,i,s){Ys(t,"algorithm"),tn(e,"baseKey"),Ys(r,"algorithm"),nn(i,"boolean","extractable"),sn(s,"keyUsages");const n=Qs(t);tn(n.public,"algorithm.public"),n.public=await n.public.exportProto();const o=Qs(r),a=new cr;a.providerID=this.service.id,a.algorithm=n,a.derivedKeyType.fromAlgorithm(o),a.key=e,a.extractable=i,a.usage=s;const c=await this.service.client.send(a);return await Bt.importProto(c)}async digest(t,e){return R().crypto.subtle.digest(t,e)}async generateKey(t,e,r){Ys(t,"algorithm"),nn(e,"boolean","extractable"),sn(r,"keyUsages");const i=Qs(t),s=new rr;s.providerID=this.service.id,s.algorithm=i,s.extractable=e,s.usage=r;const n=await this.service.client.send(s);try{return await Et.importProto(n)}catch(o){return await Bt.importProto(n)}}async exportKey(t,e){nn(t,"string","format"),tn(e,"key");const r=new fr;r.providerID=this.service.id,r.format=t,r.key=e;const i=await this.service.client.send(r);return"jwk"===t?JSON.parse(c.ToBinary(i)):i}async importKey(t,e,r,i,s){nn(t,"string","format"),Ys(r,"algorithm"),nn(i,"boolean","extractable"),sn(s,"keyUsages");const n=Qs(r);let o;"jwk"===t?o=c.FromUtf8String(JSON.stringify(e)):(rn(e,"keyData"),o=a.toArrayBuffer(e));const h=new lr;h.providerID=this.service.id,h.algorithm=n,h.keyData=o,h.format=t,h.extractable=i,h.keyUsages=s;const u=await this.service.client.send(h);return await Bt.importProto(u)}async sign(t,e,r){Ys(t,"algorithm"),tn(e,"key"),rn(r,"data");const i=Qs(t),s=a.toArrayBuffer(r),n=new ir;return n.providerID=this.service.id,n.algorithm=i,n.key=e,n.data=s,await this.service.client.send(n)}async verify(t,e,r,i){Ys(t,"algorithm"),tn(e,"key"),rn(r,"signature"),rn(i,"data");const s=Qs(t),n=a.toArrayBuffer(r),o=a.toArrayBuffer(i),c=new sr;c.providerID=this.service.id,c.algorithm=s,c.key=e,c.data=o,c.signature=n;const h=await this.service.client.send(c);return!!new Uint8Array(h)[0]}async wrapKey(t,e,r,i){nn(t,"string","format"),tn(e,"key"),tn(r,"wrappingKey"),Ys(i,"wrapAlgorithm");const s=Qs(i),n=new ur;return n.providerID=this.service.id,n.wrapAlgorithm=s,n.key=e,n.wrappingKey=r,n.format=t,await this.service.client.send(n)}async unwrapKey(t,e,r,i,s,n,o){nn(t,"string","format"),rn(e,"wrappedKey"),tn(r,"unwrappingKey"),Ys(i,"unwrapAlgorithm"),Ys(s,"unwrappedKeyAlgorithm"),nn(n,"boolean","extractable"),sn(o,"keyUsages");const c=Qs(i),h=Qs(s),u=a.toArrayBuffer(e),f=new hr;f.providerID=this.service.id,f.format=t,f.unwrapAlgorithm=c,f.unwrappedKeyAlgorithm=h,f.unwrappingKey=r,f.wrappedKey=u,f.extractable=n,f.keyUsage=o;const l=await this.service.client.send(f);return await Bt.importProto(l)}async encryptData(t,e,r,i){Ys(t,"algorithm"),tn(e,"key"),rn(r,"data");const s=Qs(t),n=a.toArrayBuffer(r);let o;o="encrypt"===i?nr:or;const c=new o;return c.providerID=this.service.id,c.algorithm=s,c.key=e,c.data=n,await this.service.client.send(c)}}class un{constructor(t,e){this.client=t,this.id=e,this.subtle=new hn(this),this.keyStorage=new cn(this),this.certStorage=new an(this)}getRandomValues(t){return R().crypto.getRandomValues(t)}async login(){const t=new $t;return t.providerID=this.id,this.client.send(t)}async logout(){const t=new Pt;return t.providerID=this.id,this.client.send(t)}async reset(){const t=new Vt;return t.providerID=this.id,this.client.send(t)}async isLoggedIn(){const t=new Jt;t.providerID=this.id;const e=await this.client.send(t);return!!new Uint8Array(e)[0]}}class fn extends g{constructor(t){super(),this.client=new Nr(t.storage),this.cardReader=new dr(this.client)}get state(){return this.client.state}connect(t=fn.FORTIFY,e){return this.removeAllListeners(),this.client.connect(t,e).on("error",t=>{this.emit("error",t.error)}).on("event",t=>{(async()=>{switch(t.action){case We.ACTION:{const e=await We.importProto(await t.exportProto());this.emit("token",e)}case He.ACTION:{const e=await He.importProto(await t.exportProto());this.emit("auth",e)}}})()}).on("listening",()=>{this.emit("listening",t)}).on("close",t=>{this.emit("close",t.remoteAddress)}),this}close(){this.client.close()}on(t,e){return console.log("SocketProvider:on",t),super.on(t,e)}once(t,e){return super.once(t,e)}async info(){const t=new Ve,e=await this.client.send(t);return await Je.importProto(e)}async challenge(){return this.client.challenge()}async isLoggedIn(){return this.client.isLoggedIn()}async login(){return this.client.login()}async getCrypto(t){const e=new Me;return e.cryptoID=t,await this.client.send(e),new un(this.client,t)}}fn.FORTIFY="127.0.0.1:31337";class ln{}function dn(t,e){return t(e={exports:{}},e.exports),e.exports}var yn=dn((function(t){!function(){function e(t){return Array.prototype.slice.call(t)}function r(t){return new Promise((function(e,r){t.onsuccess=function(){e(t.result)},t.onerror=function(){r(t.error)}}))}function i(t,e,i){var s,n=new Promise((function(n,o){r(s=t[e].apply(t,i)).then(n,o)}));return n.request=s,n}function s(t,e,r){var s=i(t,e,r);return s.then((function(t){if(t)return new u(t,s.request)}))}function n(t,e,r){r.forEach((function(r){Object.defineProperty(t.prototype,r,{get:function(){return this[e][r]},set:function(t){this[e][r]=t}})}))}function o(t,e,r,s){s.forEach((function(s){s in r.prototype&&(t.prototype[s]=function(){return i(this[e],s,arguments)})}))}function a(t,e,r,i){i.forEach((function(i){i in r.prototype&&(t.prototype[i]=function(){return this[e][i].apply(this[e],arguments)})}))}function c(t,e,r,i){i.forEach((function(i){i in r.prototype&&(t.prototype[i]=function(){return s(this[e],i,arguments)})}))}function h(t){this._index=t}function u(t,e){this._cursor=t,this._request=e}function f(t){this._store=t}function l(t){this._tx=t,this.complete=new Promise((function(e,r){t.oncomplete=function(){e()},t.onerror=function(){r(t.error)},t.onabort=function(){r(t.error)}}))}function d(t,e,r){this._db=t,this.oldVersion=e,this.transaction=new l(r)}function y(t){this._db=t}n(h,"_index",["name","keyPath","multiEntry","unique"]),o(h,"_index",IDBIndex,["get","getKey","getAll","getAllKeys","count"]),c(h,"_index",IDBIndex,["openCursor","openKeyCursor"]),n(u,"_cursor",["direction","key","primaryKey","value"]),o(u,"_cursor",IDBCursor,["update","delete"]),["advance","continue","continuePrimaryKey"].forEach((function(t){t in IDBCursor.prototype&&(u.prototype[t]=function(){var e=this,i=arguments;return Promise.resolve().then((function(){return e._cursor[t].apply(e._cursor,i),r(e._request).then((function(t){if(t)return new u(t,e._request)}))}))})})),f.prototype.createIndex=function(){return new h(this._store.createIndex.apply(this._store,arguments))},f.prototype.index=function(){return new h(this._store.index.apply(this._store,arguments))},n(f,"_store",["name","keyPath","indexNames","autoIncrement"]),o(f,"_store",IDBObjectStore,["put","add","delete","clear","get","getAll","getKey","getAllKeys","count"]),c(f,"_store",IDBObjectStore,["openCursor","openKeyCursor"]),a(f,"_store",IDBObjectStore,["deleteIndex"]),l.prototype.objectStore=function(){return new f(this._tx.objectStore.apply(this._tx,arguments))},n(l,"_tx",["objectStoreNames","mode"]),a(l,"_tx",IDBTransaction,["abort"]),d.prototype.createObjectStore=function(){return new f(this._db.createObjectStore.apply(this._db,arguments))},n(d,"_db",["name","version","objectStoreNames"]),a(d,"_db",IDBDatabase,["deleteObjectStore","close"]),y.prototype.transaction=function(){return new l(this._db.transaction.apply(this._db,arguments))},n(y,"_db",["name","version","objectStoreNames"]),a(y,"_db",IDBDatabase,["close"]),["openCursor","openKeyCursor"].forEach((function(t){[f,h].forEach((function(r){t in r.prototype&&(r.prototype[t.replace("open","iterate")]=function(){var r=e(arguments),i=r[r.length-1],s=this._store||this._index,n=s[t].apply(s,r.slice(0,-1));n.onsuccess=function(){i(n.result)}})}))})),[h,f].forEach((function(t){t.prototype.getAll||(t.prototype.getAll=function(t,e){var r=this,i=[];return new Promise((function(s){r.iterateCursor(t,(function(t){t?(i.push(t.value),void 0===e||i.length!=e?t.continue():s(i)):s(i)}))}))})})),t.exports={open:function(t,e,r){var s=i(indexedDB,"open",[t,e]),n=s.request;return n&&(n.onupgradeneeded=function(t){r&&r(new d(n.result,t.oldVersion,n.transaction))}),s.then((function(t){return new y(t)}))},delete:function(t){return i(indexedDB,"deleteDatabase",[t])}},t.exports.default=t.exports}()})),wn=dn((function(t){t.exports="undefined"!=typeof indexedDB?yn:{open:function(){return Promise.reject("IDB requires a browser environment")},delete:function(){return Promise.reject("IDB requires a browser environment")}}}));class pn extends ln{constructor(t){super(),this.db=t}static async create(){const t=await wn.open(this.STORAGE_NAME,2,t=>{1===t.oldVersion&&(t.deleteObjectStore(this.SESSION_STORAGE),t.deleteObjectStore(this.IDENTITY_STORAGE),t.deleteObjectStore(this.REMOTE_STORAGE)),t.createObjectStore(this.SESSION_STORAGE),t.createObjectStore(this.IDENTITY_STORAGE),t.createObjectStore(this.REMOTE_STORAGE)});return new pn(t)}async loadWrapKey(){const t=await this.db.transaction(pn.IDENTITY_STORAGE).objectStore(pn.IDENTITY_STORAGE).get(pn.WRAP_KEY);return t?(Er.iv=t.iv,t.key instanceof ArrayBuffer?{key:await R().crypto.subtle.importKey("raw",t.key,{name:Er.name,length:256},!0,["encrypt","decrypt","wrapKey","unwrapKey"]),iv:t.iv}:{key:t.key,iv:t.iv}):null}async saveWrapKey(t){let e;e=br()||Ar()?{key:await R().crypto.subtle.exportKey("raw",t.key),iv:t.iv}:{...t},await this.db.transaction(pn.IDENTITY_STORAGE,"readwrite").objectStore(pn.IDENTITY_STORAGE).put(e,pn.WRAP_KEY)}async loadIdentity(){const t=await this.db.transaction(pn.IDENTITY_STORAGE).objectStore(pn.IDENTITY_STORAGE).get(pn.IDENTITY);let e=null;if(t){if(mr()||br()||Ar()){const e=await this.loadWrapKey();if(!(e&&e.key.usages.some(t=>"encrypt"===t)&&t.exchangeKey.privateKey instanceof ArrayBuffer))return null;t.exchangeKey.privateKey=await R().crypto.subtle.unwrapKey("jwk",t.exchangeKey.privateKey,e.key,Er,Sr,!1,["deriveKey","deriveBits"]),t.signingKey.privateKey=await R().crypto.subtle.unwrapKey("jwk",t.signingKey.privateKey,e.key,Er,Br,!1,["sign"]),t.exchangeKey.publicKey=await R().crypto.subtle.unwrapKey("jwk",t.exchangeKey.publicKey,e.key,Er,Sr,!0,[]),t.signingKey.publicKey=await R().crypto.subtle.unwrapKey("jwk",t.signingKey.publicKey,e.key,Er,Br,!0,["verify"])}e=await $.fromJSON(t)}return e}async saveIdentity(t){let e;if(mr()||br()||Ar()){e={key:await R().crypto.subtle.generateKey({name:Er.name,length:256},br()||Ar(),["wrapKey","unwrapKey","encrypt","decrypt"]),iv:R().crypto.getRandomValues(new Uint8Array(Er.iv)).buffer},await this.saveWrapKey(e);const r=await R().crypto.subtle.generateKey(t.exchangeKey.privateKey.algorithm,!0,["deriveKey","deriveBits"]);t.exchangeKey.privateKey=r.privateKey,await kr(t.exchangeKey.publicKey,r.publicKey);const i=await R().crypto.subtle.generateKey(t.signingKey.privateKey.algorithm,!0,["sign","verify"]);t.signingKey.privateKey=i.privateKey,await kr(t.signingKey.publicKey,i.publicKey)}const r=await t.toJSON();e&&(r.exchangeKey.privateKey=await R().crypto.subtle.wrapKey("jwk",t.exchangeKey.privateKey,e.key,Er),r.signingKey.privateKey=await R().crypto.subtle.wrapKey("jwk",t.signingKey.privateKey,e.key,Er),r.exchangeKey.publicKey=await R().crypto.subtle.wrapKey("jwk",t.exchangeKey.publicKey.key,e.key,Er),r.signingKey.publicKey=await R().crypto.subtle.wrapKey("jwk",t.signingKey.publicKey.key,e.key,Er)),await this.db.transaction(pn.IDENTITY_STORAGE,"readwrite").objectStore(pn.IDENTITY_STORAGE).put(r,pn.IDENTITY)}async loadRemoteIdentity(t){const e=await this.db.transaction(pn.REMOTE_STORAGE).objectStore(pn.REMOTE_STORAGE).get(t);let r=null;if(e){const t=await this.loadWrapKey();t&&(e.exchangeKey=await R().crypto.subtle.unwrapKey("jwk",e.exchangeKey,t.key,Er,Sr,!0,[]),e.signingKey=await R().crypto.subtle.unwrapKey("jwk",e.signingKey,t.key,Er,Br,!0,["verify"])),r=await P.fromJSON(e)}return r}async saveRemoteIdentity(t,e){const r=await e.toJSON(),i=await this.loadWrapKey();i&&(r.exchangeKey=await R().crypto.subtle.wrapKey("jwk",r.exchangeKey,i.key,Er),r.signingKey=await R().crypto.subtle.wrapKey("jwk",r.signingKey,i.key,Er)),await this.db.transaction(pn.REMOTE_STORAGE,"readwrite").objectStore(pn.REMOTE_STORAGE).put(r,t)}async loadSession(t){const e=await this.db.transaction(pn.SESSION_STORAGE).objectStore(pn.SESSION_STORAGE).get(t);let r=null;if(e){const i=await this.loadIdentity();if(!i)throw new Error("Identity is empty");const s=await this.loadRemoteIdentity(t);if(!s)throw new Error("Remote identity is not found");r=await rt.fromJSON(i,s,e)}return r}async saveSession(t,e){const r=await e.toJSON();await this.db.transaction(pn.SESSION_STORAGE,"readwrite").objectStore(pn.SESSION_STORAGE).put(r,t)}}return pn.STORAGE_NAME="webcrypto-remote",pn.IDENTITY_STORAGE="identity",pn.SESSION_STORAGE="sessions",pn.REMOTE_STORAGE="remoteIdentity",pn.WRAP_KEY="wkey",pn.IDENTITY="identity",t.BrowserStorage=pn,t.CertificateStorage=an,t.CryptoServerError=yr,t.KeyStorage=cn,t.MemoryStorage=class extends ln{constructor(){super(...arguments),this.remoteIdentities={},this.sessions={}}async loadIdentity(){return this.identity||null}async saveIdentity(t){this.identity=t}async loadRemoteIdentity(t){return this.remoteIdentities[t]||null}async saveRemoteIdentity(t,e){this.remoteIdentities[t]=e}async loadSession(t){return this.sessions[t]||null}async saveSession(t,e){this.sessions[t]=e}},t.RatchetStorage=ln,t.SocketCrypto=un,t.SocketProvider=fn,t.getEngine=R,t.setEngine=function(t,e){O={crypto:e,name:t}},Object.defineProperty(t,"__esModule",{value:!0}),t}({},protobuf,fetch.bind(self),WebSocket);self.WebcryptoSocket=t;