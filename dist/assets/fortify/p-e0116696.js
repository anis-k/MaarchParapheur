import{af as e,ag as t,ah as s,ai as r,aj as i,ak as a,al as n,am as o,an as c,ao as h,ap as u,aq as l,ar as m,as as w,at as f,au as d,av as y,aw as p,ax as b,ay as g,az as A,aA as v,aB as S,aC as k,aD as C,aE as P,aF as E,aG as I,P as N,aH as x,aI as B,aJ as U,aK as H,aL as j,aM as D,aN as O,aO as K,aP as R,aQ as V,aR as M,aS as L,aT as T,f as q,m as J,t as F,j as _,Q as W,a2 as Q,C as G,J as z,L as $,l as X}from"./p-4b404e74.js";import{i as Y}from"./p-7e1544ef.js";
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */
Uint8Array.prototype.slice||Object.defineProperty(Uint8Array.prototype,"slice",{value(e,t){return new Uint8Array(Array.prototype.slice.call(this,e,t))}});var Z=/iPhone/i,ee=/iPod/i,te=/iPad/i,se=/\biOS-universal(?:.+)Mac\b/i,re=/\bAndroid(?:.+)Mobile\b/i,ie=/Android/i,ae=/(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,ne=/Silk/i,oe=/Windows Phone/i,ce=/\bWindows(?:.+)ARM\b/i,he=/BlackBerry/i,ue=/BB10/i,le=/Opera Mini/i,me=/\b(CriOS|Chrome)(?:.+)Mobile/i,we=/Mobile(?:.+)Firefox\b/i,fe=function(e){return void 0!==e&&"MacIntel"===e.platform&&"number"==typeof e.maxTouchPoints&&e.maxTouchPoints>1&&"undefined"==typeof MSStream};class de{constructor(t={}){this.algorithmId=e(t,"algorithmId",de.defaultValues("algorithmId")),"algorithmParams"in t&&(this.algorithmParams=e(t,"algorithmParams",de.defaultValues("algorithmParams"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"algorithmId":return"";case"algorithmParams":return new t;default:throw new Error("Invalid member name for AlgorithmIdentifier class: "+e)}}static compareWithDefault(e,s){switch(e){case"algorithmId":return""===s;case"algorithmParams":return s instanceof t;default:throw new Error("Invalid member name for AlgorithmIdentifier class: "+e)}}static schema(i={}){const a=e(i,"names",{});return new s({name:a.blockName||"",optional:a.optional||!1,value:[new r({name:a.algorithmIdentifier||""}),new t({name:a.algorithmParams||"",optional:!0})]})}fromSchema(e){i(e,["algorithm","params"]);const t=a(e,e,de.schema({names:{algorithmIdentifier:"algorithm",algorithmParams:"params"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AlgorithmIdentifier");this.algorithmId=t.result.algorithm.valueBlock.toString(),"params"in t.result&&(this.algorithmParams=t.result.params)}toSchema(){const e=[];return e.push(new r({value:this.algorithmId})),"algorithmParams"in this&&this.algorithmParams instanceof t==0&&e.push(this.algorithmParams),new s({value:e})}toJSON(){const e={algorithmId:this.algorithmId};return"algorithmParams"in this&&this.algorithmParams instanceof t==0&&(e.algorithmParams=this.algorithmParams.toJSON()),e}isEqual(e){return e instanceof de!=0&&this.algorithmId===e.algorithmId&&("algorithmParams"in this?"algorithmParams"in e&&JSON.stringify(this.algorithmParams)===JSON.stringify(e.algorithmParams):!("algorithmParams"in e))}}class ye{constructor(t={}){this.x=e(t,"x",ye.defaultValues("x")),this.y=e(t,"y",ye.defaultValues("y")),this.namedCurve=e(t,"namedCurve",ye.defaultValues("namedCurve")),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"x":case"y":return new ArrayBuffer(0);case"namedCurve":return"";default:throw new Error("Invalid member name for ECCPublicKey class: "+e)}}static compareWithDefault(e,t){switch(e){case"x":case"y":return n(t,ye.defaultValues(e));case"namedCurve":return""===t;default:throw new Error("Invalid member name for ECCPublicKey class: "+e)}}static schema(e={}){return new o}fromSchema(e){if(e instanceof ArrayBuffer==0)throw new Error("Object's schema was not verified against input data for ECPublicKey");if(4!==new Uint8Array(e)[0])throw new Error("Object's schema was not verified against input data for ECPublicKey");let t;switch(this.namedCurve){case"1.2.840.10045.3.1.7":t=32;break;case"1.3.132.0.34":t=48;break;case"1.3.132.0.35":t=66;break;default:throw new Error("Incorrect curve OID: "+this.namedCurve)}if(e.byteLength!==2*t+1)throw new Error("Object's schema was not verified against input data for ECPublicKey");this.x=e.slice(1,t+1),this.y=e.slice(1+t,2*t+1)}toSchema(){return new o({data:c(new Uint8Array([4]).buffer,this.x,this.y)})}toJSON(){let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}return{crv:e,x:h(u(this.x),!0,!0,!1),y:h(u(this.y),!0,!0,!1)}}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("x"in e))throw new Error('Absent mandatory parameter "x"');{const s=l(m(e.x,!0));if(s.byteLength<t){this.x=new ArrayBuffer(t);const e=new Uint8Array(this.x),r=new Uint8Array(s);e.set(r,1)}else this.x=s.slice(0,t)}if(!("y"in e))throw new Error('Absent mandatory parameter "y"');{const s=l(m(e.y,!0));if(s.byteLength<t){this.y=new ArrayBuffer(t);const e=new Uint8Array(this.y),r=new Uint8Array(s);e.set(r,1)}else this.y=s.slice(0,t)}}}class pe{constructor(t={}){this.modulus=e(t,"modulus",pe.defaultValues("modulus")),this.publicExponent=e(t,"publicExponent",pe.defaultValues("publicExponent")),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"modulus":case"publicExponent":return new w;default:throw new Error("Invalid member name for RSAPublicKey class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new w({name:r.modulus||""}),new w({name:r.publicExponent||""})]})}fromSchema(e){i(e,["modulus","publicExponent"]);const t=a(e,e,pe.schema({names:{modulus:"modulus",publicExponent:"publicExponent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPublicKey");this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent}toSchema(){return new s({value:[this.modulus.convertToDER(),this.publicExponent]})}toJSON(){return{n:h(u(this.modulus.valueBlock.valueHex),!0,!0,!0),e:h(u(this.publicExponent.valueBlock.valueHex),!0,!0,!0)}}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');{const t=l(m(e.n,!0));this.modulus=new w({valueHex:t.slice(0,Math.pow(2,f(t.byteLength)))})}if(!("e"in e))throw new Error('Absent mandatory parameter "e"');this.publicExponent=new w({valueHex:l(m(e.e,!0)).slice(0,3)})}}class be{constructor(t={}){this.algorithm=e(t,"algorithm",be.defaultValues("algorithm")),this.subjectPublicKey=e(t,"subjectPublicKey",be.defaultValues("subjectPublicKey")),"parsedKey"in t&&(this.parsedKey=e(t,"parsedKey",be.defaultValues("parsedKey"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"algorithm":return new de;case"subjectPublicKey":return new d;default:throw new Error("Invalid member name for PublicKeyInfo class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[de.schema(r.algorithm||{}),new d({name:r.subjectPublicKey||""})]})}fromSchema(e){i(e,["algorithm","subjectPublicKey"]);const t=a(e,e,be.schema({names:{algorithm:{names:{blockName:"algorithm"}},subjectPublicKey:"subjectPublicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PublicKeyInfo");switch(this.algorithm=new de({schema:t.result.algorithm}),this.subjectPublicKey=t.result.subjectPublicKey,this.algorithm.algorithmId){case"1.2.840.10045.2.1":if("algorithmParams"in this.algorithm&&this.algorithm.algorithmParams.constructor.blockName()===r.blockName())try{this.parsedKey=new ye({namedCurve:this.algorithm.algorithmParams.valueBlock.toString(),schema:this.subjectPublicKey.valueBlock.valueHex})}catch(s){}break;case"1.2.840.113549.1.1.1":{const e=y(this.subjectPublicKey.valueBlock.valueHex);if(-1!==e.offset)try{this.parsedKey=new pe({schema:e.result})}catch(s){}}}}toSchema(){return new s({value:[this.algorithm.toSchema(),this.subjectPublicKey]})}toJSON(){if("parsedKey"in this==0)return{algorithm:this.algorithm.toJSON(),subjectPublicKey:this.subjectPublicKey.toJSON()};const e={};switch(this.algorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const s of Object.keys(t))e[s]=t[s];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new ye({json:e}),this.algorithm=new de({algorithmId:"1.2.840.10045.2.1",algorithmParams:new r({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new pe({json:e}),this.algorithm=new de({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new p});break;default:throw new Error('Invalid value for "kty" parameter: '+e.kty)}this.subjectPublicKey=new d({valueHex:this.parsedKey.toSchema().toBER(!1)})}}importKey(e){let t=Promise.resolve();const s=this;if(void 0===e)return Promise.reject("Need to provide publicKey input parameter");const r=je();return void 0===r?Promise.reject("Unable to create WebCrypto object"):(t=t.then(()=>r.exportKey("spki",e)),t=t.then(e=>{const t=y(e);try{s.fromSchema(t.result)}catch(r){return Promise.reject("Error during initializing object from schema")}},e=>Promise.reject("Error during exporting public key: "+e)),t)}}class ge{constructor(t={}){this.type=e(t,"type",ge.defaultValues("type")),this.values=e(t,"values",ge.defaultValues("values")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"type":return"";case"values":return[];default:throw new Error("Invalid member name for Attribute class: "+e)}}static compareWithDefault(e,t){switch(e){case"type":return""===t;case"values":return 0===t.length;default:throw new Error("Invalid member name for Attribute class: "+e)}}static schema(i={}){const a=e(i,"names",{});return new s({name:a.blockName||"",value:[new r({name:a.type||""}),new b({name:a.setName||"",value:[new g({name:a.values||"",value:new t})]})]})}fromSchema(e){i(e,["type","values"]);const t=a(e,e,ge.schema({names:{type:"type",values:"values"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Attribute");this.type=t.result.type.valueBlock.toString(),this.values=t.result.values}toSchema(){return new s({value:[new r({value:this.type}),new b({value:this.values})]})}toJSON(){return{type:this.type,values:Array.from(this.values,e=>e.toJSON())}}}class Ae{constructor(t={}){this.version=e(t,"version",Ae.defaultValues("version")),this.privateKey=e(t,"privateKey",Ae.defaultValues("privateKey")),"namedCurve"in t&&(this.namedCurve=e(t,"namedCurve",Ae.defaultValues("namedCurve"))),"publicKey"in t&&(this.publicKey=e(t,"publicKey",Ae.defaultValues("publicKey"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"version":return 1;case"privateKey":return new A;case"namedCurve":return"";case"publicKey":return new ye;default:throw new Error("Invalid member name for ECCPrivateKey class: "+e)}}static compareWithDefault(e,t){switch(e){case"version":return t===Ae.defaultValues(e);case"privateKey":return t.isEqual(Ae.defaultValues(e));case"namedCurve":return""===t;case"publicKey":return ye.compareWithDefault("namedCurve",t.namedCurve)&&ye.compareWithDefault("x",t.x)&&ye.compareWithDefault("y",t.y);default:throw new Error("Invalid member name for ECCPrivateKey class: "+e)}}static schema(t={}){const i=e(t,"names",{});return new s({name:i.blockName||"",value:[new w({name:i.version||""}),new A({name:i.privateKey||""}),new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new r({name:i.namedCurve||""})]}),new v({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new d({name:i.publicKey||""})]})]})}fromSchema(e){i(e,["version","privateKey","namedCurve","publicKey"]);const t=a(e,e,Ae.schema({names:{version:"version",privateKey:"privateKey",namedCurve:"namedCurve",publicKey:"publicKey"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ECPrivateKey");if(this.version=t.result.version.valueBlock.valueDec,this.privateKey=t.result.privateKey,"namedCurve"in t.result&&(this.namedCurve=t.result.namedCurve.valueBlock.toString()),"publicKey"in t.result){const e={schema:t.result.publicKey.valueBlock.valueHex};"namedCurve"in this&&(e.namedCurve=this.namedCurve),this.publicKey=new ye(e)}}toSchema(){const e=[new w({value:this.version}),this.privateKey];return"namedCurve"in this&&e.push(new v({idBlock:{tagClass:3,tagNumber:0},value:[new r({value:this.namedCurve})]})),"publicKey"in this&&e.push(new v({idBlock:{tagClass:3,tagNumber:1},value:[new d({valueHex:this.publicKey.toSchema().toBER(!1)})]})),new s({value:e})}toJSON(){if("namedCurve"in this==0||Ae.compareWithDefault("namedCurve",this.namedCurve))throw new Error('Not enough information for making JSON: absent "namedCurve" value');let e="";switch(this.namedCurve){case"1.2.840.10045.3.1.7":e="P-256";break;case"1.3.132.0.34":e="P-384";break;case"1.3.132.0.35":e="P-521"}const t={crv:e,d:h(u(this.privateKey.valueBlock.valueHex),!0,!0,!1)};if("publicKey"in this){const e=this.publicKey.toJSON();t.x=e.x,t.y=e.y}return t}fromJSON(e){let t=0;if(!("crv"in e))throw new Error('Absent mandatory parameter "crv"');switch(e.crv.toUpperCase()){case"P-256":this.namedCurve="1.2.840.10045.3.1.7",t=32;break;case"P-384":this.namedCurve="1.3.132.0.34",t=48;break;case"P-521":this.namedCurve="1.3.132.0.35",t=66}if(!("d"in e))throw new Error('Absent mandatory parameter "d"');{const s=l(m(e.d,!0));if(s.byteLength<t){const e=new ArrayBuffer(t),r=new Uint8Array(e),i=new Uint8Array(s);r.set(i,1),this.privateKey=new A({valueHex:e})}else this.privateKey=new A({valueHex:s.slice(0,t)})}"x"in e&&"y"in e&&(this.publicKey=new ye({json:e}))}}class ve{constructor(t={}){this.prime=e(t,"prime",ve.defaultValues("prime")),this.exponent=e(t,"exponent",ve.defaultValues("exponent")),this.coefficient=e(t,"coefficient",ve.defaultValues("coefficient")),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"prime":case"exponent":case"coefficient":return new w;default:throw new Error("Invalid member name for OtherPrimeInfo class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new w({name:r.prime||""}),new w({name:r.exponent||""}),new w({name:r.coefficient||""})]})}fromSchema(e){i(e,["prime","exponent","coefficient"]);const t=a(e,e,ve.schema({names:{prime:"prime",exponent:"exponent",coefficient:"coefficient"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for OtherPrimeInfo");this.prime=t.result.prime.convertFromDER(),this.exponent=t.result.exponent.convertFromDER(),this.coefficient=t.result.coefficient.convertFromDER()}toSchema(){return new s({value:[this.prime.convertToDER(),this.exponent.convertToDER(),this.coefficient.convertToDER()]})}toJSON(){return{r:h(u(this.prime.valueBlock.valueHex),!0,!0),d:h(u(this.exponent.valueBlock.valueHex),!0,!0),t:h(u(this.coefficient.valueBlock.valueHex),!0,!0)}}fromJSON(e){if(!("r"in e))throw new Error('Absent mandatory parameter "r"');if(this.prime=new w({valueHex:l(m(e.r,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.exponent=new w({valueHex:l(m(e.d,!0))}),!("t"in e))throw new Error('Absent mandatory parameter "t"');this.coefficient=new w({valueHex:l(m(e.t,!0))})}}class Se{constructor(t={}){this.version=e(t,"version",Se.defaultValues("version")),this.modulus=e(t,"modulus",Se.defaultValues("modulus")),this.publicExponent=e(t,"publicExponent",Se.defaultValues("publicExponent")),this.privateExponent=e(t,"privateExponent",Se.defaultValues("privateExponent")),this.prime1=e(t,"prime1",Se.defaultValues("prime1")),this.prime2=e(t,"prime2",Se.defaultValues("prime2")),this.exponent1=e(t,"exponent1",Se.defaultValues("exponent1")),this.exponent2=e(t,"exponent2",Se.defaultValues("exponent2")),this.coefficient=e(t,"coefficient",Se.defaultValues("coefficient")),"otherPrimeInfos"in t&&(this.otherPrimeInfos=e(t,"otherPrimeInfos",Se.defaultValues("otherPrimeInfos"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"version":return 0;case"modulus":case"publicExponent":case"privateExponent":case"prime1":case"prime2":case"exponent1":case"exponent2":case"coefficient":return new w;case"otherPrimeInfos":return[];default:throw new Error("Invalid member name for RSAPrivateKey class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new w({name:r.version||""}),new w({name:r.modulus||""}),new w({name:r.publicExponent||""}),new w({name:r.privateExponent||""}),new w({name:r.prime1||""}),new w({name:r.prime2||""}),new w({name:r.exponent1||""}),new w({name:r.exponent2||""}),new w({name:r.coefficient||""}),new s({optional:!0,value:[new g({name:r.otherPrimeInfosName||"",value:ve.schema(r.otherPrimeInfo||{})})]})]})}fromSchema(e){i(e,["version","modulus","publicExponent","privateExponent","prime1","prime2","exponent1","exponent2","coefficient","otherPrimeInfos"]);const t=a(e,e,Se.schema({names:{version:"version",modulus:"modulus",publicExponent:"publicExponent",privateExponent:"privateExponent",prime1:"prime1",prime2:"prime2",exponent1:"exponent1",exponent2:"exponent2",coefficient:"coefficient",otherPrimeInfo:{names:{blockName:"otherPrimeInfos"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSAPrivateKey");this.version=t.result.version.valueBlock.valueDec,this.modulus=t.result.modulus.convertFromDER(256),this.publicExponent=t.result.publicExponent,this.privateExponent=t.result.privateExponent.convertFromDER(256),this.prime1=t.result.prime1.convertFromDER(128),this.prime2=t.result.prime2.convertFromDER(128),this.exponent1=t.result.exponent1.convertFromDER(128),this.exponent2=t.result.exponent2.convertFromDER(128),this.coefficient=t.result.coefficient.convertFromDER(128),"otherPrimeInfos"in t.result&&(this.otherPrimeInfos=Array.from(t.result.otherPrimeInfos,e=>new ve({schema:e})))}toSchema(){const e=[];return e.push(new w({value:this.version})),e.push(this.modulus.convertToDER()),e.push(this.publicExponent),e.push(this.privateExponent.convertToDER()),e.push(this.prime1.convertToDER()),e.push(this.prime2.convertToDER()),e.push(this.exponent1.convertToDER()),e.push(this.exponent2.convertToDER()),e.push(this.coefficient.convertToDER()),"otherPrimeInfos"in this&&e.push(new s({value:Array.from(this.otherPrimeInfos,e=>e.toSchema())})),new s({value:e})}toJSON(){const e={n:h(u(this.modulus.valueBlock.valueHex),!0,!0,!0),e:h(u(this.publicExponent.valueBlock.valueHex),!0,!0,!0),d:h(u(this.privateExponent.valueBlock.valueHex),!0,!0,!0),p:h(u(this.prime1.valueBlock.valueHex),!0,!0,!0),q:h(u(this.prime2.valueBlock.valueHex),!0,!0,!0),dp:h(u(this.exponent1.valueBlock.valueHex),!0,!0,!0),dq:h(u(this.exponent2.valueBlock.valueHex),!0,!0,!0),qi:h(u(this.coefficient.valueBlock.valueHex),!0,!0,!0)};return"otherPrimeInfos"in this&&(e.oth=Array.from(this.otherPrimeInfos,e=>e.toJSON())),e}fromJSON(e){if(!("n"in e))throw new Error('Absent mandatory parameter "n"');if(this.modulus=new w({valueHex:l(m(e.n,!0,!0))}),!("e"in e))throw new Error('Absent mandatory parameter "e"');if(this.publicExponent=new w({valueHex:l(m(e.e,!0,!0))}),!("d"in e))throw new Error('Absent mandatory parameter "d"');if(this.privateExponent=new w({valueHex:l(m(e.d,!0,!0))}),!("p"in e))throw new Error('Absent mandatory parameter "p"');if(this.prime1=new w({valueHex:l(m(e.p,!0,!0))}),!("q"in e))throw new Error('Absent mandatory parameter "q"');if(this.prime2=new w({valueHex:l(m(e.q,!0,!0))}),!("dp"in e))throw new Error('Absent mandatory parameter "dp"');if(this.exponent1=new w({valueHex:l(m(e.dp,!0,!0))}),!("dq"in e))throw new Error('Absent mandatory parameter "dq"');if(this.exponent2=new w({valueHex:l(m(e.dq,!0,!0))}),!("qi"in e))throw new Error('Absent mandatory parameter "qi"');this.coefficient=new w({valueHex:l(m(e.qi,!0,!0))}),"oth"in e&&(this.otherPrimeInfos=Array.from(e.oth,e=>new ve({json:e})))}}class ke{constructor(t={}){this.version=e(t,"version",ke.defaultValues("version")),this.privateKeyAlgorithm=e(t,"privateKeyAlgorithm",ke.defaultValues("privateKeyAlgorithm")),this.privateKey=e(t,"privateKey",ke.defaultValues("privateKey")),"attributes"in t&&(this.attributes=e(t,"attributes",ke.defaultValues("attributes"))),"parsedKey"in t&&(this.parsedKey=e(t,"parsedKey",ke.defaultValues("parsedKey"))),"schema"in t&&this.fromSchema(t.schema),"json"in t&&this.fromJSON(t.json)}static defaultValues(e){switch(e){case"version":return 0;case"privateKeyAlgorithm":return new de;case"privateKey":return new A;case"attributes":return[];case"parsedKey":return{};default:throw new Error("Invalid member name for PrivateKeyInfo class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new w({name:r.version||""}),de.schema(r.privateKeyAlgorithm||{}),new A({name:r.privateKey||""}),new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new g({name:r.attributes||"",value:ge.schema()})]})]})}fromSchema(e){i(e,["version","privateKeyAlgorithm","privateKey","attributes"]);const t=a(e,e,ke.schema({names:{version:"version",privateKeyAlgorithm:{names:{blockName:"privateKeyAlgorithm"}},privateKey:"privateKey",attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyInfo");switch(this.version=t.result.version.valueBlock.valueDec,this.privateKeyAlgorithm=new de({schema:t.result.privateKeyAlgorithm}),this.privateKey=t.result.privateKey,"attributes"in t.result&&(this.attributes=Array.from(t.result.attributes,e=>new ge({schema:e}))),this.privateKeyAlgorithm.algorithmId){case"1.2.840.113549.1.1.1":{const e=y(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Se({schema:e.result}))}break;case"1.2.840.10045.2.1":if("algorithmParams"in this.privateKeyAlgorithm&&this.privateKeyAlgorithm.algorithmParams instanceof r){const e=y(this.privateKey.valueBlock.valueHex);-1!==e.offset&&(this.parsedKey=new Ae({namedCurve:this.privateKeyAlgorithm.algorithmParams.valueBlock.toString(),schema:e.result}))}}}toSchema(){const e=[new w({value:this.version}),this.privateKeyAlgorithm.toSchema(),this.privateKey];return"attributes"in this&&e.push(new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new s({value:e})}toJSON(){if("parsedKey"in this==0){const e={version:this.version,privateKeyAlgorithm:this.privateKeyAlgorithm.toJSON(),privateKey:this.privateKey.toJSON()};return"attributes"in this&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}const e={};switch(this.privateKeyAlgorithm.algorithmId){case"1.2.840.10045.2.1":e.kty="EC";break;case"1.2.840.113549.1.1.1":e.kty="RSA"}const t=this.parsedKey.toJSON();for(const s of Object.keys(t))e[s]=t[s];return e}fromJSON(e){if("kty"in e){switch(e.kty.toUpperCase()){case"EC":this.parsedKey=new Ae({json:e}),this.privateKeyAlgorithm=new de({algorithmId:"1.2.840.10045.2.1",algorithmParams:new r({value:this.parsedKey.namedCurve})});break;case"RSA":this.parsedKey=new Se({json:e}),this.privateKeyAlgorithm=new de({algorithmId:"1.2.840.113549.1.1.1",algorithmParams:new p});break;default:throw new Error('Invalid value for "kty" parameter: '+e.kty)}this.privateKey=new A({valueHex:this.parsedKey.toSchema().toBER(!1)})}}}class Ce{constructor(t={}){if(this.contentType=e(t,"contentType",Ce.defaultValues("contentType")),this.contentEncryptionAlgorithm=e(t,"contentEncryptionAlgorithm",Ce.defaultValues("contentEncryptionAlgorithm")),"encryptedContent"in t&&(this.encryptedContent=t.encryptedContent,1===this.encryptedContent.idBlock.tagClass&&4===this.encryptedContent.idBlock.tagNumber&&!1===this.encryptedContent.idBlock.isConstructed)){const e=new A({idBlock:{isConstructed:!0},isConstructed:!0});let t=0,s=this.encryptedContent.valueBlock.valueHex.byteLength;for(;s>0;){const r=new Uint8Array(this.encryptedContent.valueBlock.valueHex,t,t+1024>this.encryptedContent.valueBlock.valueHex.byteLength?this.encryptedContent.valueBlock.valueHex.byteLength-t:1024),i=new ArrayBuffer(r.length),a=new Uint8Array(i);for(let e=0;e<a.length;e++)a[e]=r[e];e.valueBlock.value.push(new A({valueHex:i})),s-=r.length,t+=r.length}this.encryptedContent=e}"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"contentType":return"";case"contentEncryptionAlgorithm":return new de;case"encryptedContent":return new A;default:throw new Error("Invalid member name for EncryptedContentInfo class: "+e)}}static compareWithDefault(e,t){switch(e){case"contentType":return""===t;case"contentEncryptionAlgorithm":return""===t.algorithmId&&"algorithmParams"in t==0;case"encryptedContent":return t.isEqual(Ce.defaultValues(e));default:throw new Error("Invalid member name for EncryptedContentInfo class: "+e)}}static schema(t={}){const i=e(t,"names",{});return new s({name:i.blockName||"",value:[new r({name:i.contentType||""}),de.schema(i.contentEncryptionAlgorithm||{}),new S({value:[new v({name:i.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0},value:[new g({value:new A})]}),new k({name:i.encryptedContent||"",idBlock:{tagClass:3,tagNumber:0}})]})]})}fromSchema(e){i(e,["contentType","contentEncryptionAlgorithm","encryptedContent"]);const t=a(e,e,Ce.schema({names:{contentType:"contentType",contentEncryptionAlgorithm:{names:{blockName:"contentEncryptionAlgorithm"}},encryptedContent:"encryptedContent"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for EncryptedContentInfo");this.contentType=t.result.contentType.valueBlock.toString(),this.contentEncryptionAlgorithm=new de({schema:t.result.contentEncryptionAlgorithm}),"encryptedContent"in t.result&&(this.encryptedContent=t.result.encryptedContent,this.encryptedContent.idBlock.tagClass=1,this.encryptedContent.idBlock.tagNumber=4)}toSchema(){const e={isIndefiniteForm:!1},t=[];if(t.push(new r({value:this.contentType})),t.push(this.contentEncryptionAlgorithm.toSchema()),"encryptedContent"in this){e.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed;const s=this.encryptedContent;s.idBlock.tagClass=3,s.idBlock.tagNumber=0,s.lenBlock.isIndefiniteForm=this.encryptedContent.idBlock.isConstructed,t.push(s)}return new s({lenBlock:e,value:t})}toJSON(){const e={contentType:this.contentType,contentEncryptionAlgorithm:this.contentEncryptionAlgorithm.toJSON()};return"encryptedContent"in this&&(e.encryptedContent=this.encryptedContent.toJSON()),e}}class Pe{constructor(t={}){this.hashAlgorithm=e(t,"hashAlgorithm",Pe.defaultValues("hashAlgorithm")),this.maskGenAlgorithm=e(t,"maskGenAlgorithm",Pe.defaultValues("maskGenAlgorithm")),this.saltLength=e(t,"saltLength",Pe.defaultValues("saltLength")),this.trailerField=e(t,"trailerField",Pe.defaultValues("trailerField")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"hashAlgorithm":return new de({algorithmId:"1.3.14.3.2.26",algorithmParams:new p});case"maskGenAlgorithm":return new de({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:new de({algorithmId:"1.3.14.3.2.26",algorithmParams:new p}).toSchema()});case"saltLength":return 20;case"trailerField":return 1;default:throw new Error("Invalid member name for RSASSAPSSParams class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new v({idBlock:{tagClass:3,tagNumber:0},optional:!0,value:[de.schema(r.hashAlgorithm||{})]}),new v({idBlock:{tagClass:3,tagNumber:1},optional:!0,value:[de.schema(r.maskGenAlgorithm||{})]}),new v({idBlock:{tagClass:3,tagNumber:2},optional:!0,value:[new w({name:r.saltLength||""})]}),new v({idBlock:{tagClass:3,tagNumber:3},optional:!0,value:[new w({name:r.trailerField||""})]})]})}fromSchema(e){i(e,["hashAlgorithm","maskGenAlgorithm","saltLength","trailerField"]);const t=a(e,e,Pe.schema({names:{hashAlgorithm:{names:{blockName:"hashAlgorithm"}},maskGenAlgorithm:{names:{blockName:"maskGenAlgorithm"}},saltLength:"saltLength",trailerField:"trailerField"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RSASSAPSSParams");"hashAlgorithm"in t.result&&(this.hashAlgorithm=new de({schema:t.result.hashAlgorithm})),"maskGenAlgorithm"in t.result&&(this.maskGenAlgorithm=new de({schema:t.result.maskGenAlgorithm})),"saltLength"in t.result&&(this.saltLength=t.result.saltLength.valueBlock.valueDec),"trailerField"in t.result&&(this.trailerField=t.result.trailerField.valueBlock.valueDec)}toSchema(){const e=[];return this.hashAlgorithm.isEqual(Pe.defaultValues("hashAlgorithm"))||e.push(new v({idBlock:{tagClass:3,tagNumber:0},value:[this.hashAlgorithm.toSchema()]})),this.maskGenAlgorithm.isEqual(Pe.defaultValues("maskGenAlgorithm"))||e.push(new v({idBlock:{tagClass:3,tagNumber:1},value:[this.maskGenAlgorithm.toSchema()]})),this.saltLength!==Pe.defaultValues("saltLength")&&e.push(new v({idBlock:{tagClass:3,tagNumber:2},value:[new w({value:this.saltLength})]})),this.trailerField!==Pe.defaultValues("trailerField")&&e.push(new v({idBlock:{tagClass:3,tagNumber:3},value:[new w({value:this.trailerField})]})),new s({value:e})}toJSON(){const e={};return this.hashAlgorithm.isEqual(Pe.defaultValues("hashAlgorithm"))||(e.hashAlgorithm=this.hashAlgorithm.toJSON()),this.maskGenAlgorithm.isEqual(Pe.defaultValues("maskGenAlgorithm"))||(e.maskGenAlgorithm=this.maskGenAlgorithm.toJSON()),this.saltLength!==Pe.defaultValues("saltLength")&&(e.saltLength=this.saltLength),this.trailerField!==Pe.defaultValues("trailerField")&&(e.trailerField=this.trailerField),e}}class Ee{constructor(t={}){this.salt=e(t,"salt",Ee.defaultValues("salt")),this.iterationCount=e(t,"iterationCount",Ee.defaultValues("iterationCount")),"keyLength"in t&&(this.keyLength=e(t,"keyLength",Ee.defaultValues("keyLength"))),"prf"in t&&(this.prf=e(t,"prf",Ee.defaultValues("prf"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"salt":return{};case"iterationCount":return-1;case"keyLength":return 0;case"prf":return new de({algorithmId:"1.3.14.3.2.26",algorithmParams:new p});default:throw new Error("Invalid member name for PBKDF2Params class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new S({value:[new A({name:r.saltPrimitive||""}),de.schema(r.saltConstructed||{})]}),new w({name:r.iterationCount||""}),new w({name:r.keyLength||"",optional:!0}),de.schema(r.prf||{names:{optional:!0}})]})}fromSchema(e){i(e,["salt","iterationCount","keyLength","prf"]);const t=a(e,e,Ee.schema({names:{saltPrimitive:"salt",saltConstructed:{names:{blockName:"salt"}},iterationCount:"iterationCount",keyLength:"keyLength",prf:{names:{blockName:"prf",optional:!0}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBKDF2Params");this.salt=t.result.salt,this.iterationCount=t.result.iterationCount.valueBlock.valueDec,"keyLength"in t.result&&(this.keyLength=t.result.keyLength.valueBlock.valueDec),"prf"in t.result&&(this.prf=new de({schema:t.result.prf}))}toSchema(){const e=[];return e.push(this.salt),e.push(new w({value:this.iterationCount})),"keyLength"in this&&Ee.defaultValues("keyLength")!==this.keyLength&&e.push(new w({value:this.keyLength})),"prf"in this&&!1===Ee.defaultValues("prf").isEqual(this.prf)&&e.push(this.prf.toSchema()),new s({value:e})}toJSON(){const e={salt:this.salt.toJSON(),iterationCount:this.iterationCount};return"keyLength"in this&&Ee.defaultValues("keyLength")!==this.keyLength&&(e.keyLength=this.keyLength),"prf"in this&&!1===Ee.defaultValues("prf").isEqual(this.prf)&&(e.prf=this.prf.toJSON()),e}}class Ie{constructor(t={}){this.keyDerivationFunc=e(t,"keyDerivationFunc",Ie.defaultValues("keyDerivationFunc")),this.encryptionScheme=e(t,"encryptionScheme",Ie.defaultValues("encryptionScheme")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"keyDerivationFunc":case"encryptionScheme":return new de;default:throw new Error("Invalid member name for PBES2Params class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[de.schema(r.keyDerivationFunc||{}),de.schema(r.encryptionScheme||{})]})}fromSchema(e){i(e,["keyDerivationFunc","encryptionScheme"]);const t=a(e,e,Ie.schema({names:{keyDerivationFunc:{names:{blockName:"keyDerivationFunc"}},encryptionScheme:{names:{blockName:"encryptionScheme"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PBES2Params");this.keyDerivationFunc=new de({schema:t.result.keyDerivationFunc}),this.encryptionScheme=new de({schema:t.result.encryptionScheme})}toSchema(){return new s({value:[this.keyDerivationFunc.toSchema(),this.encryptionScheme.toSchema()]})}toJSON(){return{keyDerivationFunc:this.keyDerivationFunc.toJSON(),encryptionScheme:this.encryptionScheme.toJSON()}}}function Ne(e,t,s,r,i,a){let n,o;const c=[];switch(t.toUpperCase()){case"SHA-1":n=20,o=64;break;case"SHA-256":n=32,o=64;break;case"SHA-384":n=48,o=128;break;case"SHA-512":n=64,o=128;break;default:throw new Error("Unsupported hashing algorithm")}const h=new Uint8Array(r),u=new ArrayBuffer(2*r.byteLength+2),l=new Uint8Array(u);for(let N=0;N<h.length;N++)l[2*N]=0,l[2*N+1]=h[N];l[l.length-2]=0,l[l.length-1]=0,r=u.slice(0);const m=new ArrayBuffer(o),w=new Uint8Array(m);for(let N=0;N<m.byteLength;N++)w[N]=3;const f=i.byteLength,d=o*Math.ceil(f/o),y=new ArrayBuffer(d),p=new Uint8Array(y),b=new Uint8Array(i);for(let N=0;N<d;N++)p[N]=b[N%f];const g=r.byteLength,A=o*Math.ceil(g/o),v=new ArrayBuffer(A),S=new Uint8Array(v),k=new Uint8Array(r);for(let N=0;N<A;N++)S[N]=k[N%g];let C=new ArrayBuffer(y.byteLength+v.byteLength),P=new Uint8Array(C);P.set(p),P.set(S,p.length);const E=Math.ceil((s>>3)/n);let I=Promise.resolve(C);for(let N=0;N<=E;N++){I=I.then(e=>{const t=new ArrayBuffer(m.byteLength+e.byteLength),s=new Uint8Array(t);return s.set(w),s.set(P,w.length),t});for(let s=0;s<a;s++)I=I.then(s=>e.digest({name:t},new Uint8Array(s)));I=I.then(e=>{const t=new ArrayBuffer(o),s=new Uint8Array(t);for(let o=0;o<t.byteLength;o++)s[o]=e[o%e.length];const r=Math.ceil(f/o)+Math.ceil(g/o),i=[];let a=0,n=o;for(let c=0;c<r;c++){const e=Array.from(new Uint8Array(C.slice(a,a+n)));a+=o,a+o>C.byteLength&&(n=C.byteLength-a);let r=511;for(let i=t.byteLength-1;i>=0;i--)r>>=8,r+=s[i]+e[i],e[i]=255&r;i.push(...e)}return C=new ArrayBuffer(i.length),P=new Uint8Array(C),P.set(i),c.push(...new Uint8Array(e)),C})}return I=I.then(()=>{const e=new ArrayBuffer(s>>3);return new Uint8Array(e).set(new Uint8Array(c).slice(0,s>>3)),e}),I}class xe{constructor(t={}){this.crypto=e(t,"crypto",{}),this.subtle=e(t,"subtle",{}),this.name=e(t,"name","")}importKey(e,t,s,r,i){let a={};switch(t instanceof Uint8Array&&(t=t.buffer),e.toLowerCase()){case"raw":return this.subtle.importKey("raw",t,s,r,i);case"spki":{const e=y(t);if(-1===e.offset)return Promise.reject("Incorrect keyData");const o=new be;try{o.fromSchema(e.result)}catch(n){return Promise.reject("Incorrect keyData")}switch(s.name.toUpperCase()){case"RSA-PSS":switch(s.hash.name.toUpperCase()){case"SHA-1":a.alg="PS1";break;case"SHA-256":a.alg="PS256";break;case"SHA-384":a.alg="PS384";break;case"SHA-512":a.alg="PS512";break;default:return Promise.reject("Incorrect hash algorithm: "+s.hash.name.toUpperCase())}case"RSASSA-PKCS1-V1_5":{if(i=["verify"],a.kty="RSA",a.ext=r,a.key_ops=i,"1.2.840.113549.1.1.1"!==o.algorithm.algorithmId)return Promise.reject("Incorrect public key algorithm: "+o.algorithm.algorithmId);if("alg"in a==0)switch(s.hash.name.toUpperCase()){case"SHA-1":a.alg="RS1";break;case"SHA-256":a.alg="RS256";break;case"SHA-384":a.alg="RS384";break;case"SHA-512":a.alg="RS512";break;default:return Promise.reject("Incorrect hash algorithm: "+s.hash.name.toUpperCase())}const e=o.toJSON();for(const t of Object.keys(e))a[t]=e[t]}break;case"ECDSA":i=["verify"];case"ECDH":{if(a={kty:"EC",ext:r,key_ops:i},"1.2.840.10045.2.1"!==o.algorithm.algorithmId)return Promise.reject("Incorrect public key algorithm: "+o.algorithm.algorithmId);const e=o.toJSON();for(const t of Object.keys(e))a[t]=e[t]}break;case"RSA-OAEP":{if(a.kty="RSA",a.ext=r,a.key_ops=i,"safari"===this.name.toLowerCase())a.alg="RSA-OAEP";else switch(s.hash.name.toUpperCase()){case"SHA-1":a.alg="RSA-OAEP";break;case"SHA-256":a.alg="RSA-OAEP-256";break;case"SHA-384":a.alg="RSA-OAEP-384";break;case"SHA-512":a.alg="RSA-OAEP-512";break;default:return Promise.reject("Incorrect hash algorithm: "+s.hash.name.toUpperCase())}const e=o.toJSON();for(const t of Object.keys(e))a[t]=e[t]}break;case"RSAES-PKCS1-V1_5":{a.kty="RSA",a.ext=r,a.key_ops=i,a.alg="PS1";const e=o.toJSON();for(const t of Object.keys(e))a[t]=e[t]}break;default:return Promise.reject("Incorrect algorithm name: "+s.name.toUpperCase())}}break;case"pkcs8":{const e=new ke,o=y(t);if(-1===o.offset)return Promise.reject("Incorrect keyData");try{e.fromSchema(o.result)}catch(n){return Promise.reject("Incorrect keyData")}if("parsedKey"in e==0)return Promise.reject("Incorrect keyData");switch(s.name.toUpperCase()){case"RSA-PSS":switch(s.hash.name.toUpperCase()){case"SHA-1":a.alg="PS1";break;case"SHA-256":a.alg="PS256";break;case"SHA-384":a.alg="PS384";break;case"SHA-512":a.alg="PS512";break;default:return Promise.reject("Incorrect hash algorithm: "+s.hash.name.toUpperCase())}case"RSASSA-PKCS1-V1_5":{if(i=["sign"],a.kty="RSA",a.ext=r,a.key_ops=i,"1.2.840.113549.1.1.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject("Incorrect private key algorithm: "+e.privateKeyAlgorithm.algorithmId);if("alg"in a==0)switch(s.hash.name.toUpperCase()){case"SHA-1":a.alg="RS1";break;case"SHA-256":a.alg="RS256";break;case"SHA-384":a.alg="RS384";break;case"SHA-512":a.alg="RS512";break;default:return Promise.reject("Incorrect hash algorithm: "+s.hash.name.toUpperCase())}const t=e.toJSON();for(const e of Object.keys(t))a[e]=t[e]}break;case"ECDSA":i=["sign"];case"ECDH":{if(a={kty:"EC",ext:r,key_ops:i},"1.2.840.10045.2.1"!==e.privateKeyAlgorithm.algorithmId)return Promise.reject("Incorrect algorithm: "+e.privateKeyAlgorithm.algorithmId);const t=e.toJSON();for(const e of Object.keys(t))a[e]=t[e]}break;case"RSA-OAEP":{if(a.kty="RSA",a.ext=r,a.key_ops=i,"safari"===this.name.toLowerCase())a.alg="RSA-OAEP";else switch(s.hash.name.toUpperCase()){case"SHA-1":a.alg="RSA-OAEP";break;case"SHA-256":a.alg="RSA-OAEP-256";break;case"SHA-384":a.alg="RSA-OAEP-384";break;case"SHA-512":a.alg="RSA-OAEP-512";break;default:return Promise.reject("Incorrect hash algorithm: "+s.hash.name.toUpperCase())}const t=e.toJSON();for(const e of Object.keys(t))a[e]=t[e]}break;case"RSAES-PKCS1-V1_5":{i=["decrypt"],a.kty="RSA",a.ext=r,a.key_ops=i,a.alg="PS1";const t=e.toJSON();for(const e of Object.keys(t))a[e]=t[e]}break;default:return Promise.reject("Incorrect algorithm name: "+s.name.toUpperCase())}}break;case"jwk":a=t;break;default:return Promise.reject("Incorrect format: "+e)}return"safari"===this.name.toLowerCase()?Promise.resolve().then(()=>this.subtle.importKey("jwk",l(JSON.stringify(a)),s,r,i)).then(e=>e,()=>this.subtle.importKey("jwk",a,s,r,i)):this.subtle.importKey("jwk",a,s,r,i)}exportKey(e,t){let s=this.subtle.exportKey("jwk",t);switch("safari"===this.name.toLowerCase()&&(s=s.then(e=>e instanceof ArrayBuffer?JSON.parse(u(e)):e)),e.toLowerCase()){case"raw":return this.subtle.exportKey("raw",t);case"spki":s=s.then(e=>{const t=new be;try{t.fromJSON(e)}catch(s){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"pkcs8":s=s.then(e=>{const t=new ke;try{t.fromJSON(e)}catch(s){return Promise.reject("Incorrect key data")}return t.toSchema().toBER(!1)});break;case"jwk":break;default:return Promise.reject("Incorrect format: "+e)}return s}convert(e,t,s,r,i,a){switch(e.toLowerCase()){case"raw":switch(t.toLowerCase()){case"raw":return Promise.resolve(s);case"spki":return Promise.resolve().then(()=>this.importKey("raw",s,r,i,a)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("raw",s,r,i,a)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve().then(()=>this.importKey("raw",s,r,i,a)).then(e=>this.exportKey("jwk",e));default:return Promise.reject("Incorrect outputFormat: "+t)}case"spki":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("spki",s,r,i,a)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve(s);case"pkcs8":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"jwk":return Promise.resolve().then(()=>this.importKey("spki",s,r,i,a)).then(e=>this.exportKey("jwk",e));default:return Promise.reject("Incorrect outputFormat: "+t)}case"pkcs8":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("pkcs8",s,r,i,a)).then(e=>this.exportKey("raw",e));case"spki":return Promise.reject("Impossible to convert between SPKI/PKCS8");case"pkcs8":return Promise.resolve(s);case"jwk":return Promise.resolve().then(()=>this.importKey("pkcs8",s,r,i,a)).then(e=>this.exportKey("jwk",e));default:return Promise.reject("Incorrect outputFormat: "+t)}case"jwk":switch(t.toLowerCase()){case"raw":return Promise.resolve().then(()=>this.importKey("jwk",s,r,i,a)).then(e=>this.exportKey("raw",e));case"spki":return Promise.resolve().then(()=>this.importKey("jwk",s,r,i,a)).then(e=>this.exportKey("spki",e));case"pkcs8":return Promise.resolve().then(()=>this.importKey("jwk",s,r,i,a)).then(e=>this.exportKey("pkcs8",e));case"jwk":return Promise.resolve(s);default:return Promise.reject("Incorrect outputFormat: "+t)}default:return Promise.reject("Incorrect inputFormat: "+e)}}encrypt(...e){return this.subtle.encrypt(...e)}decrypt(...e){return this.subtle.decrypt(...e)}sign(...e){return this.subtle.sign(...e)}verify(...e){return this.subtle.verify(...e)}digest(...e){return this.subtle.digest(...e)}generateKey(...e){return this.subtle.generateKey(...e)}deriveKey(...e){return this.subtle.deriveKey(...e)}deriveBits(...e){return this.subtle.deriveBits(...e)}wrapKey(...e){return this.subtle.wrapKey(...e)}unwrapKey(...e){return this.subtle.unwrapKey(...e)}getRandomValues(e){if("getRandomValues"in this.crypto==0)throw new Error("No support for getRandomValues");return this.crypto.getRandomValues(e)}getAlgorithmByOID(e){switch(e){case"1.2.840.113549.1.1.1":return{name:"RSAES-PKCS1-v1_5"};case"1.2.840.113549.1.1.5":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-1"}};case"1.2.840.113549.1.1.11":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}};case"1.2.840.113549.1.1.12":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}};case"1.2.840.113549.1.1.13":return{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}};case"1.2.840.113549.1.1.10":return{name:"RSA-PSS"};case"1.2.840.113549.1.1.7":return{name:"RSA-OAEP"};case"1.2.840.10045.2.1":case"1.2.840.10045.4.1":return{name:"ECDSA",hash:{name:"SHA-1"}};case"1.2.840.10045.4.3.2":return{name:"ECDSA",hash:{name:"SHA-256"}};case"1.2.840.10045.4.3.3":return{name:"ECDSA",hash:{name:"SHA-384"}};case"1.2.840.10045.4.3.4":return{name:"ECDSA",hash:{name:"SHA-512"}};case"1.3.133.16.840.63.0.2":return{name:"ECDH",kdf:"SHA-1"};case"1.3.132.1.11.1":return{name:"ECDH",kdf:"SHA-256"};case"1.3.132.1.11.2":return{name:"ECDH",kdf:"SHA-384"};case"1.3.132.1.11.3":return{name:"ECDH",kdf:"SHA-512"};case"2.16.840.1.101.3.4.1.2":return{name:"AES-CBC",length:128};case"2.16.840.1.101.3.4.1.22":return{name:"AES-CBC",length:192};case"2.16.840.1.101.3.4.1.42":return{name:"AES-CBC",length:256};case"2.16.840.1.101.3.4.1.6":return{name:"AES-GCM",length:128};case"2.16.840.1.101.3.4.1.26":return{name:"AES-GCM",length:192};case"2.16.840.1.101.3.4.1.46":return{name:"AES-GCM",length:256};case"2.16.840.1.101.3.4.1.4":return{name:"AES-CFB",length:128};case"2.16.840.1.101.3.4.1.24":return{name:"AES-CFB",length:192};case"2.16.840.1.101.3.4.1.44":return{name:"AES-CFB",length:256};case"2.16.840.1.101.3.4.1.5":return{name:"AES-KW",length:128};case"2.16.840.1.101.3.4.1.25":return{name:"AES-KW",length:192};case"2.16.840.1.101.3.4.1.45":return{name:"AES-KW",length:256};case"1.2.840.113549.2.7":return{name:"HMAC",hash:{name:"SHA-1"}};case"1.2.840.113549.2.9":return{name:"HMAC",hash:{name:"SHA-256"}};case"1.2.840.113549.2.10":return{name:"HMAC",hash:{name:"SHA-384"}};case"1.2.840.113549.2.11":return{name:"HMAC",hash:{name:"SHA-512"}};case"1.2.840.113549.1.9.16.3.5":return{name:"DH"};case"1.3.14.3.2.26":return{name:"SHA-1"};case"2.16.840.1.101.3.4.2.1":return{name:"SHA-256"};case"2.16.840.1.101.3.4.2.2":return{name:"SHA-384"};case"2.16.840.1.101.3.4.2.3":return{name:"SHA-512"};case"1.2.840.113549.1.5.12":return{name:"PBKDF2"};case"1.2.840.10045.3.1.7":return{name:"P-256"};case"1.3.132.0.34":return{name:"P-384"};case"1.3.132.0.35":return{name:"P-521"}}return{}}getOIDByAlgorithm(e){let t="";switch(e.name.toUpperCase()){case"RSAES-PKCS1-V1_5":t="1.2.840.113549.1.1.1";break;case"RSASSA-PKCS1-V1_5":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.1.1.5";break;case"SHA-256":t="1.2.840.113549.1.1.11";break;case"SHA-384":t="1.2.840.113549.1.1.12";break;case"SHA-512":t="1.2.840.113549.1.1.13"}break;case"RSA-PSS":t="1.2.840.113549.1.1.10";break;case"RSA-OAEP":t="1.2.840.113549.1.1.7";break;case"ECDSA":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.10045.4.1";break;case"SHA-256":t="1.2.840.10045.4.3.2";break;case"SHA-384":t="1.2.840.10045.4.3.3";break;case"SHA-512":t="1.2.840.10045.4.3.4"}break;case"ECDH":switch(e.kdf.toUpperCase()){case"SHA-1":t="1.3.133.16.840.63.0.2";break;case"SHA-256":t="1.3.132.1.11.1";break;case"SHA-384":t="1.3.132.1.11.2";break;case"SHA-512":t="1.3.132.1.11.3"}break;case"AES-CTR":break;case"AES-CBC":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.2";break;case 192:t="2.16.840.1.101.3.4.1.22";break;case 256:t="2.16.840.1.101.3.4.1.42"}break;case"AES-CMAC":break;case"AES-GCM":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.6";break;case 192:t="2.16.840.1.101.3.4.1.26";break;case 256:t="2.16.840.1.101.3.4.1.46"}break;case"AES-CFB":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.4";break;case 192:t="2.16.840.1.101.3.4.1.24";break;case 256:t="2.16.840.1.101.3.4.1.44"}break;case"AES-KW":switch(e.length){case 128:t="2.16.840.1.101.3.4.1.5";break;case 192:t="2.16.840.1.101.3.4.1.25";break;case 256:t="2.16.840.1.101.3.4.1.45"}break;case"HMAC":switch(e.hash.name.toUpperCase()){case"SHA-1":t="1.2.840.113549.2.7";break;case"SHA-256":t="1.2.840.113549.2.9";break;case"SHA-384":t="1.2.840.113549.2.10";break;case"SHA-512":t="1.2.840.113549.2.11"}break;case"DH":t="1.2.840.113549.1.9.16.3.5";break;case"SHA-1":t="1.3.14.3.2.26";break;case"SHA-256":t="2.16.840.1.101.3.4.2.1";break;case"SHA-384":t="2.16.840.1.101.3.4.2.2";break;case"SHA-512":t="2.16.840.1.101.3.4.2.3";break;case"CONCAT":case"HKDF":break;case"PBKDF2":t="1.2.840.113549.1.5.12";break;case"P-256":t="1.2.840.10045.3.1.7";break;case"P-384":t="1.3.132.0.34";break;case"P-521":t="1.3.132.0.35"}return t}getAlgorithmParameters(e,t){let s={algorithm:{},usages:[]};switch(e.toUpperCase()){case"RSAES-PKCS1-V1_5":case"RSASSA-PKCS1-V1_5":switch(t.toLowerCase()){case"generatekey":s={algorithm:{name:"RSASSA-PKCS1-v1_5",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["sign","verify"]};break;case"verify":case"sign":case"importkey":s={algorithm:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSASSA-PKCS1-v1_5"},usages:[]}}break;case"RSA-PSS":switch(t.toLowerCase()){case"sign":case"verify":s={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"},saltLength:20},usages:["sign","verify"]};break;case"generatekey":s={algorithm:{name:"RSA-PSS",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-1"}},usages:["sign","verify"]};break;case"importkey":s={algorithm:{name:"RSA-PSS",hash:{name:"SHA-1"}},usages:["verify"]};break;case"exportkey":default:return{algorithm:{name:"RSA-PSS"},usages:[]}}break;case"RSA-OAEP":switch(t.toLowerCase()){case"encrypt":case"decrypt":s={algorithm:{name:"RSA-OAEP"},usages:["encrypt","decrypt"]};break;case"generatekey":s={algorithm:{name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"importkey":s={algorithm:{name:"RSA-OAEP",hash:{name:"SHA-256"}},usages:["encrypt"]};break;case"exportkey":default:return{algorithm:{name:"RSA-OAEP"},usages:[]}}break;case"ECDSA":switch(t.toLowerCase()){case"generatekey":s={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["sign","verify"]};break;case"importkey":s={algorithm:{name:"ECDSA",namedCurve:"P-256"},usages:["verify"]};break;case"verify":case"sign":s={algorithm:{name:"ECDSA",hash:{name:"SHA-256"}},usages:["sign"]};break;default:return{algorithm:{name:"ECDSA"},usages:[]}}break;case"ECDH":switch(t.toLowerCase()){case"exportkey":case"importkey":case"generatekey":s={algorithm:{name:"ECDH",namedCurve:"P-256"},usages:["deriveKey","deriveBits"]};break;case"derivekey":case"derivebits":s={algorithm:{name:"ECDH",namedCurve:"P-256",public:[]},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"ECDH"},usages:[]}}break;case"AES-CTR":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"AES-CTR",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":s={algorithm:{name:"AES-CTR",counter:new Uint8Array(16),length:10},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CTR"},usages:[]}}break;case"AES-CBC":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"AES-CBC",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":s={algorithm:{name:"AES-CBC",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-CBC"},usages:[]}}break;case"AES-GCM":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"AES-GCM",length:256},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;case"decrypt":case"encrypt":s={algorithm:{name:"AES-GCM",iv:this.getRandomValues(new Uint8Array(16))},usages:["encrypt","decrypt","wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-GCM"},usages:[]}}break;case"AES-KW":switch(t.toLowerCase()){case"importkey":case"exportkey":case"generatekey":case"wrapkey":case"unwrapkey":s={algorithm:{name:"AES-KW",length:256},usages:["wrapKey","unwrapKey"]};break;default:return{algorithm:{name:"AES-KW"},usages:[]}}break;case"HMAC":switch(t.toLowerCase()){case"sign":case"verify":s={algorithm:{name:"HMAC"},usages:["sign","verify"]};break;case"importkey":case"exportkey":case"generatekey":s={algorithm:{name:"HMAC",length:32,hash:{name:"SHA-256"}},usages:["sign","verify"]};break;default:return{algorithm:{name:"HMAC"},usages:[]}}break;case"HKDF":switch(t.toLowerCase()){case"derivekey":s={algorithm:{name:"HKDF",hash:"SHA-256",salt:new Uint8Array([]),info:new Uint8Array([])},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"HKDF"},usages:[]}}break;case"PBKDF2":switch(t.toLowerCase()){case"derivekey":s={algorithm:{name:"PBKDF2",hash:{name:"SHA-256"},salt:new Uint8Array([]),iterations:1e4},usages:["encrypt","decrypt"]};break;default:return{algorithm:{name:"PBKDF2"},usages:[]}}}return s}getHashAlgorithm(e){let t="";switch(e.algorithmId){case"1.2.840.10045.4.1":case"1.2.840.113549.1.1.5":t="SHA-1";break;case"1.2.840.10045.4.3.2":case"1.2.840.113549.1.1.11":t="SHA-256";break;case"1.2.840.10045.4.3.3":case"1.2.840.113549.1.1.12":t="SHA-384";break;case"1.2.840.10045.4.3.4":case"1.2.840.113549.1.1.13":t="SHA-512";break;case"1.2.840.113549.1.1.10":try{const s=new Pe({schema:e.algorithmParams});if("hashAlgorithm"in s){const e=this.getAlgorithmByOID(s.hashAlgorithm.algorithmId);if("name"in e==0)return"";t=e.name}else t="SHA-1"}catch(s){}}return t}encryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("contentEncryptionAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "contentEncryptionAlgorithm"');if("hmacHashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hmacHashAlgorithm"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("contentToEncrypt"in e==0)return Promise.reject('Absent mandatory parameter "contentToEncrypt"');if("contentType"in e==0)return Promise.reject('Absent mandatory parameter "contentType"');const t=this.getOIDByAlgorithm(e.contentEncryptionAlgorithm);if(""===t)return Promise.reject('Wrong "contentEncryptionAlgorithm" value');const s=this.getOIDByAlgorithm({name:"PBKDF2"});if(""===s)return Promise.reject("Can not find OID for PBKDF2");const r=this.getOIDByAlgorithm({name:"HMAC",hash:{name:e.hmacHashAlgorithm}});if(""===r)return Promise.reject('Incorrect value for "hmacHashAlgorithm": '+e.hmacHashAlgorithm);let i=Promise.resolve();const a=new ArrayBuffer(16),n=new Uint8Array(a);this.getRandomValues(n);const o=new ArrayBuffer(64),c=new Uint8Array(o);this.getRandomValues(c);const h=new Uint8Array(e.contentToEncrypt),u=new Ee({salt:new A({valueHex:o}),iterationCount:e.iterationCount,prf:new de({algorithmId:r,algorithmParams:new p})});return i=i.then(()=>{const t=new Uint8Array(e.password);return this.importKey("raw",t,"PBKDF2",!1,["deriveKey"])},e=>Promise.reject(e)),i=i.then(t=>this.deriveKey({name:"PBKDF2",hash:{name:e.hmacHashAlgorithm},salt:c,iterations:e.iterationCount},t,e.contentEncryptionAlgorithm,!1,["encrypt"]),e=>Promise.reject(e)),i=i.then(t=>this.encrypt({name:e.contentEncryptionAlgorithm.name,iv:n},t,h),e=>Promise.reject(e)),i=i.then(r=>{const i=new Ie({keyDerivationFunc:new de({algorithmId:s,algorithmParams:u.toSchema()}),encryptionScheme:new de({algorithmId:t,algorithmParams:new A({valueHex:a})})});return new Ce({contentType:e.contentType,contentEncryptionAlgorithm:new de({algorithmId:"1.2.840.113549.1.5.13",algorithmParams:i.toSchema()}),encryptedContent:new A({valueHex:r})})},e=>Promise.reject(e)),i}decryptEncryptedContentInfo(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("encryptedContentInfo"in e==0)return Promise.reject('Absent mandatory parameter "encryptedContentInfo"');if("1.2.840.113549.1.5.13"!==e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId)return Promise.reject('Unknown "contentEncryptionAlgorithm": '+e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmId);let t,s,r=Promise.resolve();try{t=new Ie({schema:e.encryptedContentInfo.contentEncryptionAlgorithm.algorithmParams})}catch(u){return Promise.reject('Incorrectly encoded "pbes2Parameters"')}try{s=new Ee({schema:t.keyDerivationFunc.algorithmParams})}catch(u){return Promise.reject('Incorrectly encoded "pbkdf2Params"')}const i=this.getAlgorithmByOID(t.encryptionScheme.algorithmId);if("name"in i==0)return Promise.reject('Incorrect OID for "contentEncryptionAlgorithm": '+t.encryptionScheme.algorithmId);const a=new Uint8Array(t.encryptionScheme.algorithmParams.valueBlock.valueHex),n=new Uint8Array(s.salt.valueBlock.valueHex),o=s.iterationCount;let h="SHA-1";if("prf"in s){const e=this.getAlgorithmByOID(s.prf.algorithmId);if("name"in e==0)return Promise.reject("Incorrect OID for HMAC hash algorithm");h=e.hash.name}return r=r.then(()=>this.importKey("raw",e.password,"PBKDF2",!1,["deriveKey"]),e=>Promise.reject(e)),r=r.then(e=>this.deriveKey({name:"PBKDF2",hash:{name:h},salt:n,iterations:o},e,i,!1,["decrypt"]),e=>Promise.reject(e)),r=r.then(t=>{let s=new ArrayBuffer(0);if(!1===e.encryptedContentInfo.encryptedContent.idBlock.isConstructed)s=e.encryptedContentInfo.encryptedContent.valueBlock.valueHex;else for(const r of e.encryptedContentInfo.encryptedContent.valueBlock.value)s=c(s,r.valueBlock.valueHex);return this.decrypt({name:i.name,iv:a},t,s)},e=>Promise.reject(e)),r}stampDataWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToStamp"in e==0)return Promise.reject('Absent mandatory parameter "contentToStamp"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject('Incorrect "parameters.hashAlgorithm" parameter: '+e.hashAlgorithm)}let s=Promise.resolve();const r={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return s=s.then(()=>Ne(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount)),s=s.then(e=>this.importKey("raw",new Uint8Array(e),r,!1,["sign"])),s=s.then(t=>this.sign(r,t,new Uint8Array(e.contentToStamp)),e=>Promise.reject(e)),s}verifyDataStampedWithPassword(e){if(e instanceof Object==0)return Promise.reject('Parameters must have type "Object"');if("password"in e==0)return Promise.reject('Absent mandatory parameter "password"');if("hashAlgorithm"in e==0)return Promise.reject('Absent mandatory parameter "hashAlgorithm"');if("salt"in e==0)return Promise.reject('Absent mandatory parameter "iterationCount"');if("iterationCount"in e==0)return Promise.reject('Absent mandatory parameter "salt"');if("contentToVerify"in e==0)return Promise.reject('Absent mandatory parameter "contentToVerify"');if("signatureToVerify"in e==0)return Promise.reject('Absent mandatory parameter "signatureToVerify"');let t;switch(e.hashAlgorithm.toLowerCase()){case"sha-1":t=160;break;case"sha-256":t=256;break;case"sha-384":t=384;break;case"sha-512":t=512;break;default:return Promise.reject('Incorrect "parameters.hashAlgorithm" parameter: '+e.hashAlgorithm)}let s=Promise.resolve();const r={name:"HMAC",length:t,hash:{name:e.hashAlgorithm}};return s=s.then(()=>Ne(this,e.hashAlgorithm,t,e.password,e.salt,e.iterationCount)),s=s.then(e=>this.importKey("raw",new Uint8Array(e),r,!1,["verify"])),s=s.then(t=>this.verify(r,t,new Uint8Array(e.signatureToVerify),new Uint8Array(e.contentToVerify)),e=>Promise.reject(e)),s}getSignatureParameters(e,t="SHA-1"){if(""===this.getOIDByAlgorithm({name:t}))return Promise.reject("Unsupported hash algorithm: "+t);const s=new de,r=this.getAlgorithmParameters(e.algorithm.name,"sign");switch(r.algorithm.hash.name=t,e.algorithm.name.toUpperCase()){case"RSASSA-PKCS1-V1_5":case"ECDSA":s.algorithmId=this.getOIDByAlgorithm(r.algorithm);break;case"RSA-PSS":{switch(t.toUpperCase()){case"SHA-256":r.algorithm.saltLength=32;break;case"SHA-384":r.algorithm.saltLength=48;break;case"SHA-512":r.algorithm.saltLength=64}const e={};if("SHA-1"!==t.toUpperCase()){const s=this.getOIDByAlgorithm({name:t});if(""===s)return Promise.reject("Unsupported hash algorithm: "+t);e.hashAlgorithm=new de({algorithmId:s,algorithmParams:new p}),e.maskGenAlgorithm=new de({algorithmId:"1.2.840.113549.1.1.8",algorithmParams:e.hashAlgorithm.toSchema()})}20!==r.algorithm.saltLength&&(e.saltLength=r.algorithm.saltLength);const i=new Pe(e);s.algorithmId="1.2.840.113549.1.1.10",s.algorithmParams=i.toSchema()}break;default:return Promise.reject("Unsupported signature algorithm: "+e.algorithm.name)}return Promise.resolve().then(()=>({signatureAlgorithm:s,parameters:r}))}signWithPrivateKey(e,t,r){return this.sign(r.algorithm,t,new Uint8Array(e)).then(e=>("ECDSA"===r.algorithm.name&&(e=function(e){if(e.byteLength%2!=0)return new ArrayBuffer(0);const t=e.byteLength/2,r=new ArrayBuffer(t);new Uint8Array(r).set(new Uint8Array(e,0,t));const i=new w({valueHex:r}),a=new ArrayBuffer(t);new Uint8Array(a).set(new Uint8Array(e,t,t));const n=new w({valueHex:a});return new s({value:[i.convertToDER(),n.convertToDER()]}).toBER(!1)}(e)),e),e=>Promise.reject("Signing error: "+e))}fillPublicKeyParameters(e,t){const s={},r=this.getHashAlgorithm(t);if(""===r)return Promise.reject("Unsupported signature algorithm: "+t.algorithmId);let i;i="1.2.840.113549.1.1.10"===t.algorithmId?t.algorithmId:e.algorithm.algorithmId;const a=this.getAlgorithmByOID(i);if("name"in a==="")return Promise.reject("Unsupported public key algorithm: "+t.algorithmId);if(s.algorithm=this.getAlgorithmParameters(a.name,"importkey"),"hash"in s.algorithm.algorithm&&(s.algorithm.algorithm.hash.name=r),"ECDSA"===a.name){let t=!1;if("algorithmParams"in e.algorithm==1&&"idBlock"in e.algorithm.algorithmParams&&1===e.algorithm.algorithmParams.idBlock.tagClass&&6===e.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)return Promise.reject("Incorrect type for ECDSA public key parameters");const r=this.getAlgorithmByOID(e.algorithm.algorithmParams.valueBlock.toString());if("name"in r==0)return Promise.reject("Unsupported named curve algorithm: "+e.algorithm.algorithmParams.valueBlock.toString());s.algorithm.algorithm.namedCurve=r.name}return s}getPublicKey(e,t,s=null){null===s&&(s=this.fillPublicKeyParameters(e,t));const r=e.toSchema().toBER(!1),i=new Uint8Array(r);return this.importKey("spki",i,s.algorithm.algorithm,!0,s.algorithm.usages)}verifyWithPublicKey(e,t,r,i,a=null){let n=Promise.resolve();if(null===a){if(""===(a=this.getHashAlgorithm(i)))return Promise.reject("Unsupported signature algorithm: "+i.algorithmId);n=n.then(()=>this.getPublicKey(r,i))}else{const e={};let t;t="1.2.840.113549.1.1.10"===i.algorithmId?i.algorithmId:r.algorithm.algorithmId;const s=this.getAlgorithmByOID(t);if("name"in s==="")return Promise.reject("Unsupported public key algorithm: "+i.algorithmId);if(e.algorithm=this.getAlgorithmParameters(s.name,"importkey"),"hash"in e.algorithm.algorithm&&(e.algorithm.algorithm.hash.name=a),"ECDSA"===s.name){let t=!1;if("algorithmParams"in r.algorithm==1&&"idBlock"in r.algorithm.algorithmParams&&1===r.algorithm.algorithmParams.idBlock.tagClass&&6===r.algorithm.algorithmParams.idBlock.tagNumber&&(t=!0),!1===t)return Promise.reject("Incorrect type for ECDSA public key parameters");const s=this.getAlgorithmByOID(r.algorithm.algorithmParams.valueBlock.toString());if("name"in s==0)return Promise.reject("Unsupported named curve algorithm: "+r.algorithm.algorithmParams.valueBlock.toString());e.algorithm.algorithm.namedCurve=s.name}n=n.then(()=>this.getPublicKey(r,null,e))}return n=n.then(r=>{const n=this.getAlgorithmParameters(r.algorithm.name,"verify");"hash"in n.algorithm&&(n.algorithm.hash.name=a);let o=t.valueBlock.valueHex;if("ECDSA"===r.algorithm.name&&(o=function(e){if(e instanceof s==0)return new ArrayBuffer(0);if(2!==e.valueBlock.value.length)return new ArrayBuffer(0);if(e.valueBlock.value[0]instanceof w==0)return new ArrayBuffer(0);if(e.valueBlock.value[1]instanceof w==0)return new ArrayBuffer(0);const t=e.valueBlock.value[0].convertFromDER(),r=e.valueBlock.value[1].convertFromDER();switch(!0){case t.valueBlock.valueHex.byteLength<r.valueBlock.valueHex.byteLength:{if(r.valueBlock.valueHex.byteLength-t.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=r.valueBlock.valueHex.byteLength,s=new Uint8Array(t.valueBlock.valueHex),i=new ArrayBuffer(e),a=new Uint8Array(i);return a.set(s,1),a[0]=0,c(i,r.valueBlock.valueHex)}case t.valueBlock.valueHex.byteLength>r.valueBlock.valueHex.byteLength:{if(t.valueBlock.valueHex.byteLength-r.valueBlock.valueHex.byteLength!=1)throw new Error("Incorrect DER integer decoding");const e=t.valueBlock.valueHex.byteLength,s=new Uint8Array(r.valueBlock.valueHex),i=new ArrayBuffer(e),a=new Uint8Array(i);return a.set(s,1),a[0]=0,c(t.valueBlock.valueHex,i)}default:if(t.valueBlock.valueHex.byteLength%2){const e=t.valueBlock.valueHex.byteLength+1,s=new Uint8Array(t.valueBlock.valueHex),i=new ArrayBuffer(e),a=new Uint8Array(i);a.set(s,1),a[0]=0;const n=new Uint8Array(r.valueBlock.valueHex),o=new ArrayBuffer(e),h=new Uint8Array(o);return h.set(n,1),h[0]=0,c(i,o)}}return c(t.valueBlock.valueHex,r.valueBlock.valueHex)}(y(o).result)),"RSA-PSS"===r.algorithm.name){let e;try{e=new Pe({schema:i.algorithmParams})}catch(h){return Promise.reject(h)}n.algorithm.saltLength="saltLength"in e?e.saltLength:20;let t="SHA-1";if("hashAlgorithm"in e){const s=this.getAlgorithmByOID(e.hashAlgorithm.algorithmId);if("name"in s==0)return Promise.reject("Unrecognized hash algorithm: "+e.hashAlgorithm.algorithmId);t=s.name}n.algorithm.hash.name=t}return this.verify(n.algorithm,r,new Uint8Array(o),new Uint8Array(e))}),n}}let Be={name:"none",crypto:null,subtle:null};function Ue(e,t,s){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){if(void 0===global[process.pid])global[process.pid]={};else if("object"!=typeof global[process.pid])throw new Error(`Name global.${process.pid} already exists and it is not an object`);if(void 0===global[process.pid].pkijs)global[process.pid].pkijs={};else if("object"!=typeof global[process.pid].pkijs)throw new Error(`Name global.${process.pid}.pkijs already exists and it is not an object`);global[process.pid].pkijs.engine={name:e,crypto:t,subtle:s}}else Be.name!==e&&(Be={name:e,crypto:t,subtle:s})}function He(){if("undefined"!=typeof process&&"pid"in process&&"undefined"!=typeof global&&"undefined"==typeof window){let t;try{t=global[process.pid].pkijs.engine}catch(e){throw new Error('Please call "setEngine" before call to "getEngine"')}return t}return Be}function je(){const e=He();if(null!==e.subtle)return e.subtle}function De(e){let t=!1,s="";const r=e.trim();for(let i=0;i<r.length;i++)32===r.charCodeAt(i)?!1===t&&(t=!0):(t&&(s+=" ",t=!1),s+=r[i]);return s.toLowerCase()}!function(){if("undefined"!=typeof self&&"crypto"in self){let t="webcrypto";const s=self.crypto;let r;if("webkitSubtle"in self.crypto){try{r=self.crypto.webkitSubtle}catch(e){r=self.crypto.subtle}t="safari"}"subtle"in self.crypto&&(r=self.crypto.subtle),Be=void 0===r?{name:t,crypto:s,subtle:null}:{name:t,crypto:s,subtle:new xe({name:t,crypto:self.crypto,subtle:r})}}Ue(Be.name,Be.crypto,Be.subtle)}();class Oe{constructor(t={}){this.type=e(t,"type",Oe.defaultValues("type")),this.value=e(t,"value",Oe.defaultValues("value")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"type":return"";case"value":return{};default:throw new Error("Invalid member name for AttributeTypeAndValue class: "+e)}}static schema(i={}){const a=e(i,"names",{});return new s({name:a.blockName||"",value:[new r({name:a.type||""}),new t({name:a.value||""})]})}static blockName(){return"AttributeTypeAndValue"}fromSchema(e){i(e,["type","typeValue"]);const t=a(e,e,Oe.schema({names:{type:"type",value:"typeValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AttributeTypeAndValue");this.type=t.result.type.valueBlock.toString(),this.value=t.result.typeValue}toSchema(){return new s({value:[new r({value:this.type}),this.value]})}toJSON(){const e={type:this.type};return e.value=0!==Object.keys(this.value).length?this.value.toJSON():this.value,e}isEqual(e){const t=[C.blockName(),P.blockName(),E.blockName(),I.blockName(),N.blockName(),x.blockName(),B.blockName(),U.blockName(),H.blockName(),j.blockName(),D.blockName(),O.blockName()];if(e.constructor.blockName()===Oe.blockName()){if(this.type!==e.type)return!1;let s=!1;const r=this.value.constructor.blockName();if(r===e.value.constructor.blockName())for(const e of t)if(r===e){s=!0;break}if(s){const t=De(this.value.valueBlock.value),s=De(e.value.valueBlock.value);if(0!==t.localeCompare(s))return!1}else if(!1===n(this.value.valueBeforeDecode,e.value.valueBeforeDecode))return!1;return!0}return e instanceof ArrayBuffer&&n(this.value.valueBeforeDecode,e)}}class Ke{constructor(t={}){this.typesAndValues=e(t,"typesAndValues",Ke.defaultValues("typesAndValues")),this.valueBeforeDecode=e(t,"valueBeforeDecode",Ke.defaultValues("valueBeforeDecode")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"typesAndValues":return[];case"valueBeforeDecode":return new ArrayBuffer(0);default:throw new Error("Invalid member name for RelativeDistinguishedNames class: "+e)}}static compareWithDefault(e,t){switch(e){case"typesAndValues":return 0===t.length;case"valueBeforeDecode":return 0===t.byteLength;default:throw new Error("Invalid member name for RelativeDistinguishedNames class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new g({name:r.repeatedSequence||"",value:new b({value:[new g({name:r.repeatedSet||"",value:Oe.schema(r.typeAndValue||{})})]})})]})}fromSchema(e){i(e,["RDN","typesAndValues"]);const t=a(e,e,Ke.schema({names:{blockName:"RDN",repeatedSet:"typesAndValues"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for RelativeDistinguishedNames");"typesAndValues"in t.result&&(this.typesAndValues=Array.from(t.result.typesAndValues,e=>new Oe({schema:e}))),this.valueBeforeDecode=t.result.RDN.valueBeforeDecode}toSchema(){return 0===this.valueBeforeDecode.byteLength?new s({value:[new b({value:Array.from(this.typesAndValues,e=>e.toSchema())})]}):y(this.valueBeforeDecode).result}toJSON(){return{typesAndValues:Array.from(this.typesAndValues,e=>e.toJSON())}}isEqual(e){if(e instanceof Ke){if(this.typesAndValues.length!==e.typesAndValues.length)return!1;for(const[t,s]of this.typesAndValues.entries())if(!1===s.isEqual(e.typesAndValues[t]))return!1;return!0}return e instanceof ArrayBuffer&&n(this.valueBeforeDecode,e)}}class Re{constructor(t={}){this.type=e(t,"type",Re.defaultValues("type")),this.value=e(t,"value",Re.defaultValues("value")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"type":return 0;case"value":return new Date(0,0,0);default:throw new Error("Invalid member name for Time class: "+e)}}static schema(t={},s=!1){const r=e(t,"names",{});return new S({optional:s,value:[new K({name:r.utcTimeName||""}),new R({name:r.generalTimeName||""})]})}fromSchema(e){i(e,["utcTimeName","generalTimeName"]);const t=a(e,e,Re.schema({names:{utcTimeName:"utcTimeName",generalTimeName:"generalTimeName"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Time");"utcTimeName"in t.result&&(this.type=0,this.value=t.result.utcTimeName.toDate()),"generalTimeName"in t.result&&(this.type=1,this.value=t.result.generalTimeName.toDate())}toSchema(){let e={};return 0===this.type&&(e=new K({valueDate:this.value})),1===this.type&&(e=new R({valueDate:this.value})),e}toJSON(){return{type:this.type,value:this.value}}}class Ve{constructor(t={}){this.attributes=e(t,"attributes",Ve.defaultValues("attributes")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"attributes":return[];default:throw new Error("Invalid member name for SubjectDirectoryAttributes class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new g({name:r.attributes||"",value:ge.schema()})]})}fromSchema(e){i(e,["attributes"]);const t=a(e,e,Ve.schema({names:{attributes:"attributes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for SubjectDirectoryAttributes");this.attributes=Array.from(t.result.attributes,e=>new ge({schema:e}))}toSchema(){return new s({value:Array.from(this.attributes,e=>e.toSchema())})}toJSON(){return{attributes:Array.from(this.attributes,e=>e.toJSON())}}}class Me{constructor(t={}){"notBefore"in t&&(this.notBefore=e(t,"notBefore",Me.defaultValues("notBefore"))),"notAfter"in t&&(this.notAfter=e(t,"notAfter",Me.defaultValues("notAfter"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"notBefore":case"notAfter":return new Date;default:throw new Error("Invalid member name for PrivateKeyUsagePeriod class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new k({name:r.notBefore||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new k({name:r.notAfter||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){i(e,["notBefore","notAfter"]);const t=a(e,e,Me.schema({names:{notBefore:"notBefore",notAfter:"notAfter"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PrivateKeyUsagePeriod");if("notBefore"in t.result){const e=new R;e.fromBuffer(t.result.notBefore.valueBlock.valueHex),this.notBefore=e.toDate()}if("notAfter"in t.result){const e=new R({valueHex:t.result.notAfter.valueBlock.valueHex});e.fromBuffer(t.result.notAfter.valueBlock.valueHex),this.notAfter=e.toDate()}}toSchema(){const e=[];return"notBefore"in this&&e.push(new k({idBlock:{tagClass:3,tagNumber:0},valueHex:new R({valueDate:this.notBefore}).valueBlock.valueHex})),"notAfter"in this&&e.push(new k({idBlock:{tagClass:3,tagNumber:1},valueHex:new R({valueDate:this.notAfter}).valueBlock.valueHex})),new s({value:e})}toJSON(){const e={};return"notBefore"in this&&(e.notBefore=this.notBefore),"notAfter"in this&&(e.notAfter=this.notAfter),e}}function Le(t={},r=!1){const i=e(t,"names",{});return new s({optional:r,value:[new v({optional:!0,idBlock:{tagClass:2,tagNumber:1},name:i.country_name||"",value:[new S({value:[new I,new N]})]}),new v({optional:!0,idBlock:{tagClass:2,tagNumber:2},name:i.administration_domain_name||"",value:[new S({value:[new I,new N]})]}),new k({optional:!0,idBlock:{tagClass:3,tagNumber:0},name:i.network_address||"",isHexOnly:!0}),new k({optional:!0,idBlock:{tagClass:3,tagNumber:1},name:i.terminal_identifier||"",isHexOnly:!0}),new v({optional:!0,idBlock:{tagClass:3,tagNumber:2},name:i.private_domain_name||"",value:[new S({value:[new I,new N]})]}),new k({optional:!0,idBlock:{tagClass:3,tagNumber:3},name:i.organization_name||"",isHexOnly:!0}),new k({optional:!0,name:i.numeric_user_identifier||"",idBlock:{tagClass:3,tagNumber:4},isHexOnly:!0}),new v({optional:!0,name:i.personal_name||"",idBlock:{tagClass:3,tagNumber:5},value:[new k({idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new k({optional:!0,idBlock:{tagClass:3,tagNumber:1},isHexOnly:!0}),new k({optional:!0,idBlock:{tagClass:3,tagNumber:2},isHexOnly:!0}),new k({optional:!0,idBlock:{tagClass:3,tagNumber:3},isHexOnly:!0})]}),new v({optional:!0,name:i.organizational_unit_names||"",idBlock:{tagClass:3,tagNumber:6},value:[new g({value:new N})]})]})}function Te(e=!1){return new s({optional:e,value:[new N,new N]})}function qe(e=!1){return new b({optional:e,value:[new k({optional:!0,idBlock:{tagClass:3,tagNumber:0},isHexOnly:!0}),new v({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new t]})]})}class Je{constructor(t={}){this.type=e(t,"type",Je.defaultValues("type")),this.value=e(t,"value",Je.defaultValues("value")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"type":return 9;case"value":return{};default:throw new Error("Invalid member name for GeneralName class: "+e)}}static compareWithDefault(e,t){switch(e){case"type":return t===Je.defaultValues(e);case"value":return 0===Object.keys(t).length;default:throw new Error("Invalid member name for GeneralName class: "+e)}}static schema(s={}){const i=e(s,"names",{});return new S({value:[new v({idBlock:{tagClass:3,tagNumber:0},name:i.blockName||"",value:[new r,new v({idBlock:{tagClass:3,tagNumber:0},value:[new t]})]}),new k({name:i.blockName||"",idBlock:{tagClass:3,tagNumber:1}}),new k({name:i.blockName||"",idBlock:{tagClass:3,tagNumber:2}}),new v({idBlock:{tagClass:3,tagNumber:3},name:i.blockName||"",value:[Le(i.builtInStandardAttributes||{},!1),Te(!0),qe(!0)]}),new v({idBlock:{tagClass:3,tagNumber:4},name:i.blockName||"",value:[Ke.schema(i.directoryName||{})]}),new v({idBlock:{tagClass:3,tagNumber:5},name:i.blockName||"",value:[new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new S({value:[new x,new N,new E,new C,new P]})]}),new v({idBlock:{tagClass:3,tagNumber:1},value:[new S({value:[new x,new N,new E,new C,new P]})]})]}),new k({name:i.blockName||"",idBlock:{tagClass:3,tagNumber:6}}),new k({name:i.blockName||"",idBlock:{tagClass:3,tagNumber:7}}),new k({name:i.blockName||"",idBlock:{tagClass:3,tagNumber:8}})]})}fromSchema(e){i(e,["blockName","otherName","rfc822Name","dNSName","x400Address","directoryName","ediPartyName","uniformResourceIdentifier","iPAddress","registeredID"]);const t=a(e,e,Je.schema({names:{blockName:"blockName",otherName:"otherName",rfc822Name:"rfc822Name",dNSName:"dNSName",x400Address:"x400Address",directoryName:{names:{blockName:"directoryName"}},ediPartyName:"ediPartyName",uniformResourceIdentifier:"uniformResourceIdentifier",iPAddress:"iPAddress",registeredID:"registeredID"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralName");switch(this.type=t.result.blockName.idBlock.tagNumber,this.type){case 0:this.value=t.result.blockName;break;case 1:case 2:case 6:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=22;const s=e.toBER(!1);this.value=y(s).result.valueBlock.value}break;case 3:this.value=t.result.blockName;break;case 4:this.value=new Ke({schema:t.result.directoryName});break;case 5:this.value=t.result.ediPartyName;break;case 7:this.value=new A({valueHex:t.result.blockName.valueBlock.valueHex});break;case 8:{const e=t.result.blockName;e.idBlock.tagClass=1,e.idBlock.tagNumber=6;const s=e.toBER(!1);this.value=y(s).result.valueBlock.toString()}}}toSchema(){switch(this.type){case 0:case 3:case 5:return new v({idBlock:{tagClass:3,tagNumber:this.type},value:[this.value]});case 1:case 2:case 6:{const e=new U({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 4:return new v({idBlock:{tagClass:3,tagNumber:4},value:[this.value.toSchema()]});case 7:{const e=this.value;return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}case 8:{const e=new r({value:this.value});return e.idBlock.tagClass=3,e.idBlock.tagNumber=this.type,e}default:return Je.schema()}}toJSON(){const e={type:this.type,value:""};if("string"==typeof this.value)e.value=this.value;else try{e.value=this.value.toJSON()}catch(t){}return e}}class Fe{constructor(t={}){this.altNames=e(t,"altNames",Fe.defaultValues("altNames")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"altNames":return[];default:throw new Error("Invalid member name for AltName class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new g({name:r.altNames||"",value:Je.schema()})]})}fromSchema(e){i(e,["altNames"]);const t=a(e,e,Fe.schema({names:{altNames:"altNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AltName");"altNames"in t.result&&(this.altNames=Array.from(t.result.altNames,e=>new Je({schema:e})))}toSchema(){return new s({value:Array.from(this.altNames,e=>e.toSchema())})}toJSON(){return{altNames:Array.from(this.altNames,e=>e.toJSON())}}}class _e{constructor(t={}){this.cA=e(t,"cA",!1),"pathLenConstraint"in t&&(this.pathLenConstraint=e(t,"pathLenConstraint",0)),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"cA":return!1;default:throw new Error("Invalid member name for BasicConstraints class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new V({optional:!0,name:r.cA||""}),new w({optional:!0,name:r.pathLenConstraint||""})]})}fromSchema(e){i(e,["cA","pathLenConstraint"]);const t=a(e,e,_e.schema({names:{cA:"cA",pathLenConstraint:"pathLenConstraint"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for BasicConstraints");"cA"in t.result&&(this.cA=t.result.cA.valueBlock.value),"pathLenConstraint"in t.result&&(this.pathLenConstraint=t.result.pathLenConstraint.valueBlock.isHexOnly?t.result.pathLenConstraint:t.result.pathLenConstraint.valueBlock.valueDec)}toSchema(){const e=[];return this.cA!==_e.defaultValues("cA")&&e.push(new V({value:this.cA})),"pathLenConstraint"in this&&e.push(this.pathLenConstraint instanceof w?this.pathLenConstraint:new w({value:this.pathLenConstraint})),new s({value:e})}toJSON(){const e={};return this.cA!==_e.defaultValues("cA")&&(e.cA=this.cA),"pathLenConstraint"in this&&(e.pathLenConstraint=this.pathLenConstraint instanceof w?this.pathLenConstraint.toJSON():this.pathLenConstraint),e}}class We{constructor(t={}){"distributionPoint"in t&&(this.distributionPoint=e(t,"distributionPoint",We.defaultValues("distributionPoint"))),this.onlyContainsUserCerts=e(t,"onlyContainsUserCerts",We.defaultValues("onlyContainsUserCerts")),this.onlyContainsCACerts=e(t,"onlyContainsCACerts",We.defaultValues("onlyContainsCACerts")),"onlySomeReasons"in t&&(this.onlySomeReasons=e(t,"onlySomeReasons",We.defaultValues("onlySomeReasons"))),this.indirectCRL=e(t,"indirectCRL",We.defaultValues("indirectCRL")),this.onlyContainsAttributeCerts=e(t,"onlyContainsAttributeCerts",We.defaultValues("onlyContainsAttributeCerts")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"onlyContainsUserCerts":case"onlyContainsCACerts":return!1;case"onlySomeReasons":return 0;case"indirectCRL":case"onlyContainsAttributeCerts":return!1;default:throw new Error("Invalid member name for IssuingDistributionPoint class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new S({value:[new v({name:r.distributionPoint||"",idBlock:{tagClass:3,tagNumber:0},value:[new g({name:r.distributionPointNames||"",value:Je.schema()})]}),new v({name:r.distributionPoint||"",idBlock:{tagClass:3,tagNumber:1},value:Ke.schema().valueBlock.value})]})]}),new k({name:r.onlyContainsUserCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new k({name:r.onlyContainsCACerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new k({name:r.onlySomeReasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:3}}),new k({name:r.indirectCRL||"",optional:!0,idBlock:{tagClass:3,tagNumber:4}}),new k({name:r.onlyContainsAttributeCerts||"",optional:!0,idBlock:{tagClass:3,tagNumber:5}})]})}fromSchema(e){i(e,["distributionPoint","distributionPointNames","onlyContainsUserCerts","onlyContainsCACerts","onlySomeReasons","indirectCRL","onlyContainsAttributeCerts"]);const t=a(e,e,We.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",onlyContainsUserCerts:"onlyContainsUserCerts",onlyContainsCACerts:"onlyContainsCACerts",onlySomeReasons:"onlySomeReasons",indirectCRL:"indirectCRL",onlyContainsAttributeCerts:"onlyContainsAttributeCerts"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for IssuingDistributionPoint");if("distributionPoint"in t.result)switch(!0){case 0===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new Je({schema:e}));break;case 1===t.result.distributionPoint.idBlock.tagNumber:this.distributionPoint=new Ke({schema:new s({value:t.result.distributionPoint.valueBlock.value})});break;default:throw new Error("Unknown tagNumber for distributionPoint: {$asn1.result.distributionPoint.idBlock.tagNumber}")}if("onlyContainsUserCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsUserCerts.valueBlock.valueHex);this.onlyContainsUserCerts=0!==e[0]}if("onlyContainsCACerts"in t.result){const e=new Uint8Array(t.result.onlyContainsCACerts.valueBlock.valueHex);this.onlyContainsCACerts=0!==e[0]}if("onlySomeReasons"in t.result){const e=new Uint8Array(t.result.onlySomeReasons.valueBlock.valueHex);this.onlySomeReasons=e[0]}if("indirectCRL"in t.result){const e=new Uint8Array(t.result.indirectCRL.valueBlock.valueHex);this.indirectCRL=0!==e[0]}if("onlyContainsAttributeCerts"in t.result){const e=new Uint8Array(t.result.onlyContainsAttributeCerts.valueBlock.valueHex);this.onlyContainsAttributeCerts=0!==e[0]}}toSchema(){const e=[];if("distributionPoint"in this){let t;this.distributionPoint instanceof Array?t=new v({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}):(t=this.distributionPoint.toSchema(),t.idBlock.tagClass=3,t.idBlock.tagNumber=1),e.push(new v({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if(this.onlyContainsUserCerts!==We.defaultValues("onlyContainsUserCerts")&&e.push(new k({idBlock:{tagClass:3,tagNumber:1},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsCACerts!==We.defaultValues("onlyContainsCACerts")&&e.push(new k({idBlock:{tagClass:3,tagNumber:2},valueHex:new Uint8Array([255]).buffer})),"onlySomeReasons"in this){const t=new ArrayBuffer(1);new Uint8Array(t)[0]=this.onlySomeReasons,e.push(new k({idBlock:{tagClass:3,tagNumber:3},valueHex:t}))}return this.indirectCRL!==We.defaultValues("indirectCRL")&&e.push(new k({idBlock:{tagClass:3,tagNumber:4},valueHex:new Uint8Array([255]).buffer})),this.onlyContainsAttributeCerts!==We.defaultValues("onlyContainsAttributeCerts")&&e.push(new k({idBlock:{tagClass:3,tagNumber:5},valueHex:new Uint8Array([255]).buffer})),new s({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(e.distributionPoint=this.distributionPoint instanceof Array?Array.from(this.distributionPoint,e=>e.toJSON()):this.distributionPoint.toJSON()),this.onlyContainsUserCerts!==We.defaultValues("onlyContainsUserCerts")&&(e.onlyContainsUserCerts=this.onlyContainsUserCerts),this.onlyContainsCACerts!==We.defaultValues("onlyContainsCACerts")&&(e.onlyContainsCACerts=this.onlyContainsCACerts),"onlySomeReasons"in this&&(e.onlySomeReasons=this.onlySomeReasons),this.indirectCRL!==We.defaultValues("indirectCRL")&&(e.indirectCRL=this.indirectCRL),this.onlyContainsAttributeCerts!==We.defaultValues("onlyContainsAttributeCerts")&&(e.onlyContainsAttributeCerts=this.onlyContainsAttributeCerts),e}}class Qe{constructor(t={}){this.names=e(t,"names",Qe.defaultValues("names")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"names":return[];default:throw new Error("Invalid member name for GeneralNames class: "+e)}}static schema(t={},r=!1){const i=e(t,"names",{});return new s({optional:r,name:i.blockName||"",value:[new g({name:i.generalNames||"",value:Je.schema()})]})}fromSchema(e){i(e,["names","generalNames"]);const t=a(e,e,Qe.schema({names:{blockName:"names",generalNames:"generalNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralNames");this.names=Array.from(t.result.generalNames,e=>new Je({schema:e}))}toSchema(){return new s({value:Array.from(this.names,e=>e.toSchema())})}toJSON(){return{names:Array.from(this.names,e=>e.toJSON())}}}class Ge{constructor(t={}){this.base=e(t,"base",Ge.defaultValues("base")),this.minimum=e(t,"minimum",Ge.defaultValues("minimum")),"maximum"in t&&(this.maximum=e(t,"maximum",Ge.defaultValues("maximum"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"base":return new Je;case"minimum":case"maximum":return 0;default:throw new Error("Invalid member name for GeneralSubtree class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[Je.schema(r.base||{}),new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new w({name:r.minimum||""})]}),new v({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new w({name:r.maximum||""})]})]})}fromSchema(e){i(e,["base","minimum","maximum"]);const t=a(e,e,Ge.schema({names:{base:{names:{blockName:"base"}},minimum:"minimum",maximum:"maximum"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for GeneralSubtree");this.base=new Je({schema:t.result.base}),"minimum"in t.result&&(this.minimum=t.result.minimum.valueBlock.isHexOnly?t.result.minimum:t.result.minimum.valueBlock.valueDec),"maximum"in t.result&&(this.maximum=t.result.maximum.valueBlock.isHexOnly?t.result.maximum:t.result.maximum.valueBlock.valueDec)}toSchema(){const e=[];if(e.push(this.base.toSchema()),0!==this.minimum){let t=0;t=this.minimum instanceof w?this.minimum:new w({value:this.minimum}),e.push(new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[t]}))}if("maximum"in this){let t=0;t=this.maximum instanceof w?this.maximum:new w({value:this.maximum}),e.push(new v({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[t]}))}return new s({value:e})}toJSON(){const e={base:this.base.toJSON()};return 0!==this.minimum&&(e.minimum="number"==typeof this.minimum?this.minimum:this.minimum.toJSON()),"maximum"in this&&(e.maximum="number"==typeof this.maximum?this.maximum:this.maximum.toJSON()),e}}class ze{constructor(t={}){"permittedSubtrees"in t&&(this.permittedSubtrees=e(t,"permittedSubtrees",ze.defaultValues("permittedSubtrees"))),"excludedSubtrees"in t&&(this.excludedSubtrees=e(t,"excludedSubtrees",ze.defaultValues("excludedSubtrees"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"permittedSubtrees":case"excludedSubtrees":return[];default:throw new Error("Invalid member name for NameConstraints class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new g({name:r.permittedSubtrees||"",value:Ge.schema()})]}),new v({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new g({name:r.excludedSubtrees||"",value:Ge.schema()})]})]})}fromSchema(e){i(e,["permittedSubtrees","excludedSubtrees"]);const t=a(e,e,ze.schema({names:{permittedSubtrees:"permittedSubtrees",excludedSubtrees:"excludedSubtrees"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for NameConstraints");"permittedSubtrees"in t.result&&(this.permittedSubtrees=Array.from(t.result.permittedSubtrees,e=>new Ge({schema:e}))),"excludedSubtrees"in t.result&&(this.excludedSubtrees=Array.from(t.result.excludedSubtrees,e=>new Ge({schema:e})))}toSchema(){const e=[];return"permittedSubtrees"in this&&e.push(new v({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.permittedSubtrees,e=>e.toSchema())})),"excludedSubtrees"in this&&e.push(new v({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.excludedSubtrees,e=>e.toSchema())})),new s({value:e})}toJSON(){const e={};return"permittedSubtrees"in this&&(e.permittedSubtrees=Array.from(this.permittedSubtrees,e=>e.toJSON())),"excludedSubtrees"in this&&(e.excludedSubtrees=Array.from(this.excludedSubtrees,e=>e.toJSON())),e}}class $e{constructor(t={}){"distributionPoint"in t&&(this.distributionPoint=e(t,"distributionPoint",$e.defaultValues("distributionPoint"))),"reasons"in t&&(this.reasons=e(t,"reasons",$e.defaultValues("reasons"))),"cRLIssuer"in t&&(this.cRLIssuer=e(t,"cRLIssuer",$e.defaultValues("cRLIssuer"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"distributionPoint":return[];case"reasons":return new d;case"cRLIssuer":return[];default:throw new Error("Invalid member name for DistributionPoint class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new S({value:[new v({name:r.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new g({name:r.distributionPointNames||"",value:Je.schema()})]}),new v({name:r.distributionPoint||"",optional:!0,idBlock:{tagClass:3,tagNumber:1},value:Ke.schema().valueBlock.value})]})]}),new k({name:r.reasons||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new v({name:r.cRLIssuer||"",optional:!0,idBlock:{tagClass:3,tagNumber:2},value:[new g({name:r.cRLIssuerNames||"",value:Je.schema()})]})]})}fromSchema(e){i(e,["distributionPoint","distributionPointNames","reasons","cRLIssuer","cRLIssuerNames"]);const t=a(e,e,$e.schema({names:{distributionPoint:"distributionPoint",distributionPointNames:"distributionPointNames",reasons:"reasons",cRLIssuer:"cRLIssuer",cRLIssuerNames:"cRLIssuerNames"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for DistributionPoint");"distributionPoint"in t.result&&(0===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=Array.from(t.result.distributionPointNames,e=>new Je({schema:e}))),1===t.result.distributionPoint.idBlock.tagNumber&&(this.distributionPoint=new Ke({schema:new s({value:t.result.distributionPoint.valueBlock.value})}))),"reasons"in t.result&&(this.reasons=new d({valueHex:t.result.reasons.valueBlock.valueHex})),"cRLIssuer"in t.result&&(this.cRLIssuer=Array.from(t.result.cRLIssuerNames,e=>new Je({schema:e})))}toSchema(){const e=[];if("distributionPoint"in this){let t;t=new v(this.distributionPoint instanceof Array?{idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.distributionPoint,e=>e.toSchema())}:{idBlock:{tagClass:3,tagNumber:1},value:[this.distributionPoint.toSchema()]}),e.push(new v({idBlock:{tagClass:3,tagNumber:0},value:[t]}))}return"reasons"in this&&e.push(new k({idBlock:{tagClass:3,tagNumber:1},valueHex:this.reasons.valueBlock.valueHex})),"cRLIssuer"in this&&e.push(new v({idBlock:{tagClass:3,tagNumber:2},value:Array.from(this.cRLIssuer,e=>e.toSchema())})),new s({value:e})}toJSON(){const e={};return"distributionPoint"in this&&(e.distributionPoint=this.distributionPoint instanceof Array?Array.from(this.distributionPoint,e=>e.toJSON()):this.distributionPoint.toJSON()),"reasons"in this&&(e.reasons=this.reasons.toJSON()),"cRLIssuer"in this&&(e.cRLIssuer=Array.from(this.cRLIssuer,e=>e.toJSON())),e}}class Xe{constructor(t={}){this.distributionPoints=e(t,"distributionPoints",Xe.defaultValues("distributionPoints")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"distributionPoints":return[];default:throw new Error("Invalid member name for CRLDistributionPoints class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new g({name:r.distributionPoints||"",value:$e.schema()})]})}fromSchema(e){i(e,["distributionPoints"]);const t=a(e,e,Xe.schema({names:{distributionPoints:"distributionPoints"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CRLDistributionPoints");this.distributionPoints=Array.from(t.result.distributionPoints,e=>new $e({schema:e}))}toSchema(){return new s({value:Array.from(this.distributionPoints,e=>e.toSchema())})}toJSON(){return{distributionPoints:Array.from(this.distributionPoints,e=>e.toJSON())}}}class Ye{constructor(t={}){this.policyQualifierId=e(t,"policyQualifierId",Ye.defaultValues("policyQualifierId")),this.qualifier=e(t,"qualifier",Ye.defaultValues("qualifier")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"policyQualifierId":return"";case"qualifier":return new t;default:throw new Error("Invalid member name for PolicyQualifierInfo class: "+e)}}static schema(i={}){const a=e(i,"names",{});return new s({name:a.blockName||"",value:[new r({name:a.policyQualifierId||""}),new t({name:a.qualifier||""})]})}fromSchema(e){i(e,["policyQualifierId","qualifier"]);const t=a(e,e,Ye.schema({names:{policyQualifierId:"policyQualifierId",qualifier:"qualifier"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyQualifierInfo");this.policyQualifierId=t.result.policyQualifierId.valueBlock.toString(),this.qualifier=t.result.qualifier}toSchema(){return new s({value:[new r({value:this.policyQualifierId}),this.qualifier]})}toJSON(){return{policyQualifierId:this.policyQualifierId,qualifier:this.qualifier.toJSON()}}}class Ze{constructor(t={}){this.policyIdentifier=e(t,"policyIdentifier",Ze.defaultValues("policyIdentifier")),"policyQualifiers"in t&&(this.policyQualifiers=e(t,"policyQualifiers",Ze.defaultValues("policyQualifiers"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"policyIdentifier":return"";case"policyQualifiers":return[];default:throw new Error("Invalid member name for PolicyInformation class: "+e)}}static schema(t={}){const i=e(t,"names",{});return new s({name:i.blockName||"",value:[new r({name:i.policyIdentifier||""}),new s({optional:!0,value:[new g({name:i.policyQualifiers||"",value:Ye.schema()})]})]})}fromSchema(e){i(e,["policyIdentifier","policyQualifiers"]);const t=a(e,e,Ze.schema({names:{policyIdentifier:"policyIdentifier",policyQualifiers:"policyQualifiers"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyInformation");this.policyIdentifier=t.result.policyIdentifier.valueBlock.toString(),"policyQualifiers"in t.result&&(this.policyQualifiers=Array.from(t.result.policyQualifiers,e=>new Ye({schema:e})))}toSchema(){const e=[];return e.push(new r({value:this.policyIdentifier})),"policyQualifiers"in this&&e.push(new s({value:Array.from(this.policyQualifiers,e=>e.toSchema())})),new s({value:e})}toJSON(){const e={policyIdentifier:this.policyIdentifier};return"policyQualifiers"in this&&(e.policyQualifiers=Array.from(this.policyQualifiers,e=>e.toJSON())),e}}class et{constructor(t={}){this.certificatePolicies=e(t,"certificatePolicies",et.defaultValues("certificatePolicies")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"certificatePolicies":return[];default:throw new Error("Invalid member name for CertificatePolicies class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new g({name:r.certificatePolicies||"",value:Ze.schema()})]})}fromSchema(e){i(e,["certificatePolicies"]);const t=a(e,e,et.schema({names:{certificatePolicies:"certificatePolicies"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificatePolicies");this.certificatePolicies=Array.from(t.result.certificatePolicies,e=>new Ze({schema:e}))}toSchema(){return new s({value:Array.from(this.certificatePolicies,e=>e.toSchema())})}toJSON(){return{certificatePolicies:Array.from(this.certificatePolicies,e=>e.toJSON())}}}class tt{constructor(t={}){this.issuerDomainPolicy=e(t,"issuerDomainPolicy",tt.defaultValues("issuerDomainPolicy")),this.subjectDomainPolicy=e(t,"subjectDomainPolicy",tt.defaultValues("subjectDomainPolicy")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"issuerDomainPolicy":case"subjectDomainPolicy":return"";default:throw new Error("Invalid member name for PolicyMapping class: "+e)}}static schema(t={}){const i=e(t,"names",{});return new s({name:i.blockName||"",value:[new r({name:i.issuerDomainPolicy||""}),new r({name:i.subjectDomainPolicy||""})]})}fromSchema(e){i(e,["issuerDomainPolicy","subjectDomainPolicy"]);const t=a(e,e,tt.schema({names:{issuerDomainPolicy:"issuerDomainPolicy",subjectDomainPolicy:"subjectDomainPolicy"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMapping");this.issuerDomainPolicy=t.result.issuerDomainPolicy.valueBlock.toString(),this.subjectDomainPolicy=t.result.subjectDomainPolicy.valueBlock.toString()}toSchema(){return new s({value:[new r({value:this.issuerDomainPolicy}),new r({value:this.subjectDomainPolicy})]})}toJSON(){return{issuerDomainPolicy:this.issuerDomainPolicy,subjectDomainPolicy:this.subjectDomainPolicy}}}class st{constructor(t={}){this.mappings=e(t,"mappings",st.defaultValues("mappings")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"mappings":return[];default:throw new Error("Invalid member name for PolicyMappings class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new g({name:r.mappings||"",value:tt.schema()})]})}fromSchema(e){i(e,["mappings"]);const t=a(e,e,st.schema({names:{mappings:"mappings"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyMappings");this.mappings=Array.from(t.result.mappings,e=>new tt({schema:e}))}toSchema(){return new s({value:Array.from(this.mappings,e=>e.toSchema())})}toJSON(){return{mappings:Array.from(this.mappings,e=>e.toJSON())}}}class rt{constructor(t={}){"keyIdentifier"in t&&(this.keyIdentifier=e(t,"keyIdentifier",rt.defaultValues("keyIdentifier"))),"authorityCertIssuer"in t&&(this.authorityCertIssuer=e(t,"authorityCertIssuer",rt.defaultValues("authorityCertIssuer"))),"authorityCertSerialNumber"in t&&(this.authorityCertSerialNumber=e(t,"authorityCertSerialNumber",rt.defaultValues("authorityCertSerialNumber"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"keyIdentifier":return new A;case"authorityCertIssuer":return[];case"authorityCertSerialNumber":return new w;default:throw new Error("Invalid member name for AuthorityKeyIdentifier class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new k({name:r.keyIdentifier||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new v({optional:!0,idBlock:{tagClass:3,tagNumber:1},value:[new g({name:r.authorityCertIssuer||"",value:Je.schema()})]}),new k({name:r.authorityCertSerialNumber||"",optional:!0,idBlock:{tagClass:3,tagNumber:2}})]})}fromSchema(e){i(e,["keyIdentifier","authorityCertIssuer","authorityCertSerialNumber"]);const t=a(e,e,rt.schema({names:{keyIdentifier:"keyIdentifier",authorityCertIssuer:"authorityCertIssuer",authorityCertSerialNumber:"authorityCertSerialNumber"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AuthorityKeyIdentifier");"keyIdentifier"in t.result&&(this.keyIdentifier=new A({valueHex:t.result.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in t.result&&(this.authorityCertIssuer=Array.from(t.result.authorityCertIssuer,e=>new Je({schema:e}))),"authorityCertSerialNumber"in t.result&&(this.authorityCertSerialNumber=new w({valueHex:t.result.authorityCertSerialNumber.valueBlock.valueHex}))}toSchema(){const e=[];return"keyIdentifier"in this&&e.push(new k({idBlock:{tagClass:3,tagNumber:0},valueHex:this.keyIdentifier.valueBlock.valueHex})),"authorityCertIssuer"in this&&e.push(new v({idBlock:{tagClass:3,tagNumber:1},value:Array.from(this.authorityCertIssuer,e=>e.toSchema())})),"authorityCertSerialNumber"in this&&e.push(new k({idBlock:{tagClass:3,tagNumber:2},valueHex:this.authorityCertSerialNumber.valueBlock.valueHex})),new s({value:e})}toJSON(){const e={};return"keyIdentifier"in this&&(e.keyIdentifier=this.keyIdentifier.toJSON()),"authorityCertIssuer"in this&&(e.authorityCertIssuer=Array.from(this.authorityCertIssuer,e=>e.toJSON())),"authorityCertSerialNumber"in this&&(e.authorityCertSerialNumber=this.authorityCertSerialNumber.toJSON()),e}}class it{constructor(t={}){"requireExplicitPolicy"in t&&(this.requireExplicitPolicy=e(t,"requireExplicitPolicy",it.defaultValues("requireExplicitPolicy"))),"inhibitPolicyMapping"in t&&(this.inhibitPolicyMapping=e(t,"inhibitPolicyMapping",it.defaultValues("inhibitPolicyMapping"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"requireExplicitPolicy":case"inhibitPolicyMapping":return 0;default:throw new Error("Invalid member name for PolicyConstraints class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new k({name:r.requireExplicitPolicy||"",optional:!0,idBlock:{tagClass:3,tagNumber:0}}),new k({name:r.inhibitPolicyMapping||"",optional:!0,idBlock:{tagClass:3,tagNumber:1}})]})}fromSchema(e){i(e,["requireExplicitPolicy","inhibitPolicyMapping"]);const t=a(e,e,it.schema({names:{requireExplicitPolicy:"requireExplicitPolicy",inhibitPolicyMapping:"inhibitPolicyMapping"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for PolicyConstraints");if("requireExplicitPolicy"in t.result){const e=t.result.requireExplicitPolicy;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const s=e.toBER(!1),r=y(s);this.requireExplicitPolicy=r.result.valueBlock.valueDec}if("inhibitPolicyMapping"in t.result){const e=t.result.inhibitPolicyMapping;e.idBlock.tagClass=1,e.idBlock.tagNumber=2;const s=e.toBER(!1),r=y(s);this.inhibitPolicyMapping=r.result.valueBlock.valueDec}}toSchema(){const e=[];if("requireExplicitPolicy"in this){const t=new w({value:this.requireExplicitPolicy});t.idBlock.tagClass=3,t.idBlock.tagNumber=0,e.push(t)}if("inhibitPolicyMapping"in this){const t=new w({value:this.inhibitPolicyMapping});t.idBlock.tagClass=3,t.idBlock.tagNumber=1,e.push(t)}return new s({value:e})}toJSON(){const e={};return"requireExplicitPolicy"in this&&(e.requireExplicitPolicy=this.requireExplicitPolicy),"inhibitPolicyMapping"in this&&(e.inhibitPolicyMapping=this.inhibitPolicyMapping),e}}class at{constructor(t={}){this.keyPurposes=e(t,"keyPurposes",at.defaultValues("keyPurposes")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"keyPurposes":return[];default:throw new Error("Invalid member name for ExtKeyUsage class: "+e)}}static schema(t={}){const i=e(t,"names",{});return new s({name:i.blockName||"",value:[new g({name:i.keyPurposes||"",value:new r})]})}fromSchema(e){i(e,["keyPurposes"]);const t=a(e,e,at.schema({names:{keyPurposes:"keyPurposes"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for ExtKeyUsage");this.keyPurposes=Array.from(t.result.keyPurposes,e=>e.valueBlock.toString())}toSchema(){return new s({value:Array.from(this.keyPurposes,e=>new r({value:e}))})}toJSON(){return{keyPurposes:Array.from(this.keyPurposes)}}}class nt{constructor(t={}){this.accessMethod=e(t,"accessMethod",nt.defaultValues("accessMethod")),this.accessLocation=e(t,"accessLocation",nt.defaultValues("accessLocation")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"accessMethod":return"";case"accessLocation":return new Je;default:throw new Error("Invalid member name for AccessDescription class: "+e)}}static schema(t={}){const i=e(t,"names",{});return new s({name:i.blockName||"",value:[new r({name:i.accessMethod||""}),Je.schema(i.accessLocation||{})]})}fromSchema(e){i(e,["accessMethod","accessLocation"]);const t=a(e,e,nt.schema({names:{accessMethod:"accessMethod",accessLocation:{names:{blockName:"accessLocation"}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for AccessDescription");this.accessMethod=t.result.accessMethod.valueBlock.toString(),this.accessLocation=new Je({schema:t.result.accessLocation})}toSchema(){return new s({value:[new r({value:this.accessMethod}),this.accessLocation.toSchema()]})}toJSON(){return{accessMethod:this.accessMethod,accessLocation:this.accessLocation.toJSON()}}}class ot{constructor(t={}){this.accessDescriptions=e(t,"accessDescriptions",ot.defaultValues("accessDescriptions")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"accessDescriptions":return[];default:throw new Error("Invalid member name for InfoAccess class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new g({name:r.accessDescriptions||"",value:nt.schema()})]})}fromSchema(e){i(e,["accessDescriptions"]);const t=a(e,e,ot.schema({names:{accessDescriptions:"accessDescriptions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for InfoAccess");this.accessDescriptions=Array.from(t.result.accessDescriptions,e=>new nt({schema:e}))}toSchema(){return new s({value:Array.from(this.accessDescriptions,e=>e.toSchema())})}toJSON(){return{accessDescriptions:Array.from(this.accessDescriptions,e=>e.toJSON())}}}class ct{constructor(e={}){this.clear();for(const t of Object.keys(e))switch(t){case"length":this.length=e.length;break;case"stub":for(let t=0;t<this._view.length;t++)this._view[t]=e.stub;break;case"view":this.fromUint8Array(e.view);break;case"buffer":this.fromArrayBuffer(e.buffer);break;case"string":this.fromString(e.string);break;case"hexstring":this.fromHexString(e.hexstring)}}set buffer(e){this._buffer=e.slice(0),this._view=new Uint8Array(this._buffer)}get buffer(){return this._buffer}set view(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}get view(){return this._view}get length(){return this._buffer.byteLength}set length(e){this._buffer=new ArrayBuffer(e),this._view=new Uint8Array(this._buffer)}clear(){this._buffer=new ArrayBuffer(0),this._view=new Uint8Array(this._buffer)}fromArrayBuffer(e){this.buffer=e}fromUint8Array(e){this._buffer=new ArrayBuffer(e.length),this._view=new Uint8Array(this._buffer),this._view.set(e)}fromString(e){const t=e.length;this.length=t;for(let s=0;s<t;s++)this.view[s]=e.charCodeAt(s)}toString(e=0,t=this.view.length-e){let s="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let r=e;r<e+t;r++)s+=String.fromCharCode(this.view[r]);return s}fromHexString(e){const t=e.length;this.buffer=new ArrayBuffer(t>>1),this.view=new Uint8Array(this.buffer);const s=new Map;s.set("0",0),s.set("1",1),s.set("2",2),s.set("3",3),s.set("4",4),s.set("5",5),s.set("6",6),s.set("7",7),s.set("8",8),s.set("9",9),s.set("A",10),s.set("a",10),s.set("B",11),s.set("b",11),s.set("C",12),s.set("c",12),s.set("D",13),s.set("d",13),s.set("E",14),s.set("e",14),s.set("F",15),s.set("f",15);let r=0,i=0;for(let a=0;a<t;a++)a%2?(i|=s.get(e.charAt(a)),this.view[r]=i,r++):i=s.get(e.charAt(a))<<4}toHexString(e=0,t=this.view.length-e){let s="";(e>=this.view.length||e<0)&&(e=0),(t>=this.view.length||t<0)&&(t=this.view.length-e);for(let r=e;r<e+t;r++){const e=this.view[r].toString(16).toUpperCase();s=s+(1==e.length?"0":"")+e}return s}copy(e=0,t=this._buffer.byteLength-e){if(0===e&&0===this._buffer.byteLength)return new ct;if(e<0||e>this._buffer.byteLength-1)throw new Error("Wrong start position: "+e);const s=new ct;return s._buffer=this._buffer.slice(e,e+t),s._view=new Uint8Array(s._buffer),s}slice(e=0,t=this._buffer.byteLength){if(0===e&&0===this._buffer.byteLength)return new ct;if(e<0||e>this._buffer.byteLength-1)throw new Error("Wrong start position: "+e);const s=new ct;return s._buffer=this._buffer.slice(e,t),s._view=new Uint8Array(s._buffer),s}realloc(e){const t=new ArrayBuffer(e);new Uint8Array(t).set(e>this._view.length?this._view:new Uint8Array(this._buffer,0,e)),this._buffer=t.slice(0),this._view=new Uint8Array(this._buffer)}append(e){const t=this._buffer.byteLength,s=e._buffer.byteLength,r=e._view.slice();this.realloc(t+s),this._view.set(r,t)}insert(e,t=0,s=this._buffer.byteLength-t){return!(t>this._buffer.byteLength-1||(s>this._buffer.byteLength-t&&(s=this._buffer.byteLength-t),s>e._buffer.byteLength&&(s=e._buffer.byteLength),this._view.set(s==e._buffer.byteLength?e._view:e._view.slice(0,s),t),0))}isEqual(e){if(this._buffer.byteLength!=e._buffer.byteLength)return!1;for(let t=0;t<e._buffer.byteLength;t++)if(this.view[t]!=e.view[t])return!1;return!0}isEqualView(e){if(e.length!=this.view.length)return!1;for(let t=0;t<e.length;t++)if(this.view[t]!=e[t])return!1;return!0}findPattern(e,t=null,s=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==s&&(s=t),s>t&&(s=t)):(null==s&&(s=this.buffer.byteLength-t),s>this.buffer.byteLength-t&&(s=this.buffer.byteLength-t));const i=e.buffer.byteLength;if(i>s)return-1;const a=[];for(let n=0;n<i;n++)a.push(e.view[n]);for(let n=0;n<=s-i;n++){let e=!0;const s=r?t-i-n:t+n;for(let t=0;t<i;t++)if(this.view[t+s]!=a[t]){e=!1;break}if(e)return r?t-i-n:t+i+n}return-1}findFirstIn(e,t=null,s=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==s&&(s=t),s>t&&(s=t)):(null==s&&(s=this.buffer.byteLength-t),s>this.buffer.byteLength-t&&(s=this.buffer.byteLength-t));const i={id:-1,position:r?0:t+s,length:0};for(let a=0;a<e.length;a++){const n=this.findPattern(e[a],t,s,r);if(-1!=n){let t=!1;const s=e[a].length;r?n-s>=i.position-i.length&&(t=!0):n-s<=i.position-i.length&&(t=!0),t&&(i.position=n,i.id=a,i.length=s)}}return i}findAllIn(e,t=0,s=this.buffer.byteLength-t){const r=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return r;null==s&&(s=this.buffer.byteLength-t),s>this.buffer.byteLength-t&&(s=this.buffer.byteLength-t);let i={id:-1,position:t};for(;;){const t=i.position;if(i=this.findFirstIn(e,i.position,s),-1==i.id)break;s-=i.position-t,r.push({id:i.id,position:i.position})}return r}findAllPatternIn(e,t=0,s=this.buffer.byteLength-t){null==t&&(t=0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),null==s&&(s=this.buffer.byteLength-t),s>this.buffer.byteLength-t&&(s=this.buffer.byteLength-t);const r=[],i=e.buffer.byteLength;if(i>s)return-1;const a=Array.from(e.view);for(let n=0;n<=s-i;n++){let e=!0;const s=t+n;for(let t=0;t<i;t++)if(this.view[t+s]!=a[t]){e=!1;break}e&&(r.push(t+i+n),n+=i-1)}return r}findFirstNotIn(e,t=null,s=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==s&&(s=t),s>t&&(s=t)):(null==s&&(s=this.buffer.byteLength-t),s>this.buffer.byteLength-t&&(s=this.buffer.byteLength-t));const i={left:{id:-1,position:t},right:{id:-1,position:0},value:new ct};let a=s;for(;a>0;){if(i.right=this.findFirstIn(e,r?t-s+a:t+s-a,a,r),-1==i.right.id){s=a,r?t-=s:t=i.left.position,i.value=new ct,i.value._buffer=this._buffer.slice(t,t+s),i.value._view=new Uint8Array(i.value._buffer);break}if(i.right.position!=(r?i.left.position-e[i.right.id].buffer.byteLength:i.left.position+e[i.right.id].buffer.byteLength)){r?(t=i.right.position+e[i.right.id].buffer.byteLength,s=i.left.position-i.right.position-e[i.right.id].buffer.byteLength):(t=i.left.position,s=i.right.position-i.left.position-e[i.right.id].buffer.byteLength),i.value=new ct,i.value._buffer=this._buffer.slice(t,t+s),i.value._view=new Uint8Array(i.value._buffer);break}i.left=i.right,a-=e[i.right.id]._buffer.byteLength}if(r){const e=i.right;i.right=i.left,i.left=e}return i}findAllNotIn(e,t=null,s=null){const r=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return r;null==s&&(s=this.buffer.byteLength-t),s>this.buffer.byteLength-t&&(s=this.buffer.byteLength-t);let i={left:{id:-1,position:t},right:{id:-1,position:t},value:new ct};do{const t=i.right.position;i=this.findFirstNotIn(e,i.right.position,s),s-=i.right.position-t,r.push({left:{id:i.left.id,position:i.left.position},right:{id:i.right.id,position:i.right.position},value:i.value})}while(-1!=i.right.id);return r}findFirstSequence(e,t=null,s=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==s&&(s=t),s>t&&(s=t)):(null==s&&(s=this.buffer.byteLength-t),s>this.buffer.byteLength-t&&(s=this.buffer.byteLength-t));const i=this.skipNotPatterns(e,t,s,r);if(-1==i)return{position:-1,value:new ct};const a=this.skipPatterns(e,i,s-(r?t-i:i-t),r);r?(t=a,s=i-a):(t=i,s=a-i);const n=new ct;return n._buffer=this._buffer.slice(t,t+s),n._view=new Uint8Array(n._buffer),{position:a,value:n}}findAllSequences(e,t=null,s=null){const r=[];if(null==t&&(t=0),t>this.buffer.byteLength-1)return r;null==s&&(s=this.buffer.byteLength-t),s>this.buffer.byteLength-t&&(s=this.buffer.byteLength-t);let i={position:t,value:new ct};do{const t=i.position;i=this.findFirstSequence(e,i.position,s),-1!=i.position&&(s-=i.position-t,r.push({position:i.position,value:i.value}))}while(-1!=i.position);return r}findPairedPatterns(e,t,s=null,r=null){const i=[];if(e.isEqual(t))return i;if(null==s&&(s=0),s>this.buffer.byteLength-1)return i;null==r&&(r=this.buffer.byteLength-s),r>this.buffer.byteLength-s&&(r=this.buffer.byteLength-s);let a=0;const n=this.findAllPatternIn(e,s,r);if(0==n.length)return i;const o=this.findAllPatternIn(t,s,r);if(0==o.length)return i;for(;a<n.length&&0!=o.length;)if(n[0]!=o[0]){if(n[a]>o[0])break;for(;n[a]<o[0]&&(a++,!(a>=n.length)););i.push({left:n[a-1],right:o[0]}),n.splice(a-1,1),o.splice(0,1),a=0}else i.push({left:n[0],right:o[0]}),n.splice(0,1),o.splice(0,1);return i.sort((e,t)=>e.left-t.left),i}findPairedArrays(e,t,s=null,r=null){const i=[];if(null==s&&(s=0),s>this.buffer.byteLength-1)return i;null==r&&(r=this.buffer.byteLength-s),r>this.buffer.byteLength-s&&(r=this.buffer.byteLength-s);let a=0;const n=this.findAllIn(e,s,r);if(0==n.length)return i;const o=this.findAllIn(t,s,r);if(0==o.length)return i;for(;a<n.length&&0!=o.length;)if(n[0].position!=o[0].position){if(n[a].position>o[0].position)break;for(;n[a].position<o[0].position&&(a++,!(a>=n.length)););i.push({left:n[a-1],right:o[0]}),n.splice(a-1,1),o.splice(0,1),a=0}else i.push({left:n[0],right:o[0]}),n.splice(0,1),o.splice(0,1);return i.sort((e,t)=>e.left.position-t.left.position),i}replacePattern(e,t,s=null,r=null,i=null){let a,n;const o={status:-1,searchPatternPositions:[],replacePatternPositions:[]};if(null==s&&(s=0),s>this.buffer.byteLength-1)return!1;if(null==r&&(r=this.buffer.byteLength-s),r>this.buffer.byteLength-s&&(r=this.buffer.byteLength-s),null==i){if(a=this.findAllIn([e],s,r),0==a.length)return o}else a=i;o.searchPatternPositions.push(...Array.from(a,e=>e.position));const c=e.buffer.byteLength-t.buffer.byteLength,h=new ArrayBuffer(this.view.length-a.length*c),u=new Uint8Array(h);for(u.set(new Uint8Array(this.buffer,0,s)),n=0;n<a.length;n++){const r=0==n?s:a[n-1].position;u.set(new Uint8Array(this.buffer,r,a[n].position-e.buffer.byteLength-r),r-n*c),u.set(t.view,a[n].position-e.buffer.byteLength-n*c),o.replacePatternPositions.push(a[n].position-e.buffer.byteLength-n*c)}return n--,u.set(new Uint8Array(this.buffer,a[n].position,this.buffer.byteLength-a[n].position),a[n].position-e.buffer.byteLength+t.buffer.byteLength-n*c),this.buffer=h,this.view=new Uint8Array(this.buffer),o.status=1,o}skipPatterns(e,t=null,s=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==s&&(s=t),s>t&&(s=t)):(null==s&&(s=this.buffer.byteLength-t),s>this.buffer.byteLength-t&&(s=this.buffer.byteLength-t));let i=t;for(let a=0;a<e.length;a++){const n=e[a].buffer.byteLength,o=r?i-n:i;let c=!0;for(let t=0;t<n;t++)if(this.view[t+o]!=e[a].view[t]){c=!1;break}if(c)if(a=-1,r){if(i-=n,i<=0)return i}else if(i+=n,i>=t+s)return i}return i}skipNotPatterns(e,t=null,s=null,r=!1){null==t&&(t=r?this.buffer.byteLength:0),t>this.buffer.byteLength&&(t=this.buffer.byteLength),r?(null==s&&(s=t),s>t&&(s=t)):(null==s&&(s=this.buffer.byteLength-t),s>this.buffer.byteLength-t&&(s=this.buffer.byteLength-t));let i=-1;for(let a=0;a<s;a++){for(let s=0;s<e.length;s++){const n=e[s].buffer.byteLength,o=r?t-a-n:t+a;let c=!0;for(let t=0;t<n;t++)if(this.view[t+o]!=e[s].view[t]){c=!1;break}if(c){i=r?t-a:t+a;break}}if(-1!=i)break}return i}}class ht{constructor(e={}){this.stream=new ct,this._length=0,this.backward=!1,this._start=0,this.appendBlock=0,this.prevLength=0,this.prevStart=0;for(const t of Object.keys(e))switch(t){case"stream":this.stream=e.stream;break;case"backward":this.backward=e.backward,this._start=this.stream.buffer.byteLength;break;case"length":this._length=e.length;break;case"start":this._start=e.start;break;case"appendBlock":this.appendBlock=e.appendBlock;break;case"view":this.stream=new ct({view:e.view});break;case"buffer":this.stream=new ct({buffer:e.buffer});break;case"string":this.stream=new ct({string:e.string});break;case"hexstring":this.stream=new ct({hexstring:e.hexstring})}}set stream(e){this._stream=e,this.prevLength=this._length,this._length=e._buffer.byteLength,this.prevStart=this._start,this._start=0}get stream(){return this._stream}set length(e){this.prevLength=this._length,this._length=e}get length(){return this.appendBlock?this.start:this._length}set start(e){e>this.stream.buffer.byteLength||(this.prevStart=this._start,this.prevLength=this._length,this._length-=this.backward?this._start-e:e-this._start,this._start=e)}get start(){return this._start}get buffer(){return this._stream._buffer.slice(0,this._length)}resetPosition(){this._start=this.prevStart,this._length=this.prevLength}findPattern(e,t=null){(null==t||t>this.length)&&(t=this.length);const s=this.stream.findPattern(e,this.start,this.length,this.backward);if(-1==s)return s;if(this.backward){if(s<this.start-e.buffer.byteLength-t)return-1}else if(s>this.start+e.buffer.byteLength+t)return-1;return this.start=s,s}findFirstIn(e,t=null){(null==t||t>this.length)&&(t=this.length);const s=this.stream.findFirstIn(e,this.start,this.length,this.backward);if(-1==s.id)return s;if(this.backward){if(s.position<this.start-e[s.id].buffer.byteLength-t)return{id:-1,position:this.backward?0:this.start+this.length}}else if(s.position>this.start+e[s.id].buffer.byteLength+t)return{id:-1,position:this.backward?0:this.start+this.length};return this.start=s.position,s}findAllIn(e){return this.stream.findAllIn(e,this.backward?this.start-this.length:this.start,this.length)}findFirstNotIn(e,t=null){(null==t||t>this._length)&&(t=this._length);const s=this._stream.findFirstNotIn(e,this._start,this._length,this.backward);if(-1==s.left.id&&-1==s.right.id)return s;if(this.backward){if(-1!=s.right.id&&s.right.position<this._start-e[s.right.id]._buffer.byteLength-t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new ct}}else if(-1!=s.left.id&&s.left.position>this._start+e[s.left.id]._buffer.byteLength+t)return{left:{id:-1,position:this._start},right:{id:-1,position:0},value:new ct};return this.start=this.backward?-1==s.left.id?0:s.left.position:-1==s.right.id?this._start+this._length:s.right.position,s}findAllNotIn(e){return this._stream.findAllNotIn(e,this.backward?this._start-this._length:this._start,this._length)}findFirstSequence(e,t=null,s=null){(null==t||t>this._length)&&(t=this._length),(null==s||s>t)&&(s=t);const r=this._stream.findFirstSequence(e,this._start,t,this.backward);if(0==r.value.buffer.byteLength)return r;if(this.backward){if(r.position<this._start-r.value._buffer.byteLength-s)return{position:-1,value:new ct}}else if(r.position>this._start+r.value._buffer.byteLength+s)return{position:-1,value:new ct};return this.start=r.position,r}findAllSequences(e){return this.stream.findAllSequences(e,this.backward?this.start-this.length:this.start,this.length)}findPairedPatterns(e,t,s=null){(null==s||s>this.length)&&(s=this.length);const r=this.stream.findPairedPatterns(e,t,this.backward?this.start-this.length:this.start,this.length);if(r.length)if(this.backward){if(r[0].right<this.start-t.buffer.byteLength-s)return[]}else if(r[0].left>this.start+e.buffer.byteLength+s)return[];return r}findPairedArrays(e,t,s=null){(null==s||s>this.length)&&(s=this.length);const r=this.stream.findPairedArrays(e,t,this.backward?this.start-this.length:this.start,this.length);if(r.length)if(this.backward){if(r[0].right.position<this.start-t[r[0].right.id].buffer.byteLength-s)return[]}else if(r[0].left.position>this.start+e[r[0].left.id].buffer.byteLength+s)return[];return r}replacePattern(e,t){return this.stream.replacePattern(e,t,this.backward?this.start-this.length:this.start,this.length)}skipPatterns(e){const t=this.stream.skipPatterns(e,this.start,this.length,this.backward);return this.start=t,t}skipNotPatterns(e){const t=this.stream.skipNotPatterns(e,this.start,this.length,this.backward);return-1==t?-1:(this.start=t,t)}append(e){this._start+e._buffer.byteLength>this._stream._buffer.byteLength&&(e._buffer.byteLength>this.appendBlock&&(this.appendBlock=e._buffer.byteLength+1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view.set(e._view,this._start),this._length+=2*e._buffer.byteLength,this.start=this._start+e._buffer.byteLength,this.prevLength-=2*e._buffer.byteLength}appendView(e){this._start+e.length>this._stream._buffer.byteLength&&(e.length>this.appendBlock&&(this.appendBlock=e.length+1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view.set(e,this._start),this._length+=2*e.length,this.start=this._start+e.length,this.prevLength-=2*e.length}appendChar(e){this._start+1>this._stream._buffer.byteLength&&(1>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock)),this._stream._view[this._start]=e,this._length+=2,this.start=this._start+1,this.prevLength-=2}appendUint16(e){this._start+2>this._stream._buffer.byteLength&&(2>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint16Array([e]),s=new Uint8Array(t.buffer);this._stream._view[this._start]=s[1],this._stream._view[this._start+1]=s[0],this._length+=4,this.start=this._start+2,this.prevLength-=4}appendUint24(e){this._start+3>this._stream._buffer.byteLength&&(3>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint32Array([e]),s=new Uint8Array(t.buffer);this._stream._view[this._start]=s[2],this._stream._view[this._start+1]=s[1],this._stream._view[this._start+2]=s[0],this._length+=6,this.start=this._start+3,this.prevLength-=6}appendUint32(e){this._start+4>this._stream._buffer.byteLength&&(4>this.appendBlock&&(this.appendBlock=1e3),this._stream.realloc(this._stream._buffer.byteLength+this.appendBlock));const t=new Uint32Array([e]),s=new Uint8Array(t.buffer);this._stream._view[this._start]=s[3],this._stream._view[this._start+1]=s[2],this._stream._view[this._start+2]=s[1],this._stream._view[this._start+3]=s[0],this._length+=8,this.start=this._start+4,this.prevLength-=8}getBlock(e,t=!0){if(this._length<=0)return[];let s;if(this._length<e&&(e=this._length),this.backward){const t=this._stream._buffer.slice(this._length-e,this._length),r=new Uint8Array(t);s=new Array(e);for(let i=0;i<e;i++)s[e-1-i]=r[i]}else{const t=this._stream._buffer.slice(this._start,this._start+e);s=Array.from(new Uint8Array(t))}return t&&(this.start+=this.backward?-1*e:e),s}getUint16(e=!0){const t=this.getBlock(2,e);if(t.length<2)return 0;const s=new Uint16Array(1),r=new Uint8Array(s.buffer);return r[0]=t[1],r[1]=t[0],s[0]}getInt16(e=!0){const t=this.getBlock(2,e);if(t.length<2)return 0;const s=new Int16Array(1),r=new Uint8Array(s.buffer);return r[0]=t[1],r[1]=t[0],s[0]}getUint24(e=!0){const t=this.getBlock(3,e);if(t.length<3)return 0;const s=new Uint32Array(1),r=new Uint8Array(s.buffer);for(let i=3;i>=1;i--)r[3-i]=t[i-1];return s[0]}getUint32(e=!0){const t=this.getBlock(4,e);if(t.length<4)return 0;const s=new Uint32Array(1),r=new Uint8Array(s.buffer);for(let i=3;i>=0;i--)r[3-i]=t[i];return s[0]}getInt32(e=!0){const t=this.getBlock(4,e);if(t.length<4)return 0;const s=new Int32Array(1),r=new Uint8Array(s.buffer);for(let i=3;i>=0;i--)r[3-i]=t[i];return s[0]}}class ut{constructor(t={}){this.version=e(t,"version",ut.defaultValues("version")),this.logID=e(t,"logID",ut.defaultValues("logID")),this.timestamp=e(t,"timestamp",ut.defaultValues("timestamp")),this.extensions=e(t,"extensions",ut.defaultValues("extensions")),this.hashAlgorithm=e(t,"hashAlgorithm",ut.defaultValues("hashAlgorithm")),this.signatureAlgorithm=e(t,"signatureAlgorithm",ut.defaultValues("signatureAlgorithm")),this.signature=e(t,"signature",ut.defaultValues("signature")),"schema"in t&&this.fromSchema(t.schema),"stream"in t&&this.fromStream(t.stream)}static defaultValues(e){switch(e){case"version":return 0;case"logID":case"extensions":return new ArrayBuffer(0);case"timestamp":return new Date(0);case"hashAlgorithm":case"signatureAlgorithm":return"";case"signature":return new t;default:throw new Error("Invalid member name for SignedCertificateTimestamp class: "+e)}}fromSchema(e){if(e instanceof o==0)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestamp");const t=new ht({stream:new ct({buffer:e.data})});this.fromStream(t)}fromStream(e){const t=e.getUint16();if(this.version=e.getBlock(1)[0],0===this.version){this.logID=new Uint8Array(e.getBlock(32)).buffer.slice(0),this.timestamp=new Date(M(new Uint8Array(e.getBlock(8)),8));const s=e.getUint16();switch(this.extensions=new Uint8Array(e.getBlock(s)).buffer.slice(0),e.getBlock(1)[0]){case 0:this.hashAlgorithm="none";break;case 1:this.hashAlgorithm="md5";break;case 2:this.hashAlgorithm="sha1";break;case 3:this.hashAlgorithm="sha224";break;case 4:this.hashAlgorithm="sha256";break;case 5:this.hashAlgorithm="sha384";break;case 6:this.hashAlgorithm="sha512";break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}switch(e.getBlock(1)[0]){case 0:this.signatureAlgorithm="anonymous";break;case 1:this.signatureAlgorithm="rsa";break;case 2:this.signatureAlgorithm="dsa";break;case 3:this.signatureAlgorithm="ecdsa";break;default:throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}const r=e.getUint16(),i=new Uint8Array(e.getBlock(r)).buffer.slice(0),a=y(i);if(-1===a.offset)throw new Error("Object's stream was not correct for SignedCertificateTimestamp");if(this.signature=a.result,t!==47+s+r)throw new Error("Object's stream was not correct for SignedCertificateTimestamp")}}toSchema(){const e=this.toStream();return new o({data:e.stream.buffer})}toStream(){const e=new ht;e.appendUint16(47+this.extensions.byteLength+this.signature.valueBeforeDecode.byteLength),e.appendChar(this.version),e.appendView(new Uint8Array(this.logID));const t=new ArrayBuffer(8),s=new Uint8Array(t),r=L(this.timestamp.valueOf(),8);let i,a;switch(s.set(new Uint8Array(r),8-r.byteLength),e.appendView(s),e.appendUint16(this.extensions.byteLength),this.extensions.byteLength&&e.appendView(new Uint8Array(this.extensions)),this.hashAlgorithm.toLowerCase()){case"none":i=0;break;case"md5":i=1;break;case"sha1":i=2;break;case"sha224":i=3;break;case"sha256":i=4;break;case"sha384":i=5;break;case"sha512":i=6;break;default:throw new Error("Incorrect data for hashAlgorithm: "+this.hashAlgorithm)}switch(e.appendChar(i),this.signatureAlgorithm.toLowerCase()){case"anonymous":a=0;break;case"rsa":a=1;break;case"dsa":a=2;break;case"ecdsa":a=3;break;default:throw new Error("Incorrect data for signatureAlgorithm: "+this.signatureAlgorithm)}e.appendChar(a);const n=this.signature.toBER(!1);return e.appendUint16(n.byteLength),e.appendView(new Uint8Array(n)),e}toJSON(){return{version:this.version,logID:T(this.logID),timestamp:this.timestamp,extensions:T(this.extensions),hashAlgorithm:this.hashAlgorithm,signatureAlgorithm:this.signatureAlgorithm,signature:this.signature.toJSON()}}async verify(e,t,s=0){let r,i=h(u(this.logID)),a=null,n=new ht;for(const h of e)if(h.log_id===i){a=h.key;break}if(null===a)throw new Error("Public key not found for CT with logId: "+i);const o=y(l(m(a)));if(-1===o.offset)throw new Error("Incorrect key value for CT Log with logId: "+i);r=new be({schema:o.result}),n.appendChar(0),n.appendChar(0);const c=new ArrayBuffer(8),w=new Uint8Array(c),f=L(this.timestamp.valueOf(),8);return w.set(new Uint8Array(f),8-f.byteLength),n.appendView(w),n.appendUint16(s),0===s&&n.appendUint24(t.byteLength),n.appendView(new Uint8Array(t)),n.appendUint16(this.extensions.byteLength),0!==this.extensions.byteLength&&n.appendView(new Uint8Array(this.extensions)),He().subtle.verifyWithPublicKey(n._stream._buffer.slice(0,n._length),{valueBlock:{valueHex:this.signature.toBER(!1)}},r,{algorithmId:""},"SHA-256")}}class lt{constructor(t={}){this.timestamps=e(t,"timestamps",lt.defaultValues("timestamps")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"timestamps":return[];default:throw new Error("Invalid member name for SignedCertificateTimestampList class: "+e)}}static compareWithDefault(e,t){switch(e){case"timestamps":return 0===t.length;default:throw new Error("Invalid member name for SignedCertificateTimestampList class: "+e)}}static schema(t={}){const s=e(t,"names",{});return"optional"in s==0&&(s.optional=!1),new A({name:s.blockName||"SignedCertificateTimestampList",optional:s.optional})}fromSchema(e){if(e instanceof A==0)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");const t=new ht({stream:new ct({buffer:e.valueBlock.valueHex})});if(t.getUint16()!==t.length)throw new Error("Object's schema was not verified against input data for SignedCertificateTimestampList");for(;t.length;)this.timestamps.push(new ut({stream:t}))}toSchema(){const e=new ht;let t=0;const s=[];for(const r of this.timestamps){const e=r.toStream();s.push(e),t+=e.stream.buffer.byteLength}e.appendUint16(t);for(const r of s)e.appendView(r.stream.view);return new A({valueHex:e.stream.buffer.slice(0)})}toJSON(){return{timestamps:Array.from(this.timestamps,e=>e.toJSON())}}}class mt{constructor(t={}){this.templateID=e(t,"templateID",mt.defaultValues("templateID")),"templateMajorVersion"in t&&(this.templateMajorVersion=e(t,"templateMajorVersion",mt.defaultValues("templateMajorVersion"))),"templateMinorVersion"in t&&(this.templateMinorVersion=e(t,"templateMinorVersion",mt.defaultValues("templateMinorVersion"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"templateID":return"";case"templateMajorVersion":case"templateMinorVersion":return 0;default:throw new Error("Invalid member name for CertificateTemplate class: "+e)}}static schema(t={}){const i=e(t,"names",{});return new s({name:i.blockName||"",value:[new r({name:i.templateID||""}),new w({name:i.templateMajorVersion||"",optional:!0}),new w({name:i.templateMinorVersion||"",optional:!0})]})}fromSchema(e){i(e,["templateID","templateMajorVersion","templateMinorVersion"]);let t=a(e,e,mt.schema({names:{templateID:"templateID",templateMajorVersion:"templateMajorVersion",templateMinorVersion:"templateMinorVersion"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificateTemplate");this.templateID=t.result.templateID.valueBlock.toString(),"templateMajorVersion"in t.result&&(this.templateMajorVersion=t.result.templateMajorVersion.valueBlock.valueDec),"templateMinorVersion"in t.result&&(this.templateMinorVersion=t.result.templateMinorVersion.valueBlock.valueDec)}toSchema(){const e=[];return e.push(new r({value:this.templateID})),"templateMajorVersion"in this&&e.push(new w({value:this.templateMajorVersion})),"templateMinorVersion"in this&&e.push(new w({value:this.templateMinorVersion})),new s({value:e})}toJSON(){const e={extnID:this.templateID};return"templateMajorVersion"in this&&(e.templateMajorVersion=this.templateMajorVersion),"templateMinorVersion"in this&&(e.templateMinorVersion=this.templateMinorVersion),e}}class wt{constructor(t={}){this.certificateIndex=e(t,"certificateIndex",wt.defaultValues("certificateIndex")),this.keyIndex=e(t,"keyIndex",wt.defaultValues("keyIndex")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"certificateIndex":case"keyIndex":return 0;default:throw new Error("Invalid member name for CAVersion class: "+e)}}static schema(e={}){return new w}fromSchema(e){if(e.constructor.blockName()!==w.blockName())throw new Error("Object's schema was not verified against input data for CAVersion");let t=e.valueBlock.valueHex.slice(0);const s=new Uint8Array(t);switch(!0){case t.byteLength<4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(s,4-t.byteLength),t=e.slice(0)}break;case t.byteLength>4:{const e=new ArrayBuffer(4);new Uint8Array(e).set(s.slice(0,4)),t=e.slice(0)}}const r=t.slice(0,2),i=new Uint8Array(r);let a=i[0];i[0]=i[1],i[1]=a;const n=new Uint16Array(r);this.keyIndex=n[0];const o=t.slice(2),c=new Uint8Array(o);a=c[0],c[0]=c[1],c[1]=a;const h=new Uint16Array(o);this.certificateIndex=h[0]}toSchema(){const e=new ArrayBuffer(2);new Uint16Array(e)[0]=this.certificateIndex;const t=new Uint8Array(e);let s=t[0];t[0]=t[1],t[1]=s;const r=new ArrayBuffer(2);new Uint16Array(r)[0]=this.keyIndex;const i=new Uint8Array(r);return s=i[0],i[0]=i[1],i[1]=s,new w({valueHex:c(r,e)})}toJSON(){return{certificateIndex:this.certificateIndex,keyIndex:this.keyIndex}}}class ft{constructor(t={}){this.id=e(t,"id",ft.defaultValues("id")),"type"in t&&(this.type=e(t,"type",ft.defaultValues("type"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"id":return"";case"type":return new p;default:throw new Error("Invalid member name for QCStatement class: "+e)}}static compareWithDefault(e,t){switch(e){case"id":return""===t;case"type":return t instanceof p;default:throw new Error("Invalid member name for QCStatement class: "+e)}}static schema(i={}){const a=e(i,"names",{});return new s({name:a.blockName||"",value:[new r({name:a.id||""}),new t({name:a.type||"",optional:!0})]})}fromSchema(e){i(e,["id","type"]);const t=a(e,e,ft.schema({names:{id:"id",type:"type"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for QCStatement");this.id=t.result.id.valueBlock.toString(),"type"in t.result&&(this.type=t.result.type)}toSchema(){const e=[new r({value:this.id})];return"type"in this&&e.push(this.type),new s({value:e})}toJSON(){const e={id:this.id};return"type"in this&&(e.type=this.type.toJSON()),e}}class dt{constructor(t={}){this.values=e(t,"values",dt.defaultValues("values")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"values":return[];default:throw new Error("Invalid member name for QCStatements class: "+e)}}static compareWithDefault(e,t){switch(e){case"values":return 0===t.length;default:throw new Error("Invalid member name for QCStatements class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[new g({name:r.values||"",value:ft.schema(r.value||{})})]})}fromSchema(e){i(e,["values"]);const t=a(e,e,dt.schema({names:{values:"values"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for QCStatements");this.values=Array.from(t.result.values,e=>new ft({schema:e}))}toSchema(){return new s({value:Array.from(this.values,e=>e.toSchema())})}toJSON(){return{extensions:Array.from(this.values,e=>e.toJSON())}}}class yt{constructor(t={}){this.extnID=e(t,"extnID",yt.defaultValues("extnID")),this.critical=e(t,"critical",yt.defaultValues("critical")),this.extnValue="extnValue"in t?new A({valueHex:t.extnValue}):yt.defaultValues("extnValue"),"parsedValue"in t&&(this.parsedValue=e(t,"parsedValue",yt.defaultValues("parsedValue"))),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"extnID":return"";case"critical":return!1;case"extnValue":return new A;case"parsedValue":return{};default:throw new Error("Invalid member name for Extension class: "+e)}}static schema(t={}){const i=e(t,"names",{});return new s({name:i.blockName||"",value:[new r({name:i.extnID||""}),new V({name:i.critical||"",optional:!0}),new A({name:i.extnValue||""})]})}fromSchema(e){i(e,["extnID","critical","extnValue"]);let t=a(e,e,yt.schema({names:{extnID:"extnID",critical:"critical",extnValue:"extnValue"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Extension");if(this.extnID=t.result.extnID.valueBlock.toString(),"critical"in t.result&&(this.critical=t.result.critical.valueBlock.value),this.extnValue=t.result.extnValue,t=y(this.extnValue.valueBlock.valueHex),-1!==t.offset)switch(this.extnID){case"2.5.29.9":try{this.parsedValue=new Ve({schema:t.result})}catch(s){this.parsedValue=new Ve,this.parsedValue.parsingError="Incorrectly formated SubjectDirectoryAttributes"}break;case"2.5.29.14":case"2.5.29.15":this.parsedValue=t.result;break;case"2.5.29.16":try{this.parsedValue=new Me({schema:t.result})}catch(s){this.parsedValue=new Me,this.parsedValue.parsingError="Incorrectly formated PrivateKeyUsagePeriod"}break;case"2.5.29.17":case"2.5.29.18":try{this.parsedValue=new Fe({schema:t.result})}catch(s){this.parsedValue=new Fe,this.parsedValue.parsingError="Incorrectly formated AltName"}break;case"2.5.29.19":try{this.parsedValue=new _e({schema:t.result})}catch(s){this.parsedValue=new _e,this.parsedValue.parsingError="Incorrectly formated BasicConstraints"}break;case"2.5.29.20":case"2.5.29.27":case"2.5.29.21":case"2.5.29.24":this.parsedValue=t.result;break;case"2.5.29.28":try{this.parsedValue=new We({schema:t.result})}catch(s){this.parsedValue=new We,this.parsedValue.parsingError="Incorrectly formated IssuingDistributionPoint"}break;case"2.5.29.29":try{this.parsedValue=new Qe({schema:t.result})}catch(s){this.parsedValue=new Qe,this.parsedValue.parsingError="Incorrectly formated GeneralNames"}break;case"2.5.29.30":try{this.parsedValue=new ze({schema:t.result})}catch(s){this.parsedValue=new ze,this.parsedValue.parsingError="Incorrectly formated NameConstraints"}break;case"2.5.29.31":case"2.5.29.46":try{this.parsedValue=new Xe({schema:t.result})}catch(s){this.parsedValue=new Xe,this.parsedValue.parsingError="Incorrectly formated CRLDistributionPoints"}break;case"2.5.29.32":case"1.3.6.1.4.1.311.21.10":try{this.parsedValue=new et({schema:t.result})}catch(s){this.parsedValue=new et,this.parsedValue.parsingError="Incorrectly formated CertificatePolicies"}break;case"2.5.29.33":try{this.parsedValue=new st({schema:t.result})}catch(s){this.parsedValue=new st,this.parsedValue.parsingError="Incorrectly formated CertificatePolicies"}break;case"2.5.29.35":try{this.parsedValue=new rt({schema:t.result})}catch(s){this.parsedValue=new rt,this.parsedValue.parsingError="Incorrectly formated AuthorityKeyIdentifier"}break;case"2.5.29.36":try{this.parsedValue=new it({schema:t.result})}catch(s){this.parsedValue=new it,this.parsedValue.parsingError="Incorrectly formated PolicyConstraints"}break;case"2.5.29.37":try{this.parsedValue=new at({schema:t.result})}catch(s){this.parsedValue=new at,this.parsedValue.parsingError="Incorrectly formated ExtKeyUsage"}break;case"2.5.29.54":this.parsedValue=t.result;break;case"1.3.6.1.5.5.7.1.1":case"1.3.6.1.5.5.7.1.11":try{this.parsedValue=new ot({schema:t.result})}catch(s){this.parsedValue=new ot,this.parsedValue.parsingError="Incorrectly formated InfoAccess"}break;case"1.3.6.1.4.1.11129.2.4.2":try{this.parsedValue=new lt({schema:t.result})}catch(s){this.parsedValue=new lt,this.parsedValue.parsingError="Incorrectly formated SignedCertificateTimestampList"}break;case"1.3.6.1.4.1.311.20.2":case"1.3.6.1.4.1.311.21.2":this.parsedValue=t.result;break;case"1.3.6.1.4.1.311.21.7":try{this.parsedValue=new mt({schema:t.result})}catch(s){this.parsedValue=new mt,this.parsedValue.parsingError="Incorrectly formated CertificateTemplate"}break;case"1.3.6.1.4.1.311.21.1":try{this.parsedValue=new wt({schema:t.result})}catch(s){this.parsedValue=new wt,this.parsedValue.parsingError="Incorrectly formated CAVersion"}break;case"1.3.6.1.5.5.7.1.3":try{this.parsedValue=new dt({schema:t.result})}catch(s){this.parsedValue=new dt,this.parsedValue.parsingError="Incorrectly formated QCStatements"}}}toSchema(){const e=[];return e.push(new r({value:this.extnID})),this.critical!==yt.defaultValues("critical")&&e.push(new V({value:this.critical})),e.push(this.extnValue),new s({value:e})}toJSON(){const e={extnID:this.extnID,extnValue:this.extnValue.toJSON()};return this.critical!==yt.defaultValues("critical")&&(e.critical=this.critical),"parsedValue"in this&&"toJSON"in this.parsedValue&&(e.parsedValue=this.parsedValue.toJSON()),e}}class pt{constructor(t={}){this.extensions=e(t,"extensions",pt.defaultValues("extensions")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"extensions":return[];default:throw new Error("Invalid member name for Extensions class: "+e)}}static schema(t={},r=!1){const i=e(t,"names",{});return new s({optional:r,name:i.blockName||"",value:[new g({name:i.extensions||"",value:yt.schema(i.extension||{})})]})}fromSchema(e){i(e,["extensions"]);const t=a(e,e,pt.schema({names:{extensions:"extensions"}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Extensions");this.extensions=Array.from(t.result.extensions,e=>new yt({schema:e}))}toSchema(){return new s({value:Array.from(this.extensions,e=>e.toSchema())})}toJSON(){return{extensions:Array.from(this.extensions,e=>e.toJSON())}}}function bt(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"tbsCertificate",value:[new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new w({name:r.tbsCertificateVersion||"tbsCertificate.version"})]}),new w({name:r.tbsCertificateSerialNumber||"tbsCertificate.serialNumber"}),de.schema(r.signature||{names:{blockName:"tbsCertificate.signature"}}),Ke.schema(r.issuer||{names:{blockName:"tbsCertificate.issuer"}}),new s({name:r.tbsCertificateValidity||"tbsCertificate.validity",value:[Re.schema(r.notBefore||{names:{utcTimeName:"tbsCertificate.notBefore",generalTimeName:"tbsCertificate.notBefore"}}),Re.schema(r.notAfter||{names:{utcTimeName:"tbsCertificate.notAfter",generalTimeName:"tbsCertificate.notAfter"}})]}),Ke.schema(r.subject||{names:{blockName:"tbsCertificate.subject"}}),be.schema(r.subjectPublicKeyInfo||{names:{blockName:"tbsCertificate.subjectPublicKeyInfo"}}),new k({name:r.tbsCertificateIssuerUniqueID||"tbsCertificate.issuerUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:1}}),new k({name:r.tbsCertificateSubjectUniqueID||"tbsCertificate.subjectUniqueID",optional:!0,idBlock:{tagClass:3,tagNumber:2}}),new v({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[pt.schema(r.extensions||{names:{blockName:"tbsCertificate.extensions"}})]})]})}class gt{constructor(t={}){this.tbs=e(t,"tbs",gt.defaultValues("tbs")),this.version=e(t,"version",gt.defaultValues("version")),this.serialNumber=e(t,"serialNumber",gt.defaultValues("serialNumber")),this.signature=e(t,"signature",gt.defaultValues("signature")),this.issuer=e(t,"issuer",gt.defaultValues("issuer")),this.notBefore=e(t,"notBefore",gt.defaultValues("notBefore")),this.notAfter=e(t,"notAfter",gt.defaultValues("notAfter")),this.subject=e(t,"subject",gt.defaultValues("subject")),this.subjectPublicKeyInfo=e(t,"subjectPublicKeyInfo",gt.defaultValues("subjectPublicKeyInfo")),"issuerUniqueID"in t&&(this.issuerUniqueID=e(t,"issuerUniqueID",gt.defaultValues("issuerUniqueID"))),"subjectUniqueID"in t&&(this.subjectUniqueID=e(t,"subjectUniqueID",gt.defaultValues("subjectUniqueID"))),"extensions"in t&&(this.extensions=e(t,"extensions",gt.defaultValues("extensions"))),this.signatureAlgorithm=e(t,"signatureAlgorithm",gt.defaultValues("signatureAlgorithm")),this.signatureValue=e(t,"signatureValue",gt.defaultValues("signatureValue")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"version":return 0;case"serialNumber":return new w;case"signature":return new de;case"issuer":return new Ke;case"notBefore":case"notAfter":return new Re;case"subject":return new Ke;case"subjectPublicKeyInfo":return new be;case"issuerUniqueID":case"subjectUniqueID":return new ArrayBuffer(0);case"extensions":return[];case"signatureAlgorithm":return new de;case"signatureValue":return new d;default:throw new Error("Invalid member name for Certificate class: "+e)}}static schema(t={}){const r=e(t,"names",{});return new s({name:r.blockName||"",value:[bt(r.tbsCertificate),de.schema(r.signatureAlgorithm||{names:{blockName:"signatureAlgorithm"}}),new d({name:r.signatureValue||"signatureValue"})]})}fromSchema(e){i(e,["tbsCertificate","tbsCertificate.extensions","tbsCertificate.version","tbsCertificate.serialNumber","tbsCertificate.signature","tbsCertificate.issuer","tbsCertificate.notBefore","tbsCertificate.notAfter","tbsCertificate.subject","tbsCertificate.subjectPublicKeyInfo","tbsCertificate.issuerUniqueID","tbsCertificate.subjectUniqueID","signatureAlgorithm","signatureValue"]);const t=a(e,e,gt.schema({names:{tbsCertificate:{names:{extensions:{names:{extensions:"tbsCertificate.extensions"}}}}}}));if(!1===t.verified)throw new Error("Object's schema was not verified against input data for Certificate");this.tbs=t.result.tbsCertificate.valueBeforeDecode,"tbsCertificate.version"in t.result&&(this.version=t.result["tbsCertificate.version"].valueBlock.valueDec),this.serialNumber=t.result["tbsCertificate.serialNumber"],this.signature=new de({schema:t.result["tbsCertificate.signature"]}),this.issuer=new Ke({schema:t.result["tbsCertificate.issuer"]}),this.notBefore=new Re({schema:t.result["tbsCertificate.notBefore"]}),this.notAfter=new Re({schema:t.result["tbsCertificate.notAfter"]}),this.subject=new Ke({schema:t.result["tbsCertificate.subject"]}),this.subjectPublicKeyInfo=new be({schema:t.result["tbsCertificate.subjectPublicKeyInfo"]}),"tbsCertificate.issuerUniqueID"in t.result&&(this.issuerUniqueID=t.result["tbsCertificate.issuerUniqueID"].valueBlock.valueHex),"tbsCertificate.subjectUniqueID"in t.result&&(this.subjectUniqueID=t.result["tbsCertificate.subjectUniqueID"].valueBlock.valueHex),"tbsCertificate.extensions"in t.result&&(this.extensions=Array.from(t.result["tbsCertificate.extensions"],e=>new yt({schema:e}))),this.signatureAlgorithm=new de({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[];return"version"in this&&this.version!==gt.defaultValues("version")&&e.push(new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new w({value:this.version})]})),e.push(this.serialNumber),e.push(this.signature.toSchema()),e.push(this.issuer.toSchema()),e.push(new s({value:[this.notBefore.toSchema(),this.notAfter.toSchema()]})),e.push(this.subject.toSchema()),e.push(this.subjectPublicKeyInfo.toSchema()),"issuerUniqueID"in this&&e.push(new k({optional:!0,idBlock:{tagClass:3,tagNumber:1},valueHex:this.issuerUniqueID})),"subjectUniqueID"in this&&e.push(new k({optional:!0,idBlock:{tagClass:3,tagNumber:2},valueHex:this.subjectUniqueID})),"extensions"in this&&e.push(new v({optional:!0,idBlock:{tagClass:3,tagNumber:3},value:[new s({value:Array.from(this.extensions,e=>e.toSchema())})]})),new s({value:e})}toSchema(e=!1){let t={};if(!1===e){if(0===this.tbs.length)return gt.schema().value[0];t=y(this.tbs).result}else t=this.encodeTBS();return new s({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:T(this.tbs,0,this.tbs.byteLength),serialNumber:this.serialNumber.toJSON(),signature:this.signature.toJSON(),issuer:this.issuer.toJSON(),notBefore:this.notBefore.toJSON(),notAfter:this.notAfter.toJSON(),subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return"version"in this&&this.version!==gt.defaultValues("version")&&(e.version=this.version),"issuerUniqueID"in this&&(e.issuerUniqueID=T(this.issuerUniqueID,0,this.issuerUniqueID.byteLength)),"subjectUniqueID"in this&&(e.subjectUniqueID=T(this.subjectUniqueID,0,this.subjectUniqueID.byteLength)),"extensions"in this&&(e.extensions=Array.from(this.extensions,e=>e.toJSON())),e}getPublicKey(e=null){return He().subtle.getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}getKeyHash(e="SHA-1"){const t=je();return void 0===t?Promise.reject("Unable to create WebCrypto object"):t.digest({name:e},new Uint8Array(this.subjectPublicKeyInfo.subjectPublicKey.valueBlock.valueHex))}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let s,r=Promise.resolve();const i=He();return r=r.then(()=>i.subtle.getSignatureParameters(e,t)),r=r.then(e=>{s=e.parameters,this.signature=e.signatureAlgorithm,this.signatureAlgorithm=e.signatureAlgorithm}),r=r.then(()=>{this.tbs=this.encodeTBS().toBER(!1)}),r=r.then(()=>i.subtle.signWithPrivateKey(this.tbs,e,s)),r=r.then(e=>{this.signatureValue=new d({valueHex:e})}),r}verify(e=null){let t={};return null!==e?t=e.subjectPublicKeyInfo:this.issuer.isEqual(this.subject)&&(t=this.subjectPublicKeyInfo),t instanceof be==0?Promise.reject("Please provide issuer certificate as a parameter"):He().subtle.verifyWithPublicKey(this.tbs,this.signatureValue,t,this.signatureAlgorithm)}}function At(t={}){const r=e(t,"names",{});return new s({name:r.CertificationRequestInfo||"CertificationRequestInfo",value:[new w({name:r.CertificationRequestInfoVersion||"CertificationRequestInfo.version"}),Ke.schema(r.subject||{names:{blockName:"CertificationRequestInfo.subject"}}),be.schema({names:{blockName:"CertificationRequestInfo.subjectPublicKeyInfo"}}),new v({optional:!0,idBlock:{tagClass:3,tagNumber:0},value:[new g({optional:!0,name:r.CertificationRequestInfoAttributes||"CertificationRequestInfo.attributes",value:ge.schema(r.attributes||{})})]})]})}class vt{constructor(t={}){this.tbs=e(t,"tbs",vt.defaultValues("tbs")),this.version=e(t,"version",vt.defaultValues("version")),this.subject=e(t,"subject",vt.defaultValues("subject")),this.subjectPublicKeyInfo=e(t,"subjectPublicKeyInfo",vt.defaultValues("subjectPublicKeyInfo")),"attributes"in t&&(this.attributes=e(t,"attributes",vt.defaultValues("attributes"))),this.signatureAlgorithm=e(t,"signatureAlgorithm",vt.defaultValues("signatureAlgorithm")),this.signatureValue=e(t,"signatureValue",vt.defaultValues("signatureValue")),"schema"in t&&this.fromSchema(t.schema)}static defaultValues(e){switch(e){case"tbs":return new ArrayBuffer(0);case"version":return 0;case"subject":return new Ke;case"subjectPublicKeyInfo":return new be;case"attributes":return[];case"signatureAlgorithm":return new de;case"signatureValue":return new d;default:throw new Error("Invalid member name for CertificationRequest class: "+e)}}static schema(i={}){const a=e(i,"names",{});return new s({value:[At(a.certificationRequestInfo||{}),new s({name:a.signatureAlgorithm||"signatureAlgorithm",value:[new r,new t({optional:!0})]}),new d({name:a.signatureValue||"signatureValue"})]})}fromSchema(e){i(e,["CertificationRequestInfo","CertificationRequestInfo.version","CertificationRequestInfo.subject","CertificationRequestInfo.subjectPublicKeyInfo","CertificationRequestInfo.attributes","signatureAlgorithm","signatureValue"]);const t=a(e,e,vt.schema());if(!1===t.verified)throw new Error("Object's schema was not verified against input data for CertificationRequest");this.tbs=t.result.CertificationRequestInfo.valueBeforeDecode,this.version=t.result["CertificationRequestInfo.version"].valueBlock.valueDec,this.subject=new Ke({schema:t.result["CertificationRequestInfo.subject"]}),this.subjectPublicKeyInfo=new be({schema:t.result["CertificationRequestInfo.subjectPublicKeyInfo"]}),"CertificationRequestInfo.attributes"in t.result&&(this.attributes=Array.from(t.result["CertificationRequestInfo.attributes"],e=>new ge({schema:e}))),this.signatureAlgorithm=new de({schema:t.result.signatureAlgorithm}),this.signatureValue=t.result.signatureValue}encodeTBS(){const e=[new w({value:this.version}),this.subject.toSchema(),this.subjectPublicKeyInfo.toSchema()];return"attributes"in this&&e.push(new v({idBlock:{tagClass:3,tagNumber:0},value:Array.from(this.attributes,e=>e.toSchema())})),new s({value:e})}toSchema(e=!1){let t;if(!1===e){if(0===this.tbs.byteLength)return vt.schema();t=y(this.tbs).result}else t=this.encodeTBS();return new s({value:[t,this.signatureAlgorithm.toSchema(),this.signatureValue]})}toJSON(){const e={tbs:T(this.tbs,0,this.tbs.byteLength),version:this.version,subject:this.subject.toJSON(),subjectPublicKeyInfo:this.subjectPublicKeyInfo.toJSON(),signatureAlgorithm:this.signatureAlgorithm.toJSON(),signatureValue:this.signatureValue.toJSON()};return"attributes"in this&&(e.attributes=Array.from(this.attributes,e=>e.toJSON())),e}sign(e,t="SHA-1"){if(void 0===e)return Promise.reject("Need to provide a private key for signing");let s,r=Promise.resolve();const i=He();return r=r.then(()=>i.subtle.getSignatureParameters(e,t)),r=r.then(e=>{s=e.parameters,this.signatureAlgorithm=e.signatureAlgorithm}),r=r.then(()=>{this.tbs=this.encodeTBS().toBER(!1)}),r=r.then(()=>i.subtle.signWithPrivateKey(this.tbs,e,s)),r=r.then(e=>{this.signatureValue=new d({valueHex:e})}),r}verify(){return He().subtle.verifyWithPublicKey(this.tbs,this.signatureValue,this.subjectPublicKeyInfo,this.signatureAlgorithm)}getPublicKey(e=null){return He().getPublicKey(this.subjectPublicKeyInfo,this.signatureAlgorithm,e)}}
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */var St;!function(e){e.CommonName="CN",e.Country="C",e.Region="L",e.State="ST",e.Organization="O",e.OrganizationUnit="OU"}(St||(St={}));const kt={[St.CommonName]:"2.5.4.3",[St.Country]:"2.5.4.6",[St.Region]:"2.5.4.7",[St.State]:"2.5.4.8",[St.Organization]:"2.5.4.10",[St.OrganizationUnit]:"2.5.4.11"};class Ct{static async csr(e,t,s){const r=new vt;Ue("Crypto",e,new xe({name:"Crypto",crypto:e,subtle:e.subtle}));const{publicKey:i,privateKey:a}=await e.subtle.generateKey(t,!1,Ct.keyUsages);return r.version=0,Object.keys(s).forEach(e=>{const t=s[e];t&&kt[e]&&r.subject.typesAndValues.push(new Oe({type:kt[e],value:new N({value:t})}))}),r.attributes=[],await r.subjectPublicKeyInfo.importKey(i),await r.sign(a,"SHA-256"),r.signatureAlgorithm.algorithmParams||(r.signatureAlgorithm.algorithmParams=new p),{der:r.toSchema().toBER(!1),privateKey:a,publicKey:i}}static async x509(e,t,s,r){const i=new gt;Ue("Crypto",e,new xe({name:"Crypto",crypto:e,subtle:e.subtle}));const{publicKey:a,privateKey:n}=await e.subtle.generateKey(t,!1,Ct.keyUsages);i.version=2,i.serialNumber=new w({value:1}),Object.keys(s).forEach(e=>{const t=s[e];t&&kt[e]&&i.subject.typesAndValues.push(new Oe({type:kt[e],value:new N({value:t})}))}),Object.keys(r).forEach(e=>{const t=r[e];t&&kt[e]&&i.issuer.typesAndValues.push(new Oe({type:kt[e],value:new N({value:t})}))});const o=new Date;i.notBefore.value=new Date(o.getFullYear(),o.getMonth(),o.getDate()),i.notAfter.value=new Date(o.getFullYear()+1,o.getMonth(),o.getDate()),i.extensions=[];const c=new _e({cA:!0,pathLenConstraint:3});i.extensions.push(new yt({extnID:"2.5.29.19",critical:!0,extnValue:c.toSchema().toBER(!1),parsedValue:c}));const h=new ArrayBuffer(1),u=new Uint8Array(h);u[0]|=2,u[0]|=4,u[0]|=128;const l=new d({valueHex:h});i.extensions.push(new yt({extnID:"2.5.29.15",critical:!1,extnValue:l.toBER(!1),parsedValue:l}));const m=new at({keyPurposes:["2.5.29.37.0","1.3.6.1.5.5.7.3.1","1.3.6.1.5.5.7.3.2","1.3.6.1.5.5.7.3.3","1.3.6.1.5.5.7.3.4","1.3.6.1.5.5.7.3.8","1.3.6.1.5.5.7.3.9","1.3.6.1.4.1.311.10.3.1","1.3.6.1.4.1.311.10.3.4"]});return i.extensions.push(new yt({extnID:"2.5.29.37",critical:!1,extnValue:m.toSchema().toBER(!1),parsedValue:m})),await i.subjectPublicKeyInfo.importKey(a),await i.sign(n,"SHA-256"),{der:i.toSchema(!0).toBER(!1),privateKey:n,publicKey:a}}}Ct.keyUsages=["sign","verify"];
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */
class Pt{constructor(...e){1===e.length?(this.asn=e[0],this.rawData=q.serialize(this.asn)):(this.asn=q.parse(e[0],e[1]),this.rawData=Y.BufferSourceConverter.toArrayBuffer(e[0]))}}
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */class Et extends Pt{constructor(e){super(e,J);const t=this.getAsnExtnValue();switch(this.asn.extnID){case z:this.value=_.parse(t,$);break;case Q:this.value=_.parse(t,G);break;case F:this.value=_.parse(t,W);break;default:this.value=t}}getAsnExtnValue(){return this.asn.extnValue.buffer}}
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */class It extends Pt{constructor(e){super(e,X),this.extensions=[],this.parseExtensions()}parseExtensions(){const{tbsCertificate:e}=this.asn;e.extensions&&(this.extensions=e.extensions.map(e=>new Et(q.serialize(e))))}getExtensionByOid(e){if(this.extensions.length)for(let t=0;t<this.extensions.length;t+=1){const s=this.extensions[t];if(s&&s.asn.extnID===e)return s}}hasKeyUsage(e){if(!e||!e.length)return!1;const t=this.getExtensionByOid(z);if(!t)return!1;const s=t.value.toJSON();if(!s.length)return!1;const r=[...e];for(let i=0;i<s.length&&r.length;i+=1){const e=r.indexOf(s[i]);-1!==e&&r.splice(e,1)}return!r.length}isQualified(e=[]){const t=this.getExtensionByOid(Q);if(!t)return!1;const s=this.getExtensionByOid(F);if(!s)return!1;const r=t.value.map(e=>e.policyIdentifier),i=s.value.map(e=>e.statementId),a=i.includes("0.4.0.1862.1.1");let n=r.includes("0.4.0.1456.1.1")||r.includes("0.4.0.194112.1.3")||r.includes("0.4.0.194112.1.2")||i.includes("0.4.0.1862.1.4");const o=r.includes("0.4.0.194112.1.1")||i.includes("0.4.0.1862.1.6.2");return e.length&&e.forEach(e=>{i.includes(e)&&(n=!0)}),!!(a&&n||o)}}
/**
 * @license
 * Copyright (c) Peculiar Ventures, LLC.
 *
 * This source code is licensed under the BSD 3-Clause license found in the
 * LICENSE file in the root directory of this source tree.
 */var Nt,xt,Bt,Ut,Ht,jt=function(e,t){if(!t.has(e))throw new TypeError("attempted to get private field on non-instance");return t.get(e)},Dt=function(e,t,s){if(!t.has(e))throw new TypeError("attempted to set private field on non-instance");return t.set(e,s),s};!function(e){e.RSASSA_PKCS1_V1_5="RSASSA-PKCS1-V1_5",e.ECDSA="ECDSA"}(Ut||(Ut={})),function(e){e.SHA_256="SHA-256",e.SHA_384="SHA-384",e.SHA_512="SHA-512"}(Ht||(Ht={}));class Ot{constructor(e){this.FORTIFY_URL="127.0.0.1:31337",this.CONNECTION_CHECK_TIME=1e4,this.options={onClose:()=>{},onProvidersAdded:()=>{},onProvidersRemoved:()=>{},filters:{}},Nt.set(this,void 0),xt.set(this,function(e){var t={userAgent:"",platform:"",maxTouchPoints:0};e||"undefined"==typeof navigator?"string"==typeof e?t.userAgent=e:e&&e.userAgent&&(t={userAgent:e.userAgent,platform:e.platform,maxTouchPoints:e.maxTouchPoints||0}):t={userAgent:navigator.userAgent,platform:navigator.platform,maxTouchPoints:navigator.maxTouchPoints||0};var s=t.userAgent,r=s.split("[FBAN");void 0!==r[1]&&(s=r[0]),void 0!==(r=s.split("Twitter"))[1]&&(s=r[0]);var i=function(e){return function(t){return t.test(e)}}(s),a={apple:{phone:i(Z)&&!i(oe),ipod:i(ee),tablet:!i(Z)&&(i(te)||fe(t))&&!i(oe),universal:i(se),device:(i(Z)||i(ee)||i(te)||i(se)||fe(t))&&!i(oe)},amazon:{phone:i(ae),tablet:!i(ae)&&i(ne),device:i(ae)||i(ne)},android:{phone:!i(oe)&&i(ae)||!i(oe)&&i(re),tablet:!i(oe)&&!i(ae)&&!i(re)&&(i(ne)||i(ie)),device:!i(oe)&&(i(ae)||i(ne)||i(re)||i(ie))||i(/\bokhttp\b/i)},windows:{phone:i(oe),tablet:i(ce),device:i(oe)||i(ce)},other:{blackberry:i(he),blackberry10:i(ue),opera:i(le),firefox:i(we),chrome:i(me),device:i(he)||i(ue)||i(le)||i(we)||i(me)},any:!1,phone:!1,tablet:!1};return a.any=a.apple.device||a.android.device||a.windows.device||a.other.device,a.phone=a.apple.phone||a.android.phone||a.windows.phone,a.tablet=a.apple.tablet||a.android.tablet||a.windows.tablet,a}(window.navigator)),Bt.set(this,void 0),Object.assign(this.options,e)}isConnectionSupported(){return!jt(this,xt).phone}async isConnectionDetected(){try{return(await fetch(`https://${this.FORTIFY_URL}/.well-known/webcrypto-socket`)).ok}catch(e){return!1}}async isConnectionDetectedAuto(){return new Promise(e=>{const t=async()=>{await this.isConnectionDetected()?e():Dt(this,Bt,window.setTimeout(t,this.CONNECTION_CHECK_TIME))};t()})}async start(){if(!this.isConnectionSupported())throw new Error("connection_not_supported");if(!(await this.isConnectionDetected()))throw new Error("connection_not_detected");await this.connect()}finish(){this.server&&(this.server.client.close(),this.server=null),jt(this,Bt)&&(clearTimeout(jt(this,Bt)),Dt(this,Bt,null))}async challenge(){if(!(await this.server.isLoggedIn()))return this.server.challenge()}async login(){try{await this.server.login()}catch(e){throw new Error("connection_key_not_approved")}}async connect(){if(await(async()=>{(/edge\/([\d.]+)/i.test(window.navigator.userAgent)||/firefox/i.test(window.navigator.userAgent)||window.document.documentMode)&&(window.asmCrypto||(window.asmCrypto=await __sc_import_peculiar("./p-83affd65.js")),window.elliptic||(window.elliptic=(await __sc_import_peculiar("./p-18df18da.js").then((function(e){return e.e}))).default),await __sc_import_peculiar("./p-b47e72cc.js")),window.protobuf||await __sc_import_peculiar("./p-17d01039.js").then((function(e){return e.p})),window.WebcryptoSocket||await __sc_import_peculiar("./p-e36255a8.js")})(),!jt(this,Nt))try{Dt(this,Nt,await WebcryptoSocket.BrowserStorage.create())}catch(e){Dt(this,Nt,new WebcryptoSocket.MemoryStorage)}return new Promise((e,t)=>{this.server&&e(),this.server=new WebcryptoSocket.SocketProvider({storage:jt(this,Nt)}).connect(this.FORTIFY_URL).on("error",e=>{t(e)}).on("listening",async()=>{e()}).on("token",async e=>{if(e.added.length){const t=e.added.filter(e=>this.providerFilter(e));this.options.onProvidersAdded(t)}e.removed.length&&this.options.onProvidersRemoved(e.removed)}).on("disconnect",()=>{console.log("disconnect")}).on("close",()=>{this.options.onClose()})})}providerFilter(e){const{filters:t}=this.options;if(t.onlySmartcards&&!e.isRemovable)return!1;if(t.providerNameMatch){if("string"==typeof t.providerNameMatch&&!new RegExp(t.providerNameMatch,"i").test(e.name))return!1;if(t.providerNameMatch instanceof RegExp&&!t.providerNameMatch.test(e.name))return!1}return!0}async getProviders(){return(await this.server.info()).providers.filter(e=>this.providerFilter(e))}async getProviderById(e,t){const s=await this.server.getCrypto(e);return t&&(await s.isLoggedIn()||await s.login()),s}async getCertificatesByProviders(e){const t=[];for(const s of e){const e=await this.getCertificatesByProviderId(s.id);t.push(...e)}return t}certificatePreFilter(e){const{filters:t}=this.options;if("x509"!==e.split("-")[0])return!1;if(t.certificateIdMatch){let s;if("string"==typeof t.certificateIdMatch?s=new RegExp(t.certificateIdMatch,"i"):t.certificateIdMatch instanceof RegExp&&(s=t.certificateIdMatch),s&&!s.test(e))return!1}return!0}async certificateFilter(e,t){const{filters:s}=this.options;if(!s.expired&&e.notAfter.getTime()<Date.now())return!1;if(s.subjectDNMatch){let t;if("string"==typeof s.subjectDNMatch?t=new RegExp(s.subjectDNMatch,"i"):s.subjectDNMatch instanceof RegExp&&(t=s.subjectDNMatch),t&&!t.test(e.subjectName))return!1}if(s.issuerDNMatch){let t;if("string"==typeof s.issuerDNMatch?t=new RegExp(s.issuerDNMatch,"i"):s.issuerDNMatch instanceof RegExp&&(t=s.issuerDNMatch),t&&!t.test(e.issuerName))return!1}if(s.keyUsage&&s.keyUsage.length||s.onlyQualified){const r=await t.certStorage.exportCert("raw",e),i=new It(r);if(s.onlyQualified&&!i.isQualified(s.qualifiedCertificateStatements))return!1;if(s.keyUsage&&s.keyUsage.length&&!i.hasKeyUsage(s.keyUsage))return!1}return!0}async getCertificateByIndex(e,t,s){let r;try{r=await t.certStorage.getItem(e)}catch(i){return void console.warn("Can't read certificate: "+e)}if(await this.certificateFilter(r,t))return r.index=e,r.subject=Ot.getDNValue(r.subjectName),r.issuer=Ot.getDNValue(r.issuerName),r.privateKeyId=s,r}async getCertificatesByProviderId(e){const{filters:t}=this.options;let s;try{s=await this.getProviderById(e,t.onlyWithPrivateKey)}catch(n){return[]}const r=[],i=await s.keyStorage.keys(),a=await s.certStorage.keys();for(const o of a){if(!this.certificatePreFilter(o))continue;const e=Ot.getCertificatePrivateKeyByIndex(o,i);t.onlyWithPrivateKey&&!e||r.push(this.getCertificateByIndex(o,s,e))}return(await Promise.all(r)).filter(e=>!!e)}async getCertificateBodyById(e,t){const{filters:s}=this.options,r=await this.getProviderById(e,s.onlyWithPrivateKey),i=await r.certStorage.getItem(t),a=await r.certStorage.exportCert("raw",i);return Y.Convert.ToBase64(a)}static getCertificatePrivateKeyByIndex(e,t){const s=t.filter(t=>{const s=t.split("-");return"private"===s[0]&&s[2]===e.split("-")[2]})[0];if(s)return s}static getDNValue(e){const t={};return e.split(/, /g).forEach(e=>{const[s,r]=e.split("=");t[s]=r}),t}async createX509(e,t){const s=await this.getProviderById(e,!0);let r;switch(s.exportKey=s.subtle.exportKey.bind(s.subtle),s.sign=s.subtle.sign.bind(s.subtle),s.digest=s.subtle.digest.bind(s.subtle),t.publicKey.signatureAlgorithm){case Ut.RSASSA_PKCS1_V1_5:r={hash:t.publicKey.hashAlgorithm,name:t.publicKey.signatureAlgorithm,publicExponent:new Uint8Array([1,0,1]),modulusLength:2048};break;case Ut.ECDSA:r={hash:t.publicKey.hashAlgorithm,name:t.publicKey.signatureAlgorithm,namedCurve:"P-256"};break;default:console.error("Unsupported signature algorithm name:",t.publicKey.signatureAlgorithm)}const i=await Ct.x509(s,r,t.subject,t.subject),a=await s.certStorage.importCert("raw",i.der,r,Ct.keyUsages);return await s.keyStorage.setItem(i.privateKey),await s.keyStorage.setItem(i.publicKey),await s.certStorage.setItem(a),i}async createCSR(e,t){const s=await this.getProviderById(e,!0);let r;switch(s.exportKey=s.subtle.exportKey.bind(s.subtle),s.sign=s.subtle.sign.bind(s.subtle),s.digest=s.subtle.digest.bind(s.subtle),t.publicKey.signatureAlgorithm){case Ut.RSASSA_PKCS1_V1_5:r={hash:t.publicKey.hashAlgorithm,name:t.publicKey.signatureAlgorithm,publicExponent:new Uint8Array([1,0,1]),modulusLength:2048};break;case Ut.ECDSA:r={hash:t.publicKey.hashAlgorithm,name:t.publicKey.signatureAlgorithm,namedCurve:"P-256"};break;default:console.error("Unsupported signature algorithm name:",t.publicKey.signatureAlgorithm)}const i=await Ct.csr(s,r,t.subject),a=await s.certStorage.importCert("raw",i.der,r,Ct.keyUsages);return await s.keyStorage.setItem(i.privateKey),await s.keyStorage.setItem(i.publicKey),await s.certStorage.setItem(a),i}}Nt=new WeakMap,xt=new WeakMap,Bt=new WeakMap;export{Ut as E,Ot as F,Ht as a,St as b}